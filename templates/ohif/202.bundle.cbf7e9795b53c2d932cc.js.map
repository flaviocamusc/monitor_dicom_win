{"version":3,"file":"202.bundle.cbf7e9795b53c2d932cc.js","mappings":"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","sources":["webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/helpers/toArray.ts","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/helpers/codeMeaningEquals.ts","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/helpers/downloadDICOMData.ts","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/helpers/graphicTypeEquals.ts","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone/MeasurementReport.js","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone/cornerstone4Tag.js","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone/Length.js","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone/FreehandRoi.js","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone/Bidirectional.js","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone/EllipticalRoi.js","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone/CircleRoi.js","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone/ArrowAnnotate.js","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone/CobbAngle.js","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone/Angle.js","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone/RectangleRoi.js","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone/Segmentation_3X.js","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/enums/Events.ts","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone/Segmentation_4X.js","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone/Segmentation.js","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone/index.ts","webpack:///../../../node_modules/node_modules/tslib/tslib.es6.js","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone3D/cornerstone3DTag.js","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone3D/CodingScheme.js","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone3D/MeasurementReport.ts","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone3D/ArrowAnnotate.js","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone3D/Bidirectional.ts","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone3D/Angle.ts","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone3D/CobbAngle.ts","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone3D/isValidCornerstoneTrackingIdentifier.ts","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone3D/CircleROI.ts","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone3D/EllipticalROI.ts","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone3D/RectangleROI.ts","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone3D/Length.js","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone3D/PlanarFreehandROI.ts","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone3D/Probe.js","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone3D/Segmentation/generateSegmentation.ts","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone3D/Segmentation/generateToolState.ts","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/enums/Events.js","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone3D/Segmentation/generateLabelMaps2DFrom3D.ts","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/enums/SharedArrayBufferModes.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/eventTarget.js","webpack:///../../../node_modules/node_modules/fast-deep-equal/index.js","webpack:///../../../node_modules/node_modules/object-keys/isArguments.js","webpack:///../../../node_modules/node_modules/object-keys/index.js","webpack:///../../../node_modules/node_modules/object-keys/implementation.js","webpack:///../../../node_modules/node_modules/get-intrinsic/index.js","webpack:///../../../node_modules/node_modules/has-symbols/index.js","webpack:///../../../node_modules/node_modules/has-symbols/shams.js","webpack:///../../../node_modules/node_modules/has-proto/index.js","webpack:///../../../node_modules/node_modules/function-bind/implementation.js","webpack:///../../../node_modules/node_modules/function-bind/index.js","webpack:///../../../node_modules/node_modules/hasown/index.js","webpack:///../../../node_modules/node_modules/has-property-descriptors/index.js","webpack:///../../../node_modules/node_modules/define-data-property/index.js","webpack:///../../../node_modules/node_modules/gopd/index.js","webpack:///../../../node_modules/node_modules/define-properties/index.js","webpack:///../../../node_modules/node_modules/globalthis/implementation.browser.js","webpack:///../../../node_modules/node_modules/globalthis/polyfill.js","webpack:///../../../node_modules/node_modules/globalthis/shim.js","webpack:///../../../node_modules/node_modules/globalthis/index.js","webpack:///../../../node_modules/node_modules/@kitware/vtk.js/vtk.js","webpack:///../../../node_modules/node_modules/@kitware/vtk.js/Common/Core/ClassHierarchy.js","webpack:///../../../node_modules/node_modules/@kitware/vtk.js/macros2.js","webpack:///../../../node_modules/node_modules/seedrandom/lib/alea.js","webpack:///../../../node_modules/node_modules/seedrandom/lib/xor128.js","webpack:///../../../node_modules/node_modules/seedrandom/lib/xorwow.js","webpack:///../../../node_modules/node_modules/seedrandom/lib/xorshift7.js","webpack:///../../../node_modules/node_modules/seedrandom/lib/xor4096.js","webpack:///../../../node_modules/node_modules/seedrandom/lib/tychei.js","webpack:///../../../node_modules/node_modules/seedrandom/seedrandom.js","webpack:///../../../node_modules/node_modules/seedrandom/index.js","webpack:///../../../node_modules/node_modules/@kitware/vtk.js/Common/Core/Math/Constants.js","webpack:///../../../node_modules/node_modules/@kitware/vtk.js/Common/Core/Math/index.js","webpack:///../../../node_modules/node_modules/@kitware/vtk.js/Common/Core/DataArray/Constants.js","webpack:///../../../node_modules/node_modules/@kitware/vtk.js/Common/Core/DataArray.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/triggerEvent.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/imageIdToURI.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/init.js","webpack:///../../../node_modules/node_modules/@kitware/vtk.js/Common/DataModel/Plane.js","webpack:///../../../node_modules/node_modules/@kitware/vtk.js/Common/DataModel/BoundingBox.js","webpack:///../../../node_modules/node_modules/@kitware/vtk.js/Common/DataModel/DataSetAttributes/FieldData.js","webpack:///../../../node_modules/node_modules/@kitware/vtk.js/Common/DataModel/DataSetAttributes/Constants.js","webpack:///../../../node_modules/node_modules/@kitware/vtk.js/Common/DataModel/DataSetAttributes.js","webpack:///../../../node_modules/node_modules/@kitware/vtk.js/Common/DataModel/DataSet/Constants.js","webpack:///../../../node_modules/node_modules/@kitware/vtk.js/Common/DataModel/DataSet.js","webpack:///../../../node_modules/node_modules/@kitware/vtk.js/Common/DataModel/StructuredData/Constants.js","webpack:///../../../node_modules/node_modules/@kitware/vtk.js/Common/DataModel/StructuredData.js","webpack:///../../../node_modules/node_modules/@kitware/vtk.js/Common/DataModel/ImageData.js","webpack:///../../../node_modules/node_modules/@kitware/vtk.js/Rendering/OpenGL/Texture/Constants.js","webpack:///../../../node_modules/node_modules/@kitware/vtk.js/Common/Core/HalfFloat.js","webpack:///../../../node_modules/node_modules/@kitware/vtk.js/Rendering/SceneGraph/ViewNode.js","webpack:///../../../node_modules/node_modules/@kitware/vtk.js/Rendering/SceneGraph/ViewNodeFactory.js","webpack:///../../../node_modules/node_modules/@kitware/vtk.js/Rendering/OpenGL/ViewNodeFactory.js","webpack:///../../../node_modules/node_modules/@kitware/vtk.js/Rendering/OpenGL/Texture.js","webpack:///../../../node_modules/node_modules/@kitware/vtk.js/Common/Core/Points.js","webpack:///../../../node_modules/node_modules/@kitware/vtk.js/Common/Core/CellArray.js","webpack:///../../../node_modules/node_modules/@kitware/vtk.js/Common/DataModel/Cell.js","webpack:///../../../node_modules/node_modules/@kitware/vtk.js/Common/DataModel/CellLinks.js","webpack:///../../../node_modules/node_modules/@kitware/vtk.js/Common/DataModel/CellTypes/Constants.js","webpack:///../../../node_modules/node_modules/@kitware/vtk.js/Common/DataModel/CellTypes.js","webpack:///../../../node_modules/node_modules/@kitware/vtk.js/Common/DataModel/Line/Constants.js","webpack:///../../../node_modules/node_modules/@kitware/vtk.js/Common/DataModel/Line.js","webpack:///../../../node_modules/node_modules/@kitware/vtk.js/Common/DataModel/PointSet.js","webpack:///../../../node_modules/node_modules/@kitware/vtk.js/Common/DataModel/Triangle.js","webpack:///../../../node_modules/node_modules/@kitware/vtk.js/Common/DataModel/PolyData/Constants.js","webpack:///../../../node_modules/node_modules/@kitware/vtk.js/Common/DataModel/PolyData.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/vtkClasses/vtkStreamingOpenGLTexture.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/metaData.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/cache/classes/ImageVolume.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/isTypedArray.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getMinMax.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/cache/cache.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/genericMetadataProvider.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/enums/SegmentationRepresentations.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/contourFinder.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/mergePoints.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/detectContourHoles.js","webpack:///../../../node_modules/node_modules/@kitware/vtk.js/Common/DataModel/EdgeLocator.js","webpack:///../../../node_modules/node_modules/@kitware/vtk.js/Filters/General/ImageMarchingSquares/caseTable.js","webpack:///../../../node_modules/node_modules/@kitware/vtk.js/Filters/General/ImageMarchingSquares.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/generateContourSetsFromLabelmap.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/RectangleROIStartEndThreshold.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/AnnotationToPointData.js","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone3D/RTStruct/utilities/getReferencedFrameOfReferenceSequence.js","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone3D/RTStruct/utilities/getReferencedSeriesSequence.js","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone3D/RTStruct/utilities/getStructureSetModule.js","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone3D/RTStruct/RTSS.ts","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone3D/RTStruct/utilities/getPatientModule.js","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone3D/RTStruct/utilities/getRTSeriesModule.js","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone3D/RTStruct/index.ts","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone3D/RTStruct/utilities/getRTROIObservationsSequence.js","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone3D/index.ts","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/VTKjs/Segmentation.js","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/index.ts","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/VTKjs/index.ts","webpack:///../../../node_modules/iota-array/iota.js","webpack:///../../../node_modules/is-buffer/index.js","webpack:///../../../node_modules/ndarray/ndarray.js"],"sourcesContent":["const toArray = x => (Array.isArray(x) ? x : [x]);\n\nexport { toArray };\n","/**\n * Returns a function that checks if a given content item's ConceptNameCodeSequence.CodeMeaning\n * matches the provided codeMeaningName.\n * @param codeMeaningName - The CodeMeaning to match against.\n * @returns A function that takes a content item and returns a boolean indicating whether the\n * content item's CodeMeaning matches the provided codeMeaningName.\n */\nconst codeMeaningEquals = (codeMeaningName: string) => {\n    return (contentItem: any) => {\n        return (\n            contentItem.ConceptNameCodeSequence.CodeMeaning === codeMeaningName\n        );\n    };\n};\n\nexport { codeMeaningEquals };\n","import { data } from \"dcmjs\";\nimport { Buffer } from \"buffer\";\nconst { datasetToDict } = data;\n\ninterface DicomDataset {\n    _meta?: any;\n    // other properties\n}\n\n/**\n * Trigger file download from an array buffer\n * @param bufferOrDataset - ArrayBuffer or DicomDataset\n * @param filename - name of the file to download\n */\nexport function downloadDICOMData(\n    bufferOrDataset: ArrayBuffer | DicomDataset,\n    filename: string\n) {\n    let blob;\n    if (bufferOrDataset instanceof ArrayBuffer) {\n        blob = new Blob([bufferOrDataset], { type: \"application/dicom\" });\n    } else {\n        if (!bufferOrDataset._meta) {\n            throw new Error(\"Dataset must have a _meta property\");\n        }\n\n        const buffer = Buffer.from(datasetToDict(bufferOrDataset).write());\n        blob = new Blob([buffer], { type: \"application/dicom\" });\n    }\n\n    const link = document.createElement(\"a\");\n    link.href = window.URL.createObjectURL(blob);\n    link.download = filename;\n    link.click();\n}\n","/**\n * Checks if a given content item's GraphicType property matches a specified value.\n * @param {string} graphicType - The value to compare the content item's GraphicType property to.\n * @returns {function} A function that takes a content item and returns a boolean indicating whether its GraphicType property matches the specified value.\n */\nconst graphicTypeEquals = graphicType => {\n    return contentItem => {\n        return contentItem && contentItem.GraphicType === graphicType;\n    };\n};\n\nexport { graphicTypeEquals };\n","import { normalizers, data, utilities, derivations } from \"dcmjs\";\n\nimport { toArray, codeMeaningEquals } from \"../helpers\";\n\nconst { TID1500, addAccessors } = utilities;\n\nconst { StructuredReport } = derivations;\n\nconst { Normalizer } = normalizers;\n\nconst { TID1500MeasurementReport, TID1501MeasurementGroup } = TID1500;\n\nconst { DicomMetaDictionary } = data;\n\nconst FINDING = { CodingSchemeDesignator: \"DCM\", CodeValue: \"121071\" };\nconst FINDING_SITE = { CodingSchemeDesignator: \"SCT\", CodeValue: \"363698007\" };\nconst FINDING_SITE_OLD = { CodingSchemeDesignator: \"SRT\", CodeValue: \"G-C0E3\" };\n\nconst codeValueMatch = (group, code, oldCode) => {\n    const { ConceptNameCodeSequence } = group;\n    if (!ConceptNameCodeSequence) return;\n    const { CodingSchemeDesignator, CodeValue } = ConceptNameCodeSequence;\n    return (\n        (CodingSchemeDesignator == code.CodingSchemeDesignator &&\n            CodeValue == code.CodeValue) ||\n        (oldCode &&\n            CodingSchemeDesignator == oldCode.CodingSchemeDesignator &&\n            CodeValue == oldCode.CodeValue)\n    );\n};\n\nfunction getTID300ContentItem(\n    tool,\n    toolType,\n    ReferencedSOPSequence,\n    toolClass\n) {\n    const args = toolClass.getTID300RepresentationArguments(tool);\n    args.ReferencedSOPSequence = ReferencedSOPSequence;\n\n    const TID300Measurement = new toolClass.TID300Representation(args);\n\n    return TID300Measurement;\n}\n\nfunction getMeasurementGroup(toolType, toolData, ReferencedSOPSequence) {\n    const toolTypeData = toolData[toolType];\n    const toolClass =\n        MeasurementReport.CORNERSTONE_TOOL_CLASSES_BY_TOOL_TYPE[toolType];\n    if (\n        !toolTypeData ||\n        !toolTypeData.data ||\n        !toolTypeData.data.length ||\n        !toolClass\n    ) {\n        return;\n    }\n\n    // Loop through the array of tool instances\n    // for this tool\n    const Measurements = toolTypeData.data.map(tool => {\n        return getTID300ContentItem(\n            tool,\n            toolType,\n            ReferencedSOPSequence,\n            toolClass\n        );\n    });\n\n    return new TID1501MeasurementGroup(Measurements);\n}\n\nexport default class MeasurementReport {\n    static getSetupMeasurementData(MeasurementGroup) {\n        const { ContentSequence } = MeasurementGroup;\n\n        const contentSequenceArr = toArray(ContentSequence);\n        const findingGroup = contentSequenceArr.find(group =>\n            codeValueMatch(group, FINDING)\n        );\n        const findingSiteGroups =\n            contentSequenceArr.filter(group =>\n                codeValueMatch(group, FINDING_SITE, FINDING_SITE_OLD)\n            ) || [];\n        const NUMGroup = contentSequenceArr.find(\n            group => group.ValueType === \"NUM\"\n        );\n        const SCOORDGroup = toArray(NUMGroup.ContentSequence).find(\n            group => group.ValueType === \"SCOORD\"\n        );\n        const { ReferencedSOPSequence } = SCOORDGroup.ContentSequence;\n        const { ReferencedSOPInstanceUID, ReferencedFrameNumber } =\n            ReferencedSOPSequence;\n\n        const defaultState = {\n            sopInstanceUid: ReferencedSOPInstanceUID,\n            frameIndex: ReferencedFrameNumber || 1,\n            complete: true,\n            finding: findingGroup\n                ? addAccessors(findingGroup.ConceptCodeSequence)\n                : undefined,\n            findingSites: findingSiteGroups.map(fsg => {\n                return addAccessors(fsg.ConceptCodeSequence);\n            })\n        };\n        if (defaultState.finding) {\n            defaultState.description = defaultState.finding.CodeMeaning;\n        }\n        const findingSite =\n            defaultState.findingSites && defaultState.findingSites[0];\n        if (findingSite) {\n            defaultState.location =\n                (findingSite[0] && findingSite[0].CodeMeaning) ||\n                findingSite.CodeMeaning;\n        }\n        return {\n            defaultState,\n            findingGroup,\n            findingSiteGroups,\n            NUMGroup,\n            SCOORDGroup,\n            ReferencedSOPSequence,\n            ReferencedSOPInstanceUID,\n            ReferencedFrameNumber\n        };\n    }\n\n    static generateReport(toolState, metadataProvider, options) {\n        // ToolState for array of imageIDs to a Report\n        // Assume Cornerstone metadata provider has access to Study / Series / Sop Instance UID\n\n        let allMeasurementGroups = [];\n        const firstImageId = Object.keys(toolState)[0];\n        if (!firstImageId) {\n            throw new Error(\"No measurements provided.\");\n        }\n\n        /* Patient ID\n        Warning - Missing attribute or value that would be needed to build DICOMDIR - Patient ID\n        Warning - Missing attribute or value that would be needed to build DICOMDIR - Study Date\n        Warning - Missing attribute or value that would be needed to build DICOMDIR - Study Time\n        Warning - Missing attribute or value that would be needed to build DICOMDIR - Study ID\n         */\n        const generalSeriesModule = metadataProvider.get(\n            \"generalSeriesModule\",\n            firstImageId\n        );\n\n        //const sopCommonModule = metadataProvider.get('sopCommonModule', firstImageId);\n\n        // NOTE: We are getting the Series and Study UIDs from the first imageId of the toolState\n        // which means that if the toolState is for multiple series, the report will have the incorrect\n        // SeriesInstanceUIDs\n        const { studyInstanceUID, seriesInstanceUID } = generalSeriesModule;\n\n        // Loop through each image in the toolData\n        Object.keys(toolState).forEach(imageId => {\n            const sopCommonModule = metadataProvider.get(\n                \"sopCommonModule\",\n                imageId\n            );\n            const frameNumber = metadataProvider.get(\"frameNumber\", imageId);\n            const toolData = toolState[imageId];\n            const toolTypes = Object.keys(toolData);\n\n            const ReferencedSOPSequence = {\n                ReferencedSOPClassUID: sopCommonModule.sopClassUID,\n                ReferencedSOPInstanceUID: sopCommonModule.sopInstanceUID\n            };\n\n            if (\n                Normalizer.isMultiframeSOPClassUID(sopCommonModule.sopClassUID)\n            ) {\n                ReferencedSOPSequence.ReferencedFrameNumber = frameNumber;\n            }\n\n            // Loop through each tool type for the image\n            const measurementGroups = [];\n\n            toolTypes.forEach(toolType => {\n                const group = getMeasurementGroup(\n                    toolType,\n                    toolData,\n                    ReferencedSOPSequence\n                );\n                if (group) {\n                    measurementGroups.push(group);\n                }\n            });\n\n            allMeasurementGroups =\n                allMeasurementGroups.concat(measurementGroups);\n        });\n\n        const MeasurementReport = new TID1500MeasurementReport(\n            { TID1501MeasurementGroups: allMeasurementGroups },\n            options\n        );\n\n        // TODO: what is the correct metaheader\n        // http://dicom.nema.org/medical/Dicom/current/output/chtml/part10/chapter_7.html\n        // TODO: move meta creation to happen in derivations.js\n        const fileMetaInformationVersionArray = new Uint8Array(2);\n        fileMetaInformationVersionArray[1] = 1;\n\n        const derivationSourceDataset = {\n            StudyInstanceUID: studyInstanceUID,\n            SeriesInstanceUID: seriesInstanceUID\n            //SOPInstanceUID: sopInstanceUID, // TODO: Necessary?\n            //SOPClassUID: sopClassUID,\n        };\n\n        const _meta = {\n            FileMetaInformationVersion: {\n                Value: [fileMetaInformationVersionArray.buffer],\n                vr: \"OB\"\n            },\n            //MediaStorageSOPClassUID\n            //MediaStorageSOPInstanceUID: sopCommonModule.sopInstanceUID,\n            TransferSyntaxUID: {\n                Value: [\"1.2.840.10008.1.2.1\"],\n                vr: \"UI\"\n            },\n            ImplementationClassUID: {\n                Value: [DicomMetaDictionary.uid()], // TODO: could be git hash or other valid id\n                vr: \"UI\"\n            },\n            ImplementationVersionName: {\n                Value: [\"dcmjs\"],\n                vr: \"SH\"\n            }\n        };\n\n        const _vrMap = {\n            PixelData: \"OW\"\n        };\n\n        derivationSourceDataset._meta = _meta;\n        derivationSourceDataset._vrMap = _vrMap;\n\n        const report = new StructuredReport([derivationSourceDataset]);\n\n        const contentItem = MeasurementReport.contentItem(\n            derivationSourceDataset\n        );\n\n        // Merge the derived dataset with the content from the Measurement Report\n        report.dataset = Object.assign(report.dataset, contentItem);\n        report.dataset._meta = _meta;\n\n        return report;\n    }\n\n    /**\n     * Generate Cornerstone tool state from dataset\n     * @param {object} dataset dataset\n     * @param {object} hooks\n     * @param {function} hooks.getToolClass Function to map dataset to a tool class\n     * @returns\n     */\n    static generateToolState(dataset, hooks = {}) {\n        // For now, bail out if the dataset is not a TID1500 SR with length measurements\n        if (dataset.ContentTemplateSequence.TemplateIdentifier !== \"1500\") {\n            throw new Error(\n                \"This package can currently only interpret DICOM SR TID 1500\"\n            );\n        }\n\n        const REPORT = \"Imaging Measurements\";\n        const GROUP = \"Measurement Group\";\n        const TRACKING_IDENTIFIER = \"Tracking Identifier\";\n\n        // Identify the Imaging Measurements\n        const imagingMeasurementContent = toArray(dataset.ContentSequence).find(\n            codeMeaningEquals(REPORT)\n        );\n\n        // Retrieve the Measurements themselves\n        const measurementGroups = toArray(\n            imagingMeasurementContent.ContentSequence\n        ).filter(codeMeaningEquals(GROUP));\n\n        // For each of the supported measurement types, compute the measurement data\n        const measurementData = {};\n\n        const cornerstoneToolClasses =\n            MeasurementReport.CORNERSTONE_TOOL_CLASSES_BY_UTILITY_TYPE;\n\n        const registeredToolClasses = [];\n\n        Object.keys(cornerstoneToolClasses).forEach(key => {\n            registeredToolClasses.push(cornerstoneToolClasses[key]);\n            measurementData[key] = [];\n        });\n\n        measurementGroups.forEach(measurementGroup => {\n            const measurementGroupContentSequence = toArray(\n                measurementGroup.ContentSequence\n            );\n\n            const TrackingIdentifierGroup =\n                measurementGroupContentSequence.find(\n                    contentItem =>\n                        contentItem.ConceptNameCodeSequence.CodeMeaning ===\n                        TRACKING_IDENTIFIER\n                );\n\n            const TrackingIdentifierValue = TrackingIdentifierGroup.TextValue;\n\n            const toolClass = hooks.getToolClass\n                ? hooks.getToolClass(\n                      measurementGroup,\n                      dataset,\n                      registeredToolClasses\n                  )\n                : registeredToolClasses.find(tc =>\n                      tc.isValidCornerstoneTrackingIdentifier(\n                          TrackingIdentifierValue\n                      )\n                  );\n\n            if (toolClass) {\n                const measurement =\n                    toolClass.getMeasurementData(measurementGroup);\n\n                console.log(`=== ${toolClass.toolType} ===`);\n                console.log(measurement);\n\n                measurementData[toolClass.toolType].push(measurement);\n            }\n        });\n\n        // NOTE: There is no way of knowing the cornerstone imageIds as that could be anything.\n        // That is up to the consumer to derive from the SOPInstanceUIDs.\n        return measurementData;\n    }\n\n    static registerTool(toolClass) {\n        MeasurementReport.CORNERSTONE_TOOL_CLASSES_BY_UTILITY_TYPE[\n            toolClass.utilityToolType\n        ] = toolClass;\n        MeasurementReport.CORNERSTONE_TOOL_CLASSES_BY_TOOL_TYPE[\n            toolClass.toolType\n        ] = toolClass;\n        MeasurementReport.MEASUREMENT_BY_TOOLTYPE[toolClass.toolType] =\n            toolClass.utilityToolType;\n    }\n}\n\nMeasurementReport.MEASUREMENT_BY_TOOLTYPE = {};\nMeasurementReport.CORNERSTONE_TOOL_CLASSES_BY_UTILITY_TYPE = {};\nMeasurementReport.CORNERSTONE_TOOL_CLASSES_BY_TOOL_TYPE = {};\n","export default \"cornerstoneTools@^4.0.0\";\n","import { utilities } from \"dcmjs\";\nimport MeasurementReport from \"./MeasurementReport\";\nimport CORNERSTONE_4_TAG from \"./cornerstone4Tag\";\n\nconst { Length: TID300Length } = utilities.TID300;\n\nconst LENGTH = \"Length\";\n\nclass Length {\n    // TODO: this function is required for all Cornerstone Tool Adapters, since it is called by MeasurementReport.\n    static getMeasurementData(MeasurementGroup) {\n        const { defaultState, NUMGroup, SCOORDGroup } =\n            MeasurementReport.getSetupMeasurementData(MeasurementGroup);\n\n        const state = {\n            ...defaultState,\n            length: NUMGroup.MeasuredValueSequence.NumericValue,\n            toolType: Length.toolType,\n            handles: {\n                start: {},\n                end: {},\n                textBox: {\n                    hasMoved: false,\n                    movesIndependently: false,\n                    drawnIndependently: true,\n                    allowedOutsideImage: true,\n                    hasBoundingBox: true\n                }\n            }\n        };\n\n        [\n            state.handles.start.x,\n            state.handles.start.y,\n            state.handles.end.x,\n            state.handles.end.y\n        ] = SCOORDGroup.GraphicData;\n\n        return state;\n    }\n\n    static getTID300RepresentationArguments(tool) {\n        const { handles, finding, findingSites } = tool;\n        const point1 = handles.start;\n        const point2 = handles.end;\n        const distance = tool.length;\n\n        const trackingIdentifierTextValue = \"cornerstoneTools@^4.0.0:Length\";\n\n        return {\n            point1,\n            point2,\n            distance,\n            trackingIdentifierTextValue,\n            finding,\n            findingSites: findingSites || []\n        };\n    }\n}\n\nLength.toolType = LENGTH;\nLength.utilityToolType = LENGTH;\nLength.TID300Representation = TID300Length;\nLength.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n    if (!TrackingIdentifier.includes(\":\")) {\n        return false;\n    }\n\n    const [cornerstone4Tag, toolType] = TrackingIdentifier.split(\":\");\n\n    if (cornerstone4Tag !== CORNERSTONE_4_TAG) {\n        return false;\n    }\n\n    return toolType === LENGTH;\n};\n\nMeasurementReport.registerTool(Length);\n\nexport default Length;\n","import { utilities } from \"dcmjs\";\n\nimport MeasurementReport from \"./MeasurementReport\";\nimport CORNERSTONE_4_TAG from \"./cornerstone4Tag\";\n\nconst { Polyline: TID300Polyline } = utilities.TID300;\n\nclass FreehandRoi {\n    static getMeasurementData(MeasurementGroup) {\n        const { defaultState, SCOORDGroup, NUMGroup } =\n            MeasurementReport.getSetupMeasurementData(MeasurementGroup);\n\n        const state = {\n            ...defaultState,\n            toolType: FreehandRoi.toolType,\n            handles: {\n                points: [],\n                textBox: {\n                    active: false,\n                    hasMoved: false,\n                    movesIndependently: false,\n                    drawnIndependently: true,\n                    allowedOutsideImage: true,\n                    hasBoundingBox: true\n                }\n            },\n            cachedStats: {\n                area: NUMGroup ? NUMGroup.MeasuredValueSequence.NumericValue : 0\n            },\n            color: undefined,\n            invalidated: true\n        };\n        const { GraphicData } = SCOORDGroup;\n        for (let i = 0; i < GraphicData.length; i += 2) {\n            state.handles.points.push({\n                x: GraphicData[i],\n                y: GraphicData[i + 1]\n            });\n        }\n\n        return state;\n    }\n\n    static getTID300RepresentationArguments(tool) {\n        const { handles, finding, findingSites, cachedStats = {} } = tool;\n        const { points } = handles;\n        const { area = 0, perimeter = 0 } = cachedStats;\n\n        const trackingIdentifierTextValue =\n            \"cornerstoneTools@^4.0.0:FreehandRoi\";\n\n        return {\n            points,\n            area,\n            perimeter,\n            trackingIdentifierTextValue,\n            finding,\n            findingSites: findingSites || []\n        };\n    }\n}\n\nFreehandRoi.toolType = \"FreehandRoi\";\nFreehandRoi.utilityToolType = \"FreehandRoi\";\nFreehandRoi.TID300Representation = TID300Polyline;\nFreehandRoi.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n    if (!TrackingIdentifier.includes(\":\")) {\n        return false;\n    }\n\n    const [cornerstone4Tag, toolType] = TrackingIdentifier.split(\":\");\n\n    if (cornerstone4Tag !== CORNERSTONE_4_TAG) {\n        return false;\n    }\n\n    return toolType === FreehandRoi.toolType;\n};\n\nMeasurementReport.registerTool(FreehandRoi);\n\nexport default FreehandRoi;\n","import { utilities } from \"dcmjs\";\nimport MeasurementReport from \"./MeasurementReport\";\nimport CORNERSTONE_4_TAG from \"./cornerstone4Tag\";\nimport { toArray } from \"../helpers\";\n\nconst { Bidirectional: TID300Bidirectional } = utilities.TID300;\n\nconst BIDIRECTIONAL = \"Bidirectional\";\nconst LONG_AXIS = \"Long Axis\";\nconst SHORT_AXIS = \"Short Axis\";\nconst FINDING = \"121071\";\nconst FINDING_SITE = \"G-C0E3\";\n\nclass Bidirectional {\n    // TODO: this function is required for all Cornerstone Tool Adapters, since it is called by MeasurementReport.\n    static getMeasurementData(MeasurementGroup) {\n        const { ContentSequence } = MeasurementGroup;\n\n        const findingGroup = toArray(ContentSequence).find(\n            group => group.ConceptNameCodeSequence.CodeValue === FINDING\n        );\n\n        const findingSiteGroups = toArray(ContentSequence).filter(\n            group => group.ConceptNameCodeSequence.CodeValue === FINDING_SITE\n        );\n\n        const longAxisNUMGroup = toArray(ContentSequence).find(\n            group => group.ConceptNameCodeSequence.CodeMeaning === LONG_AXIS\n        );\n\n        const longAxisSCOORDGroup = toArray(\n            longAxisNUMGroup.ContentSequence\n        ).find(group => group.ValueType === \"SCOORD\");\n\n        const shortAxisNUMGroup = toArray(ContentSequence).find(\n            group => group.ConceptNameCodeSequence.CodeMeaning === SHORT_AXIS\n        );\n\n        const shortAxisSCOORDGroup = toArray(\n            shortAxisNUMGroup.ContentSequence\n        ).find(group => group.ValueType === \"SCOORD\");\n\n        const { ReferencedSOPSequence } = longAxisSCOORDGroup.ContentSequence;\n        const { ReferencedSOPInstanceUID, ReferencedFrameNumber } =\n            ReferencedSOPSequence;\n\n        // Long axis\n\n        const longestDiameter = String(\n            longAxisNUMGroup.MeasuredValueSequence.NumericValue\n        );\n\n        const shortestDiameter = String(\n            shortAxisNUMGroup.MeasuredValueSequence.NumericValue\n        );\n\n        const bottomRight = {\n            x: Math.max(\n                longAxisSCOORDGroup.GraphicData[0],\n                longAxisSCOORDGroup.GraphicData[2],\n                shortAxisSCOORDGroup.GraphicData[0],\n                shortAxisSCOORDGroup.GraphicData[2]\n            ),\n            y: Math.max(\n                longAxisSCOORDGroup.GraphicData[1],\n                longAxisSCOORDGroup.GraphicData[3],\n                shortAxisSCOORDGroup.GraphicData[1],\n                shortAxisSCOORDGroup.GraphicData[3]\n            )\n        };\n\n        const state = {\n            sopInstanceUid: ReferencedSOPInstanceUID,\n            frameIndex: ReferencedFrameNumber || 1,\n            toolType: Bidirectional.toolType,\n            active: false,\n            handles: {\n                start: {\n                    x: longAxisSCOORDGroup.GraphicData[0],\n                    y: longAxisSCOORDGroup.GraphicData[1],\n                    drawnIndependently: false,\n                    allowedOutsideImage: false,\n                    active: false,\n                    highlight: false,\n                    index: 0\n                },\n                end: {\n                    x: longAxisSCOORDGroup.GraphicData[2],\n                    y: longAxisSCOORDGroup.GraphicData[3],\n                    drawnIndependently: false,\n                    allowedOutsideImage: false,\n                    active: false,\n                    highlight: false,\n                    index: 1\n                },\n                perpendicularStart: {\n                    x: shortAxisSCOORDGroup.GraphicData[0],\n                    y: shortAxisSCOORDGroup.GraphicData[1],\n                    drawnIndependently: false,\n                    allowedOutsideImage: false,\n                    active: false,\n                    highlight: false,\n                    index: 2\n                },\n                perpendicularEnd: {\n                    x: shortAxisSCOORDGroup.GraphicData[2],\n                    y: shortAxisSCOORDGroup.GraphicData[3],\n                    drawnIndependently: false,\n                    allowedOutsideImage: false,\n                    active: false,\n                    highlight: false,\n                    index: 3\n                },\n                textBox: {\n                    highlight: false,\n                    hasMoved: true,\n                    active: false,\n                    movesIndependently: false,\n                    drawnIndependently: true,\n                    allowedOutsideImage: true,\n                    hasBoundingBox: true,\n                    x: bottomRight.x + 10,\n                    y: bottomRight.y + 10\n                }\n            },\n            invalidated: false,\n            isCreating: false,\n            longestDiameter,\n            shortestDiameter,\n            toolName: \"Bidirectional\",\n            visible: true,\n            finding: findingGroup\n                ? findingGroup.ConceptCodeSequence\n                : undefined,\n            findingSites: findingSiteGroups.map(fsg => fsg.ConceptCodeSequence)\n        };\n\n        return state;\n    }\n\n    static getTID300RepresentationArguments(tool) {\n        const { start, end, perpendicularStart, perpendicularEnd } =\n            tool.handles;\n        const { shortestDiameter, longestDiameter, finding, findingSites } =\n            tool;\n\n        const trackingIdentifierTextValue =\n            \"cornerstoneTools@^4.0.0:Bidirectional\";\n\n        return {\n            longAxis: {\n                point1: start,\n                point2: end\n            },\n            shortAxis: {\n                point1: perpendicularStart,\n                point2: perpendicularEnd\n            },\n            longAxisLength: longestDiameter,\n            shortAxisLength: shortestDiameter,\n            trackingIdentifierTextValue,\n            finding: finding,\n            findingSites: findingSites || []\n        };\n    }\n}\n\nBidirectional.toolType = BIDIRECTIONAL;\nBidirectional.utilityToolType = BIDIRECTIONAL;\nBidirectional.TID300Representation = TID300Bidirectional;\nBidirectional.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n    if (!TrackingIdentifier.includes(\":\")) {\n        return false;\n    }\n\n    const [cornerstone4Tag, toolType] = TrackingIdentifier.split(\":\");\n\n    if (cornerstone4Tag !== CORNERSTONE_4_TAG) {\n        return false;\n    }\n\n    return toolType === BIDIRECTIONAL;\n};\n\nMeasurementReport.registerTool(Bidirectional);\n\nexport default Bidirectional;\n","import { utilities } from \"dcmjs\";\nimport MeasurementReport from \"./MeasurementReport\";\nimport CORNERSTONE_4_TAG from \"./cornerstone4Tag\";\n\nconst { Ellipse: TID300Ellipse } = utilities.TID300;\n\nconst ELLIPTICALROI = \"EllipticalRoi\";\n\nclass EllipticalRoi {\n    // TODO: this function is required for all Cornerstone Tool Adapters, since it is called by MeasurementReport.\n    static getMeasurementData(MeasurementGroup) {\n        const { defaultState, NUMGroup, SCOORDGroup } =\n            MeasurementReport.getSetupMeasurementData(MeasurementGroup);\n\n        const { GraphicData } = SCOORDGroup;\n\n        const majorAxis = [\n            { x: GraphicData[0], y: GraphicData[1] },\n            { x: GraphicData[2], y: GraphicData[3] }\n        ];\n        const minorAxis = [\n            { x: GraphicData[4], y: GraphicData[5] },\n            { x: GraphicData[6], y: GraphicData[7] }\n        ];\n\n        // Calculate two opposite corners of box defined by two axes.\n\n        const minorAxisLength = Math.sqrt(\n            Math.pow(minorAxis[0].x - minorAxis[1].x, 2) +\n                Math.pow(minorAxis[0].y - minorAxis[1].y, 2)\n        );\n\n        const minorAxisDirection = {\n            x: (minorAxis[1].x - minorAxis[0].x) / minorAxisLength,\n            y: (minorAxis[1].y - minorAxis[0].y) / minorAxisLength\n        };\n\n        const halfMinorAxisLength = minorAxisLength / 2;\n\n        // First end point of major axis + half minor axis vector\n        const corner1 = {\n            x: majorAxis[0].x + minorAxisDirection.x * halfMinorAxisLength,\n            y: majorAxis[0].y + minorAxisDirection.y * halfMinorAxisLength\n        };\n\n        // Second end point of major axis - half of minor axis vector\n        const corner2 = {\n            x: majorAxis[1].x - minorAxisDirection.x * halfMinorAxisLength,\n            y: majorAxis[1].y - minorAxisDirection.y * halfMinorAxisLength\n        };\n        const state = {\n            ...defaultState,\n            toolType: EllipticalRoi.toolType,\n            active: false,\n            cachedStats: {\n                area: NUMGroup ? NUMGroup.MeasuredValueSequence.NumericValue : 0\n            },\n            handles: {\n                end: {\n                    x: corner1.x,\n                    y: corner1.y,\n                    highlight: false,\n                    active: false\n                },\n                initialRotation: 0,\n                start: {\n                    x: corner2.x,\n                    y: corner2.y,\n                    highlight: false,\n                    active: false\n                },\n                textBox: {\n                    hasMoved: false,\n                    movesIndependently: false,\n                    drawnIndependently: true,\n                    allowedOutsideImage: true,\n                    hasBoundingBox: true\n                }\n            },\n            invalidated: true,\n            visible: true\n        };\n\n        return state;\n    }\n\n    static getTID300RepresentationArguments(tool) {\n        const { cachedStats = {}, handles, finding, findingSites } = tool;\n        const { start, end } = handles;\n        const { area } = cachedStats;\n\n        const halfXLength = Math.abs(start.x - end.x) / 2;\n        const halfYLength = Math.abs(start.y - end.y) / 2;\n\n        const points = [];\n\n        const center = { x: (start.x + end.x) / 2, y: (start.y + end.y) / 2 };\n\n        if (halfXLength > halfYLength) {\n            // X-axis major\n            // Major axis\n            points.push({ x: center.x - halfXLength, y: center.y });\n            points.push({ x: center.x + halfXLength, y: center.y });\n            // Minor axis\n            points.push({ x: center.x, y: center.y - halfYLength });\n            points.push({ x: center.x, y: center.y + halfYLength });\n        } else {\n            // Y-axis major\n            // Major axis\n            points.push({ x: center.x, y: center.y - halfYLength });\n            points.push({ x: center.x, y: center.y + halfYLength });\n            // Minor axis\n            points.push({ x: center.x - halfXLength, y: center.y });\n            points.push({ x: center.x + halfXLength, y: center.y });\n        }\n\n        const trackingIdentifierTextValue =\n            \"cornerstoneTools@^4.0.0:EllipticalRoi\";\n\n        return {\n            area,\n            points,\n            trackingIdentifierTextValue,\n            finding,\n            findingSites: findingSites || []\n        };\n    }\n}\n\nEllipticalRoi.toolType = ELLIPTICALROI;\nEllipticalRoi.utilityToolType = ELLIPTICALROI;\nEllipticalRoi.TID300Representation = TID300Ellipse;\nEllipticalRoi.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n    if (!TrackingIdentifier.includes(\":\")) {\n        return false;\n    }\n\n    const [cornerstone4Tag, toolType] = TrackingIdentifier.split(\":\");\n\n    if (cornerstone4Tag !== CORNERSTONE_4_TAG) {\n        return false;\n    }\n\n    return toolType === ELLIPTICALROI;\n};\n\nMeasurementReport.registerTool(EllipticalRoi);\n\nexport default EllipticalRoi;\n","import { utilities } from \"dcmjs\";\nimport MeasurementReport from \"./MeasurementReport\";\nimport CORNERSTONE_4_TAG from \"./cornerstone4Tag\";\n\nconst { Circle: TID300Circle } = utilities.TID300;\n\nconst CIRCLEROI = \"CircleRoi\";\n\nclass CircleRoi {\n    /** Gets the measurement data for cornerstone, given DICOM SR measurement data. */\n    static getMeasurementData(MeasurementGroup) {\n        const { defaultState, NUMGroup, SCOORDGroup } =\n            MeasurementReport.getSetupMeasurementData(MeasurementGroup);\n\n        const { GraphicData } = SCOORDGroup;\n\n        const center = { x: GraphicData[0], y: GraphicData[1] };\n        const end = { x: GraphicData[2], y: GraphicData[3] };\n\n        const state = {\n            ...defaultState,\n            toolType: CircleRoi.toolType,\n            active: false,\n            cachedStats: {\n                area: NUMGroup\n                    ? NUMGroup.MeasuredValueSequence.NumericValue\n                    : 0,\n                // Dummy values to be updated by cornerstone\n                radius: 0,\n                perimeter: 0\n            },\n            handles: {\n                end: {\n                    ...end,\n                    highlight: false,\n                    active: false\n                },\n                initialRotation: 0,\n                start: {\n                    ...center,\n                    highlight: false,\n                    active: false\n                },\n                textBox: {\n                    hasMoved: false,\n                    movesIndependently: false,\n                    drawnIndependently: true,\n                    allowedOutsideImage: true,\n                    hasBoundingBox: true\n                }\n            },\n            invalidated: true,\n            visible: true\n        };\n\n        return state;\n    }\n\n    /**\n     * Gets the TID 300 representation of a circle, given the cornerstone representation.\n     *\n     * @param {Object} tool\n     * @returns\n     */\n    static getTID300RepresentationArguments(tool) {\n        const { cachedStats = {}, handles, finding, findingSites } = tool;\n        const { start: center, end } = handles;\n        const { area, radius } = cachedStats;\n\n        const perimeter = 2 * Math.PI * radius;\n        const points = [];\n\n        points.push(center);\n        points.push(end);\n\n        const trackingIdentifierTextValue = \"cornerstoneTools@^4.0.0:CircleRoi\";\n\n        return {\n            area,\n            perimeter,\n            radius,\n            points,\n            trackingIdentifierTextValue,\n            finding,\n            findingSites: findingSites || []\n        };\n    }\n}\n\nCircleRoi.toolType = CIRCLEROI;\nCircleRoi.utilityToolType = CIRCLEROI;\nCircleRoi.TID300Representation = TID300Circle;\nCircleRoi.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n    if (!TrackingIdentifier.includes(\":\")) {\n        return false;\n    }\n\n    const [cornerstone4Tag, toolType] = TrackingIdentifier.split(\":\");\n\n    if (cornerstone4Tag !== CORNERSTONE_4_TAG) {\n        return false;\n    }\n\n    return toolType === CIRCLEROI;\n};\n\nMeasurementReport.registerTool(CircleRoi);\n\nexport default CircleRoi;\n","import { utilities } from \"dcmjs\";\n\nimport MeasurementReport from \"./MeasurementReport\";\nimport CORNERSTONE_4_TAG from \"./cornerstone4Tag\";\n\nconst { Point: TID300Point } = utilities.TID300;\n\nconst ARROW_ANNOTATE = \"ArrowAnnotate\";\nconst CORNERSTONEFREETEXT = \"CORNERSTONEFREETEXT\";\n\nclass ArrowAnnotate {\n    static getMeasurementData(MeasurementGroup) {\n        const { defaultState, SCOORDGroup, findingGroup } =\n            MeasurementReport.getSetupMeasurementData(MeasurementGroup);\n\n        const text = findingGroup.ConceptCodeSequence.CodeMeaning;\n\n        const { GraphicData } = SCOORDGroup;\n\n        const state = {\n            ...defaultState,\n            toolType: ArrowAnnotate.toolType,\n            active: false,\n            handles: {\n                start: {\n                    x: GraphicData[0],\n                    y: GraphicData[1],\n                    highlight: true,\n                    active: false\n                },\n                // Use a generic offset if the stored data doesn't have the endpoint, otherwise\n                // use the actual endpoint.\n                end: {\n                    x:\n                        GraphicData.length == 4\n                            ? GraphicData[2]\n                            : GraphicData[0] + 20,\n                    y:\n                        GraphicData.length == 4\n                            ? GraphicData[3]\n                            : GraphicData[1] + 20,\n                    highlight: true,\n                    active: false\n                },\n                textBox: {\n                    hasMoved: false,\n                    movesIndependently: false,\n                    drawnIndependently: true,\n                    allowedOutsideImage: true,\n                    hasBoundingBox: true\n                }\n            },\n            invalidated: true,\n            text,\n            visible: true\n        };\n\n        return state;\n    }\n\n    static getTID300RepresentationArguments(tool) {\n        const points = [tool.handles.start, tool.handles.end];\n\n        let { finding, findingSites } = tool;\n\n        const TID300RepresentationArguments = {\n            points,\n            trackingIdentifierTextValue: `cornerstoneTools@^4.0.0:ArrowAnnotate`,\n            findingSites: findingSites || []\n        };\n\n        // If freetext finding isn't present, add it from the tool text.\n        if (!finding || finding.CodeValue !== CORNERSTONEFREETEXT) {\n            finding = {\n                CodeValue: CORNERSTONEFREETEXT,\n                CodingSchemeDesignator: \"CST4\",\n                CodeMeaning: tool.text\n            };\n        }\n\n        TID300RepresentationArguments.finding = finding;\n\n        return TID300RepresentationArguments;\n    }\n}\n\nArrowAnnotate.toolType = ARROW_ANNOTATE;\nArrowAnnotate.utilityToolType = ARROW_ANNOTATE;\nArrowAnnotate.TID300Representation = TID300Point;\nArrowAnnotate.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n    if (!TrackingIdentifier.includes(\":\")) {\n        return false;\n    }\n\n    const [cornerstone4Tag, toolType] = TrackingIdentifier.split(\":\");\n\n    if (cornerstone4Tag !== CORNERSTONE_4_TAG) {\n        return false;\n    }\n\n    return toolType === ARROW_ANNOTATE;\n};\n\nMeasurementReport.registerTool(ArrowAnnotate);\n\nexport default ArrowAnnotate;\n","import { utilities } from \"dcmjs\";\nimport MeasurementReport from \"./MeasurementReport\";\nimport CORNERSTONE_4_TAG from \"./cornerstone4Tag\";\n\nconst { CobbAngle: TID300CobbAngle } = utilities.TID300;\n\nconst COBB_ANGLE = \"CobbAngle\";\n\nclass CobbAngle {\n    // TODO: this function is required for all Cornerstone Tool Adapters, since it is called by MeasurementReport.\n    static getMeasurementData(MeasurementGroup) {\n        const { defaultState, NUMGroup, SCOORDGroup } =\n            MeasurementReport.getSetupMeasurementData(MeasurementGroup);\n\n        const state = {\n            ...defaultState,\n            rAngle: NUMGroup.MeasuredValueSequence.NumericValue,\n            toolType: CobbAngle.toolType,\n            handles: {\n                start: {},\n                end: {},\n                start2: {\n                    highlight: true,\n                    drawnIndependently: true\n                },\n                end2: {\n                    highlight: true,\n                    drawnIndependently: true\n                },\n                textBox: {\n                    hasMoved: false,\n                    movesIndependently: false,\n                    drawnIndependently: true,\n                    allowedOutsideImage: true,\n                    hasBoundingBox: true\n                }\n            }\n        };\n\n        [\n            state.handles.start.x,\n            state.handles.start.y,\n            state.handles.end.x,\n            state.handles.end.y,\n            state.handles.start2.x,\n            state.handles.start2.y,\n            state.handles.end2.x,\n            state.handles.end2.y\n        ] = SCOORDGroup.GraphicData;\n\n        return state;\n    }\n\n    static getTID300RepresentationArguments(tool) {\n        const { handles, finding, findingSites } = tool;\n        const point1 = handles.start;\n        const point2 = handles.end;\n        const point3 = handles.start2;\n        const point4 = handles.end2;\n        const rAngle = tool.rAngle;\n\n        const trackingIdentifierTextValue = \"cornerstoneTools@^4.0.0:CobbAngle\";\n\n        return {\n            point1,\n            point2,\n            point3,\n            point4,\n            rAngle,\n            trackingIdentifierTextValue,\n            finding,\n            findingSites: findingSites || []\n        };\n    }\n}\n\nCobbAngle.toolType = COBB_ANGLE;\nCobbAngle.utilityToolType = COBB_ANGLE;\nCobbAngle.TID300Representation = TID300CobbAngle;\nCobbAngle.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n    if (!TrackingIdentifier.includes(\":\")) {\n        return false;\n    }\n\n    const [cornerstone4Tag, toolType] = TrackingIdentifier.split(\":\");\n\n    if (cornerstone4Tag !== CORNERSTONE_4_TAG) {\n        return false;\n    }\n\n    return toolType === COBB_ANGLE;\n};\n\nMeasurementReport.registerTool(CobbAngle);\n\nexport default CobbAngle;\n","import { utilities } from \"dcmjs\";\n\nimport MeasurementReport from \"./MeasurementReport\";\nimport CORNERSTONE_4_TAG from \"./cornerstone4Tag\";\n\nconst { Angle: TID300Angle } = utilities.TID300;\n\nconst ANGLE = \"Angle\";\n\nclass Angle {\n    /**\n     * Generate TID300 measurement data for a plane angle measurement - use a Angle, but label it as Angle\n     */\n    static getMeasurementData(MeasurementGroup) {\n        const { defaultState, NUMGroup, SCOORDGroup } =\n            MeasurementReport.getSetupMeasurementData(MeasurementGroup);\n\n        const state = {\n            ...defaultState,\n            rAngle: NUMGroup.MeasuredValueSequence.NumericValue,\n            toolType: Angle.toolType,\n            handles: {\n                start: {},\n                middle: {},\n                end: {},\n                textBox: {\n                    hasMoved: false,\n                    movesIndependently: false,\n                    drawnIndependently: true,\n                    allowedOutsideImage: true,\n                    hasBoundingBox: true\n                }\n            }\n        };\n\n        [\n            state.handles.start.x,\n            state.handles.start.y,\n            state.handles.middle.x,\n            state.handles.middle.y,\n            state.handles.middle.x,\n            state.handles.middle.y,\n            state.handles.end.x,\n            state.handles.end.y\n        ] = SCOORDGroup.GraphicData;\n\n        return state;\n    }\n\n    static getTID300RepresentationArguments(tool) {\n        const { handles, finding, findingSites } = tool;\n        const point1 = handles.start;\n        const point2 = handles.middle;\n        const point3 = handles.middle;\n        const point4 = handles.end;\n        const rAngle = tool.rAngle;\n\n        const trackingIdentifierTextValue = \"cornerstoneTools@^4.0.0:Angle\";\n\n        return {\n            point1,\n            point2,\n            point3,\n            point4,\n            rAngle,\n            trackingIdentifierTextValue,\n            finding,\n            findingSites: findingSites || []\n        };\n    }\n}\n\nAngle.toolType = ANGLE;\nAngle.utilityToolType = ANGLE;\nAngle.TID300Representation = TID300Angle;\nAngle.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n    if (!TrackingIdentifier.includes(\":\")) {\n        return false;\n    }\n\n    const [cornerstone4Tag, toolType] = TrackingIdentifier.split(\":\");\n\n    if (cornerstone4Tag !== CORNERSTONE_4_TAG) {\n        return false;\n    }\n\n    return toolType === ANGLE;\n};\n\nMeasurementReport.registerTool(Angle);\n\nexport default Angle;\n","import { utilities } from \"dcmjs\";\nimport MeasurementReport from \"./MeasurementReport\";\nimport CORNERSTONE_4_TAG from \"./cornerstone4Tag\";\n\nconst { Polyline: TID300Polyline } = utilities.TID300;\n\nclass RectangleRoi {\n    static getMeasurementData(MeasurementGroup) {\n        const { defaultState, SCOORDGroup, NUMGroup } =\n            MeasurementReport.getSetupMeasurementData(MeasurementGroup);\n\n        const state = {\n            ...defaultState,\n            toolType: RectangleRoi.toolType,\n            handles: {\n                start: {},\n                end: {},\n                textBox: {\n                    active: false,\n                    hasMoved: false,\n                    movesIndependently: false,\n                    drawnIndependently: true,\n                    allowedOutsideImage: true,\n                    hasBoundingBox: true\n                },\n                initialRotation: 0\n            },\n            cachedStats: {\n                area: NUMGroup ? NUMGroup.MeasuredValueSequence.NumericValue : 0\n            },\n            color: undefined,\n            invalidated: true\n        };\n        const intermediate = {};\n\n        [\n            state.handles.start.x,\n            state.handles.start.y,\n            intermediate.x,\n            intermediate.y,\n            state.handles.end.x,\n            state.handles.end.y\n        ] = SCOORDGroup.GraphicData;\n\n        return state;\n    }\n\n    static getTID300RepresentationArguments(tool) {\n        const { finding, findingSites, cachedStats = {}, handles } = tool;\n        const { start, end } = handles;\n        const points = [\n            start,\n            { x: start.x, y: end.y },\n            end,\n            { x: end.x, y: start.y }\n        ];\n        const { area, perimeter } = cachedStats;\n\n        const trackingIdentifierTextValue =\n            \"cornerstoneTools@^4.0.0:RectangleRoi\";\n\n        return {\n            points,\n            area,\n            perimeter,\n            trackingIdentifierTextValue,\n            finding,\n            findingSites: findingSites || []\n        };\n    }\n}\n\nRectangleRoi.toolType = \"RectangleRoi\";\nRectangleRoi.utilityToolType = \"RectangleRoi\";\nRectangleRoi.TID300Representation = TID300Polyline;\nRectangleRoi.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n    if (!TrackingIdentifier.includes(\":\")) {\n        return false;\n    }\n\n    const [cornerstone4Tag, toolType] = TrackingIdentifier.split(\":\");\n\n    if (cornerstone4Tag !== CORNERSTONE_4_TAG) {\n        return false;\n    }\n\n    return toolType === RectangleRoi.toolType;\n};\n\nMeasurementReport.registerTool(RectangleRoi);\n\nexport default RectangleRoi;\n","import { log, utilities, normalizers, derivations } from \"dcmjs\";\nimport ndarray from \"ndarray\";\n\nconst {\n    rotateDirectionCosinesInPlane,\n    flipImageOrientationPatient: flipIOP,\n    flipMatrix2D,\n    rotateMatrix902D\n} = utilities.orientation;\n\nconst { datasetToBlob, BitArray, DicomMessage, DicomMetaDictionary } =\n    utilities;\n\nconst { Normalizer } = normalizers;\nconst { Segmentation: SegmentationDerivation } = derivations;\n\nconst Segmentation = {\n    generateSegmentation,\n    generateToolState\n};\n\nexport default Segmentation;\n\n/**\n *\n * @typedef {Object} BrushData\n * @property {Object} toolState - The cornerstoneTools global toolState.\n * @property {Object[]} segments - The cornerstoneTools segment metadata that corresponds to the\n *                                 seriesInstanceUid.\n */\n\n/**\n * generateSegmentation - Generates cornerstoneTools brush data, given a stack of\n * imageIds, images and the cornerstoneTools brushData.\n *\n * @param  {object[]} images    An array of the cornerstone image objects.\n * @param  {BrushData} brushData and object containing the brushData.\n * @returns {type}           description\n */\nfunction generateSegmentation(\n    images,\n    brushData,\n    options = { includeSliceSpacing: true }\n) {\n    const { toolState, segments } = brushData;\n\n    // Calculate the dimensions of the data cube.\n    const image0 = images[0];\n\n    const dims = {\n        x: image0.columns,\n        y: image0.rows,\n        z: images.length\n    };\n\n    dims.xy = dims.x * dims.y;\n\n    const numSegments = _getSegCount(seg, segments);\n\n    if (!numSegments) {\n        throw new Error(\"No segments to export!\");\n    }\n\n    const isMultiframe = image0.imageId.includes(\"?frame\");\n    const seg = _createSegFromImages(images, isMultiframe, options);\n\n    const { referencedFramesPerSegment, segmentIndicies } =\n        _getNumberOfFramesPerSegment(toolState, images, segments);\n\n    let NumberOfFrames = 0;\n\n    for (let i = 0; i < referencedFramesPerSegment.length; i++) {\n        NumberOfFrames += referencedFramesPerSegment[i].length;\n    }\n\n    seg.setNumberOfFrames(NumberOfFrames);\n\n    for (let i = 0; i < segmentIndicies.length; i++) {\n        const segmentIndex = segmentIndicies[i];\n        const referencedFrameIndicies = referencedFramesPerSegment[i];\n\n        // Frame numbers start from 1.\n        const referencedFrameNumbers = referencedFrameIndicies.map(element => {\n            return element + 1;\n        });\n\n        const segment = segments[segmentIndex];\n\n        seg.addSegment(\n            segment,\n            _extractCornerstoneToolsPixelData(\n                segmentIndex,\n                referencedFrameIndicies,\n                toolState,\n                images,\n                dims\n            ),\n            referencedFrameNumbers\n        );\n    }\n\n    seg.bitPackPixelData();\n\n    const segBlob = datasetToBlob(seg.dataset);\n\n    return segBlob;\n}\n\nfunction _extractCornerstoneToolsPixelData(\n    segmentIndex,\n    referencedFrames,\n    toolState,\n    images,\n    dims\n) {\n    const pixelData = new Uint8Array(dims.xy * referencedFrames.length);\n\n    let pixelDataIndex = 0;\n\n    for (let i = 0; i < referencedFrames.length; i++) {\n        const frame = referencedFrames[i];\n\n        const imageId = images[frame].imageId;\n        const imageIdSpecificToolState = toolState[imageId];\n\n        const brushPixelData =\n            imageIdSpecificToolState.brush.data[segmentIndex].pixelData;\n\n        for (let p = 0; p < brushPixelData.length; p++) {\n            pixelData[pixelDataIndex] = brushPixelData[p];\n            pixelDataIndex++;\n        }\n    }\n\n    return pixelData;\n}\n\nfunction _getNumberOfFramesPerSegment(toolState, images, segments) {\n    const segmentIndicies = [];\n    const referencedFramesPerSegment = [];\n\n    for (let i = 0; i < segments.length; i++) {\n        if (segments[i]) {\n            segmentIndicies.push(i);\n            referencedFramesPerSegment.push([]);\n        }\n    }\n\n    for (let z = 0; z < images.length; z++) {\n        const imageId = images[z].imageId;\n        const imageIdSpecificToolState = toolState[imageId];\n\n        for (let i = 0; i < segmentIndicies.length; i++) {\n            const segIdx = segmentIndicies[i];\n\n            if (\n                imageIdSpecificToolState &&\n                imageIdSpecificToolState.brush &&\n                imageIdSpecificToolState.brush.data &&\n                imageIdSpecificToolState.brush.data[segIdx] &&\n                imageIdSpecificToolState.brush.data[segIdx].pixelData\n            ) {\n                referencedFramesPerSegment[i].push(z);\n            }\n        }\n    }\n\n    return {\n        referencedFramesPerSegment,\n        segmentIndicies\n    };\n}\n\nfunction _getSegCount(seg, segments) {\n    let numSegments = 0;\n\n    for (let i = 0; i < segments.length; i++) {\n        if (segments[i]) {\n            numSegments++;\n        }\n    }\n\n    return numSegments;\n}\n\n/**\n * _createSegFromImages - description\n *\n * @param  {Object[]} images    An array of the cornerstone image objects.\n * @param  {Boolean} isMultiframe Whether the images are multiframe.\n * @returns {Object}              The Seg derived dataSet.\n */\nfunction _createSegFromImages(images, isMultiframe, options) {\n    const datasets = [];\n\n    if (isMultiframe) {\n        const image = images[0];\n        const arrayBuffer = image.data.byteArray.buffer;\n\n        const dicomData = DicomMessage.readFile(arrayBuffer);\n        const dataset = DicomMetaDictionary.naturalizeDataset(dicomData.dict);\n\n        dataset._meta = DicomMetaDictionary.namifyDataset(dicomData.meta);\n\n        datasets.push(dataset);\n    } else {\n        for (let i = 0; i < images.length; i++) {\n            const image = images[i];\n            const arrayBuffer = image.data.byteArray.buffer;\n            const dicomData = DicomMessage.readFile(arrayBuffer);\n            const dataset = DicomMetaDictionary.naturalizeDataset(\n                dicomData.dict\n            );\n\n            dataset._meta = DicomMetaDictionary.namifyDataset(dicomData.meta);\n            datasets.push(dataset);\n        }\n    }\n\n    const multiframe = Normalizer.normalizeToDataset(datasets);\n\n    return new SegmentationDerivation([multiframe], options);\n}\n\n/**\n * generateToolState - Given a set of cornrstoneTools imageIds and a Segmentation buffer,\n * derive cornerstoneTools toolState and brush metadata.\n *\n * @param  {string[]} imageIds    An array of the imageIds.\n * @param  {ArrayBuffer} arrayBuffer The SEG arrayBuffer.\n * @param {*} metadataProvider\n * @returns {Object}  The toolState and an object from which the\n *                    segment metadata can be derived.\n */\nfunction generateToolState(imageIds, arrayBuffer, metadataProvider) {\n    const dicomData = DicomMessage.readFile(arrayBuffer);\n    const dataset = DicomMetaDictionary.naturalizeDataset(dicomData.dict);\n    dataset._meta = DicomMetaDictionary.namifyDataset(dicomData.meta);\n    const multiframe = Normalizer.normalizeToDataset([dataset]);\n\n    const imagePlaneModule = metadataProvider.get(\n        \"imagePlaneModule\",\n        imageIds[0]\n    );\n\n    if (!imagePlaneModule) {\n        console.warn(\"Insufficient metadata, imagePlaneModule missing.\");\n    }\n\n    const ImageOrientationPatient = Array.isArray(imagePlaneModule.rowCosines)\n        ? [...imagePlaneModule.rowCosines, ...imagePlaneModule.columnCosines]\n        : [\n              imagePlaneModule.rowCosines.x,\n              imagePlaneModule.rowCosines.y,\n              imagePlaneModule.rowCosines.z,\n              imagePlaneModule.columnCosines.x,\n              imagePlaneModule.columnCosines.y,\n              imagePlaneModule.columnCosines.z\n          ];\n\n    // Get IOP from ref series, compute supported orientations:\n    const validOrientations = getValidOrientations(ImageOrientationPatient);\n\n    const SharedFunctionalGroupsSequence =\n        multiframe.SharedFunctionalGroupsSequence;\n\n    const sharedImageOrientationPatient =\n        SharedFunctionalGroupsSequence.PlaneOrientationSequence\n            ? SharedFunctionalGroupsSequence.PlaneOrientationSequence\n                  .ImageOrientationPatient\n            : undefined;\n\n    const sliceLength = multiframe.Columns * multiframe.Rows;\n    const segMetadata = getSegmentMetadata(multiframe);\n    const pixelData = unpackPixelData(multiframe);\n\n    const PerFrameFunctionalGroupsSequence =\n        multiframe.PerFrameFunctionalGroupsSequence;\n\n    const toolState = {};\n\n    let inPlane = true;\n\n    for (let i = 0; i < PerFrameFunctionalGroupsSequence.length; i++) {\n        const PerFrameFunctionalGroups = PerFrameFunctionalGroupsSequence[i];\n\n        const ImageOrientationPatientI =\n            sharedImageOrientationPatient ||\n            PerFrameFunctionalGroups.PlaneOrientationSequence\n                .ImageOrientationPatient;\n\n        const pixelDataI2D = ndarray(\n            new Uint8Array(pixelData.buffer, i * sliceLength, sliceLength),\n            [multiframe.Rows, multiframe.Columns]\n        );\n\n        const alignedPixelDataI = alignPixelDataWithSourceData(\n            pixelDataI2D,\n            ImageOrientationPatientI,\n            validOrientations\n        );\n\n        if (!alignedPixelDataI) {\n            console.warn(\n                \"This segmentation object is not in-plane with the source data. Bailing out of IO. It'd be better to render this with vtkjs. \"\n            );\n            inPlane = false;\n            break;\n        }\n\n        const segmentIndex =\n            PerFrameFunctionalGroups.SegmentIdentificationSequence\n                .ReferencedSegmentNumber - 1;\n\n        let SourceImageSequence;\n        if (\n            SharedFunctionalGroupsSequence.DerivationImageSequence &&\n            SharedFunctionalGroupsSequence.DerivationImageSequence\n                .SourceImageSequence\n        ) {\n            SourceImageSequence =\n                SharedFunctionalGroupsSequence.DerivationImageSequence\n                    .SourceImageSequence[i];\n        } else {\n            SourceImageSequence =\n                PerFrameFunctionalGroups.DerivationImageSequence\n                    .SourceImageSequence;\n        }\n\n        const imageId = getImageIdOfSourceImage(\n            SourceImageSequence,\n            imageIds,\n            metadataProvider\n        );\n\n        addImageIdSpecificBrushToolState(\n            toolState,\n            imageId,\n            segmentIndex,\n            alignedPixelDataI\n        );\n    }\n\n    if (!inPlane) {\n        return;\n    }\n\n    return { toolState, segMetadata };\n}\n\n/**\n * unpackPixelData - Unpacks bitpacked pixelData if the Segmentation is BINARY.\n *\n * @param  {Object} multiframe The multiframe dataset.\n * @return {Uint8Array}      The unpacked pixelData.\n */\nfunction unpackPixelData(multiframe) {\n    const segType = multiframe.SegmentationType;\n\n    if (segType === \"BINARY\") {\n        return BitArray.unpack(multiframe.PixelData);\n    }\n\n    const pixelData = new Uint8Array(multiframe.PixelData);\n\n    const max = multiframe.MaximumFractionalValue;\n    const onlyMaxAndZero =\n        pixelData.find(element => element !== 0 && element !== max) ===\n        undefined;\n\n    if (!onlyMaxAndZero) {\n        log.warn(\n            \"This is a fractional segmentation, which is not currently supported.\"\n        );\n        return;\n    }\n\n    log.warn(\n        \"This segmentation object is actually binary... processing as such.\"\n    );\n\n    return pixelData;\n}\n\n/**\n * addImageIdSpecificBrushToolState - Adds brush pixel data to cornerstoneTools\n * formatted toolState object.\n *\n * @param  {Object} toolState    The toolState object to modify\n * @param  {String} imageId      The imageId of the toolState to add the data.\n * @param  {Number} segmentIndex The index of the segment data being added.\n * @param  {Ndarray} pixelData2D  The pixelData in Ndarry 2D format.\n */\nfunction addImageIdSpecificBrushToolState(\n    toolState,\n    imageId,\n    segmentIndex,\n    pixelData2D\n) {\n    if (!toolState[imageId]) {\n        toolState[imageId] = {};\n        toolState[imageId].brush = {};\n        toolState[imageId].brush.data = [];\n    } else if (!toolState[imageId].brush) {\n        toolState[imageId].brush = {};\n        toolState[imageId].brush.data = [];\n    } else if (!toolState[imageId].brush.data) {\n        toolState[imageId].brush.data = [];\n    }\n\n    toolState[imageId].brush.data[segmentIndex] = {};\n\n    const brushDataI = toolState[imageId].brush.data[segmentIndex];\n\n    brushDataI.pixelData = new Uint8Array(pixelData2D.data.length);\n\n    const cToolsPixelData = brushDataI.pixelData;\n\n    for (let p = 0; p < cToolsPixelData.length; p++) {\n        if (pixelData2D.data[p]) {\n            cToolsPixelData[p] = 1;\n        } else {\n            cToolsPixelData[p] = 0;\n        }\n    }\n}\n\n/**\n * getImageIdOfSourceImage - Returns the Cornerstone imageId of the source image.\n *\n * @param  {Object} SourceImageSequence Sequence describing the source image.\n * @param  {String[]} imageIds          A list of imageIds.\n * @param  {Object} metadataProvider    A Cornerstone metadataProvider to query\n *                                      metadata from imageIds.\n * @return {String}                     The corresponding imageId.\n */\nfunction getImageIdOfSourceImage(\n    SourceImageSequence,\n    imageIds,\n    metadataProvider\n) {\n    const { ReferencedSOPInstanceUID, ReferencedFrameNumber } =\n        SourceImageSequence;\n\n    return ReferencedFrameNumber\n        ? getImageIdOfReferencedFrame(\n              ReferencedSOPInstanceUID,\n              ReferencedFrameNumber,\n              imageIds,\n              metadataProvider\n          )\n        : getImageIdOfReferencedSingleFramedSOPInstance(\n              ReferencedSOPInstanceUID,\n              imageIds,\n              metadataProvider\n          );\n}\n\n/**\n * getImageIdOfReferencedSingleFramedSOPInstance - Returns the imageId\n * corresponding to the specified sopInstanceUid for single-frame images.\n *\n * @param  {String} sopInstanceUid   The sopInstanceUid of the desired image.\n * @param  {String[]} imageIds         The list of imageIds.\n * @param  {Object} metadataProvider The metadataProvider to obtain sopInstanceUids\n *                                 from the cornerstone imageIds.\n * @return {String}                  The imageId that corresponds to the sopInstanceUid.\n */\nfunction getImageIdOfReferencedSingleFramedSOPInstance(\n    sopInstanceUid,\n    imageIds,\n    metadataProvider\n) {\n    return imageIds.find(imageId => {\n        const sopCommonModule = metadataProvider.get(\n            \"sopCommonModule\",\n            imageId\n        );\n        if (!sopCommonModule) {\n            return;\n        }\n\n        return sopCommonModule.sopInstanceUID === sopInstanceUid;\n    });\n}\n\n/**\n * getImageIdOfReferencedFrame - Returns the imageId corresponding to the\n * specified sopInstanceUid and frameNumber for multi-frame images.\n *\n * @param  {String} sopInstanceUid   The sopInstanceUid of the desired image.\n * @param  {Number} frameNumber      The frame number.\n * @param  {String} imageIds         The list of imageIds.\n * @param  {Object} metadataProvider The metadataProvider to obtain sopInstanceUids\n *                                   from the cornerstone imageIds.\n * @return {String}                  The imageId that corresponds to the sopInstanceUid.\n */\nfunction getImageIdOfReferencedFrame(\n    sopInstanceUid,\n    frameNumber,\n    imageIds,\n    metadataProvider\n) {\n    const imageId = imageIds.find(imageId => {\n        const sopCommonModule = metadataProvider.get(\n            \"sopCommonModule\",\n            imageId\n        );\n        if (!sopCommonModule) {\n            return;\n        }\n\n        const imageIdFrameNumber = Number(imageId.split(\"frame=\")[1]);\n\n        return (\n            //frameNumber is zero indexed for cornerstoneDICOMImageLoader image Ids.\n            sopCommonModule.sopInstanceUID === sopInstanceUid &&\n            imageIdFrameNumber === frameNumber - 1\n        );\n    });\n\n    return imageId;\n}\n\n/**\n * getValidOrientations - returns an array of valid orientations.\n *\n * @param  iop - The row (0..2) an column (3..5) direction cosines.\n * @return  An array of valid orientations.\n */\nfunction getValidOrientations(iop) {\n    const orientations = [];\n\n    // [0,  1,  2]: 0,   0hf,   0vf\n    // [3,  4,  5]: 90,  90hf,  90vf\n    // [6, 7]:      180, 270\n\n    orientations[0] = iop;\n    orientations[1] = flipIOP.h(iop);\n    orientations[2] = flipIOP.v(iop);\n\n    const iop90 = rotateDirectionCosinesInPlane(iop, Math.PI / 2);\n\n    orientations[3] = iop90;\n    orientations[4] = flipIOP.h(iop90);\n    orientations[5] = flipIOP.v(iop90);\n\n    orientations[6] = rotateDirectionCosinesInPlane(iop, Math.PI);\n    orientations[7] = rotateDirectionCosinesInPlane(iop, 1.5 * Math.PI);\n\n    return orientations;\n}\n\n/**\n * alignPixelDataWithSourceData -\n *\n * @param pixelData2D - The data to align.\n * @param iop - The orientation of the image slice.\n * @param orientations - An array of valid imageOrientationPatient values.\n * @return The aligned pixelData.\n */\nfunction alignPixelDataWithSourceData(pixelData2D, iop, orientations) {\n    if (compareIOP(iop, orientations[0])) {\n        //Same orientation.\n        return pixelData2D;\n    } else if (compareIOP(iop, orientations[1])) {\n        //Flipped vertically.\n        return flipMatrix2D.v(pixelData2D);\n    } else if (compareIOP(iop, orientations[2])) {\n        //Flipped horizontally.\n        return flipMatrix2D.h(pixelData2D);\n    } else if (compareIOP(iop, orientations[3])) {\n        //Rotated 90 degrees.\n        return rotateMatrix902D(pixelData2D);\n    } else if (compareIOP(iop, orientations[4])) {\n        //Rotated 90 degrees and fliped horizontally.\n        return flipMatrix2D.h(rotateMatrix902D(pixelData2D));\n    } else if (compareIOP(iop, orientations[5])) {\n        //Rotated 90 degrees and fliped vertically.\n        return flipMatrix2D.v(rotateMatrix902D(pixelData2D));\n    } else if (compareIOP(iop, orientations[6])) {\n        //Rotated 180 degrees. // TODO -> Do this more effeciently, there is a 1:1 mapping like 90 degree rotation.\n        return rotateMatrix902D(rotateMatrix902D(pixelData2D));\n    } else if (compareIOP(iop, orientations[7])) {\n        //Rotated 270 degrees.  // TODO -> Do this more effeciently, there is a 1:1 mapping like 90 degree rotation.\n        return rotateMatrix902D(\n            rotateMatrix902D(rotateMatrix902D(pixelData2D))\n        );\n    }\n}\n\nconst dx = 1e-5;\n\n/**\n * compareIOP - Returns true if iop1 and iop2 are equal\n * within a tollerance, dx.\n *\n * @param  iop1 - An ImageOrientationPatient array.\n * @param  iop2 - An ImageOrientationPatient array.\n * @return True if iop1 and iop2 are equal.\n */\nfunction compareIOP(iop1, iop2) {\n    return (\n        Math.abs(iop1[0] - iop2[0]) < dx &&\n        Math.abs(iop1[1] - iop2[1]) < dx &&\n        Math.abs(iop1[2] - iop2[2]) < dx &&\n        Math.abs(iop1[3] - iop2[3]) < dx &&\n        Math.abs(iop1[4] - iop2[4]) < dx &&\n        Math.abs(iop1[5] - iop2[5]) < dx\n    );\n}\n\nfunction getSegmentMetadata(multiframe) {\n    const data = [];\n\n    const segmentSequence = multiframe.SegmentSequence;\n\n    if (Array.isArray(segmentSequence)) {\n        for (let segIdx = 0; segIdx < segmentSequence.length; segIdx++) {\n            data.push(segmentSequence[segIdx]);\n        }\n    } else {\n        // Only one segment, will be stored as an object.\n        data.push(segmentSequence);\n    }\n\n    return {\n        seriesInstanceUid:\n            multiframe.ReferencedSeriesSequence.SeriesInstanceUID,\n        data\n    };\n}\n","/**\n * Cornerstone adapters events\n */\nenum Events {\n    /**\n     * Cornerstone segmentation load progress event\n     */\n    SEGMENTATION_LOAD_PROGRESS = \"CORNERSTONE_ADAPTER_SEGMENTATION_LOAD_PROGRESS\"\n}\n\nexport default Events;\n","import {\n    log,\n    data as dcmjsData,\n    utilities,\n    normalizers,\n    derivations\n} from \"dcmjs\";\nimport ndarray from \"ndarray\";\nimport cloneDeep from \"lodash.clonedeep\";\n\nimport { Events } from \"../enums\";\n\nconst {\n    rotateDirectionCosinesInPlane,\n    flipImageOrientationPatient: flipIOP,\n    flipMatrix2D,\n    rotateMatrix902D,\n    nearlyEqual\n} = utilities.orientation;\n\nconst { BitArray, DicomMessage, DicomMetaDictionary } = dcmjsData;\n\nconst { Normalizer } = normalizers;\nconst { Segmentation: SegmentationDerivation } = derivations;\n\nconst { encode, decode } = utilities.compression;\n\n/**\n *\n * @typedef {Object} BrushData\n * @property {Object} toolState - The cornerstoneTools global toolState.\n * @property {Object[]} segments - The cornerstoneTools segment metadata that corresponds to the\n *                                 seriesInstanceUid.\n */\nconst generateSegmentationDefaultOptions = {\n    includeSliceSpacing: true,\n    rleEncode: false\n};\n\n/**\n * generateSegmentation - Generates cornerstoneTools brush data, given a stack of\n * imageIds, images and the cornerstoneTools brushData.\n *\n * @param  {object[]} images An array of cornerstone images that contain the source\n *                           data under `image.data.byteArray.buffer`.\n * @param  {Object|Object[]} inputLabelmaps3D The cornerstone `Labelmap3D` object, or an array of objects.\n * @param  {Object} userOptions Options to pass to the segmentation derivation and `fillSegmentation`.\n * @returns {Blob}\n */\nfunction generateSegmentation(images, inputLabelmaps3D, userOptions = {}) {\n    const isMultiframe = images[0].imageId.includes(\"?frame\");\n    const segmentation = _createSegFromImages(\n        images,\n        isMultiframe,\n        userOptions\n    );\n\n    return fillSegmentation(segmentation, inputLabelmaps3D, userOptions);\n}\n\n/**\n * Fills a given segmentation object with data from the input labelmaps3D\n *\n * @param segmentation - The segmentation object to be filled.\n * @param inputLabelmaps3D - An array of 3D labelmaps, or a single 3D labelmap.\n * @param userOptions - Optional configuration settings. Will override the default options.\n *\n * @returns {object} The filled segmentation object.\n */\nfunction fillSegmentation(segmentation, inputLabelmaps3D, userOptions = {}) {\n    const options = Object.assign(\n        {},\n        generateSegmentationDefaultOptions,\n        userOptions\n    );\n\n    // Use another variable so we don't redefine labelmaps3D.\n    const labelmaps3D = Array.isArray(inputLabelmaps3D)\n        ? inputLabelmaps3D\n        : [inputLabelmaps3D];\n\n    let numberOfFrames = 0;\n    const referencedFramesPerLabelmap = [];\n\n    for (\n        let labelmapIndex = 0;\n        labelmapIndex < labelmaps3D.length;\n        labelmapIndex++\n    ) {\n        const labelmap3D = labelmaps3D[labelmapIndex];\n        const { labelmaps2D, metadata } = labelmap3D;\n\n        const referencedFramesPerSegment = [];\n\n        for (let i = 1; i < metadata.length; i++) {\n            if (metadata[i]) {\n                referencedFramesPerSegment[i] = [];\n            }\n        }\n\n        for (let i = 0; i < labelmaps2D.length; i++) {\n            const labelmap2D = labelmaps2D[i];\n\n            if (labelmaps2D[i]) {\n                const { segmentsOnLabelmap } = labelmap2D;\n\n                segmentsOnLabelmap.forEach(segmentIndex => {\n                    if (segmentIndex !== 0) {\n                        referencedFramesPerSegment[segmentIndex].push(i);\n                        numberOfFrames++;\n                    }\n                });\n            }\n        }\n\n        referencedFramesPerLabelmap[labelmapIndex] = referencedFramesPerSegment;\n    }\n\n    segmentation.setNumberOfFrames(numberOfFrames);\n\n    for (\n        let labelmapIndex = 0;\n        labelmapIndex < labelmaps3D.length;\n        labelmapIndex++\n    ) {\n        const referencedFramesPerSegment =\n            referencedFramesPerLabelmap[labelmapIndex];\n\n        const labelmap3D = labelmaps3D[labelmapIndex];\n        const { metadata } = labelmap3D;\n\n        for (\n            let segmentIndex = 1;\n            segmentIndex < referencedFramesPerSegment.length;\n            segmentIndex++\n        ) {\n            const referencedFrameIndicies =\n                referencedFramesPerSegment[segmentIndex];\n\n            if (referencedFrameIndicies) {\n                // Frame numbers start from 1.\n                const referencedFrameNumbers = referencedFrameIndicies.map(\n                    element => {\n                        return element + 1;\n                    }\n                );\n                const segmentMetadata = metadata[segmentIndex];\n                const labelmaps = _getLabelmapsFromReferencedFrameIndicies(\n                    labelmap3D,\n                    referencedFrameIndicies\n                );\n\n                segmentation.addSegmentFromLabelmap(\n                    segmentMetadata,\n                    labelmaps,\n                    segmentIndex,\n                    referencedFrameNumbers\n                );\n            }\n        }\n    }\n    if (options.rleEncode) {\n        const rleEncodedFrames = encode(\n            segmentation.dataset.PixelData,\n            numberOfFrames,\n            segmentation.dataset.Rows,\n            segmentation.dataset.Columns\n        );\n\n        // Must use fractional now to RLE encode, as the DICOM standard only allows BitStored && BitsAllocated\n        // to be 1 for BINARY. This is not ideal and there should be a better format for compression in this manner\n        // added to the standard.\n        segmentation.assignToDataset({\n            BitsAllocated: \"8\",\n            BitsStored: \"8\",\n            HighBit: \"7\",\n            SegmentationType: \"FRACTIONAL\",\n            SegmentationFractionalType: \"PROBABILITY\",\n            MaximumFractionalValue: \"255\"\n        });\n\n        segmentation.dataset._meta.TransferSyntaxUID = {\n            Value: [\"1.2.840.10008.1.2.5\"],\n            vr: \"UI\"\n        };\n        segmentation.dataset._vrMap.PixelData = \"OB\";\n        segmentation.dataset.PixelData = rleEncodedFrames;\n    } else {\n        // If no rleEncoding, at least bitpack the data.\n        segmentation.bitPackPixelData();\n    }\n\n    return segmentation;\n}\n\nfunction _getLabelmapsFromReferencedFrameIndicies(\n    labelmap3D,\n    referencedFrameIndicies\n) {\n    const { labelmaps2D } = labelmap3D;\n\n    const labelmaps = [];\n\n    for (let i = 0; i < referencedFrameIndicies.length; i++) {\n        const frame = referencedFrameIndicies[i];\n\n        labelmaps.push(labelmaps2D[frame].pixelData);\n    }\n\n    return labelmaps;\n}\n\n/**\n * _createSegFromImages - description\n *\n * @param  {Object[]} images    An array of the cornerstone image objects.\n * @param  {Boolean} isMultiframe Whether the images are multiframe.\n * @returns {Object}              The Seg derived dataSet.\n */\nfunction _createSegFromImages(images, isMultiframe, options) {\n    const datasets = [];\n\n    if (isMultiframe) {\n        const image = images[0];\n        const arrayBuffer = image.data.byteArray.buffer;\n\n        const dicomData = DicomMessage.readFile(arrayBuffer);\n        const dataset = DicomMetaDictionary.naturalizeDataset(dicomData.dict);\n\n        dataset._meta = DicomMetaDictionary.namifyDataset(dicomData.meta);\n\n        datasets.push(dataset);\n    } else {\n        for (let i = 0; i < images.length; i++) {\n            const image = images[i];\n            const arrayBuffer = image.data.byteArray.buffer;\n            const dicomData = DicomMessage.readFile(arrayBuffer);\n            const dataset = DicomMetaDictionary.naturalizeDataset(\n                dicomData.dict\n            );\n\n            dataset._meta = DicomMetaDictionary.namifyDataset(dicomData.meta);\n            datasets.push(dataset);\n        }\n    }\n\n    const multiframe = Normalizer.normalizeToDataset(datasets);\n\n    return new SegmentationDerivation([multiframe], options);\n}\n\n/**\n * generateToolState - Given a set of cornrstoneTools imageIds and a Segmentation buffer,\n * derive cornerstoneTools toolState and brush metadata.\n *\n * @param  {string[]} imageIds - An array of the imageIds.\n * @param  {ArrayBuffer} arrayBuffer - The SEG arrayBuffer.\n * @param  {*} metadataProvider.\n * @param  {obj} options - Options object.\n *\n * @return {[]ArrayBuffer}a list of array buffer for each labelMap\n * @return {Object} an object from which the segment metadata can be derived\n * @return {[][][]} 2D list containing the track of segments per frame\n * @return {[][][]} 3D list containing the track of segments per frame for each labelMap\n *                  (available only for the overlapping case).\n */\nasync function generateToolState(\n    imageIds,\n    arrayBuffer,\n    metadataProvider,\n    options\n) {\n    const {\n        skipOverlapping = false,\n        tolerance = 1e-3,\n        TypedArrayConstructor = Uint8Array,\n        maxBytesPerChunk = 199000000,\n        eventTarget,\n        triggerEvent\n    } = options;\n    const dicomData = DicomMessage.readFile(arrayBuffer);\n    const dataset = DicomMetaDictionary.naturalizeDataset(dicomData.dict);\n    dataset._meta = DicomMetaDictionary.namifyDataset(dicomData.meta);\n    const multiframe = Normalizer.normalizeToDataset([dataset]);\n\n    const imagePlaneModule = metadataProvider.get(\n        \"imagePlaneModule\",\n        imageIds[0]\n    );\n\n    const generalSeriesModule = metadataProvider.get(\n        \"generalSeriesModule\",\n        imageIds[0]\n    );\n\n    const SeriesInstanceUID = generalSeriesModule.seriesInstanceUID;\n\n    if (!imagePlaneModule) {\n        console.warn(\"Insufficient metadata, imagePlaneModule missing.\");\n    }\n\n    const ImageOrientationPatient = Array.isArray(imagePlaneModule.rowCosines)\n        ? [...imagePlaneModule.rowCosines, ...imagePlaneModule.columnCosines]\n        : [\n              imagePlaneModule.rowCosines.x,\n              imagePlaneModule.rowCosines.y,\n              imagePlaneModule.rowCosines.z,\n              imagePlaneModule.columnCosines.x,\n              imagePlaneModule.columnCosines.y,\n              imagePlaneModule.columnCosines.z\n          ];\n\n    // Get IOP from ref series, compute supported orientations:\n    const validOrientations = getValidOrientations(ImageOrientationPatient);\n\n    const sliceLength = multiframe.Columns * multiframe.Rows;\n    const segMetadata = getSegmentMetadata(multiframe, SeriesInstanceUID);\n\n    const TransferSyntaxUID = multiframe._meta.TransferSyntaxUID.Value[0];\n\n    let pixelData;\n    let pixelDataChunks;\n\n    if (TransferSyntaxUID === \"1.2.840.10008.1.2.5\") {\n        const rleEncodedFrames = Array.isArray(multiframe.PixelData)\n            ? multiframe.PixelData\n            : [multiframe.PixelData];\n\n        pixelData = decode(\n            rleEncodedFrames,\n            multiframe.Rows,\n            multiframe.Columns\n        );\n\n        if (multiframe.BitsStored === 1) {\n            console.warn(\"No implementation for rle + bitbacking.\");\n\n            return;\n        }\n\n        // Todo: need to test this with rle data\n        pixelDataChunks = [pixelData];\n    } else {\n        pixelDataChunks = unpackPixelData(multiframe, { maxBytesPerChunk });\n\n        if (!pixelDataChunks) {\n            throw new Error(\"Fractional segmentations are not yet supported\");\n        }\n    }\n\n    const orientation = checkOrientation(\n        multiframe,\n        validOrientations,\n        [imagePlaneModule.rows, imagePlaneModule.columns, imageIds.length],\n        tolerance\n    );\n\n    // Pre-compute the sop UID to imageId index map so that in the for loop\n    // we don't have to call metadataProvider.get() for each imageId over\n    // and over again.\n    const sopUIDImageIdIndexMap = imageIds.reduce((acc, imageId) => {\n        const { sopInstanceUid } = metadataProvider.get(\n            \"generalImageModule\",\n            imageId\n        );\n        acc[sopInstanceUid] = imageId;\n        return acc;\n    }, {});\n\n    let overlapping = false;\n    if (!skipOverlapping) {\n        overlapping = checkSEGsOverlapping(\n            pixelDataChunks,\n            multiframe,\n            imageIds,\n            validOrientations,\n            metadataProvider,\n            tolerance,\n            TypedArrayConstructor,\n            sopUIDImageIdIndexMap\n        );\n    }\n\n    let insertFunction;\n\n    switch (orientation) {\n        case \"Planar\":\n            if (overlapping) {\n                insertFunction = insertOverlappingPixelDataPlanar;\n            } else {\n                insertFunction = insertPixelDataPlanar;\n            }\n            break;\n        case \"Perpendicular\":\n            //insertFunction = insertPixelDataPerpendicular;\n            throw new Error(\n                \"Segmentations orthogonal to the acquisition plane of the source data are not yet supported.\"\n            );\n        case \"Oblique\":\n            throw new Error(\n                \"Segmentations oblique to the acquisition plane of the source data are not yet supported.\"\n            );\n    }\n\n    /* if SEGs are overlapping:\n    1) the labelmapBuffer will contain M volumes which have non-overlapping segments;\n    2) segmentsOnFrame will have M * numberOfFrames values to track in which labelMap are the segments;\n    3) insertFunction will return the number of LabelMaps\n    4) generateToolState return is an array*/\n\n    const segmentsOnFrameArray = [];\n    segmentsOnFrameArray[0] = [];\n    const segmentsOnFrame = [];\n\n    const arrayBufferLength =\n        sliceLength * imageIds.length * TypedArrayConstructor.BYTES_PER_ELEMENT;\n    const labelmapBufferArray = [];\n    labelmapBufferArray[0] = new ArrayBuffer(arrayBufferLength);\n\n    // Pre-compute the indices and metadata so that we don't have to call\n    // a function for each imageId in the for loop.\n    const imageIdMaps = imageIds.reduce(\n        (acc, curr, index) => {\n            acc.indices[curr] = index;\n            acc.metadata[curr] = metadataProvider.get(\"instance\", curr);\n            return acc;\n        },\n        { indices: {}, metadata: {} }\n    );\n\n    // This is the centroid calculation for each segment Index, the data structure\n    // is a Map with key = segmentIndex and value = {imageIdIndex: centroid, ...}\n    // later on we will use this data structure to calculate the centroid of the\n    // segment in the labelmapBuffer\n    const segmentsPixelIndices = new Map();\n\n    const overlappingSegments = await insertFunction(\n        segmentsOnFrame,\n        segmentsOnFrameArray,\n        labelmapBufferArray,\n        pixelDataChunks,\n        multiframe,\n        imageIds,\n        validOrientations,\n        metadataProvider,\n        tolerance,\n        TypedArrayConstructor,\n        segmentsPixelIndices,\n        sopUIDImageIdIndexMap,\n        imageIdMaps,\n        eventTarget,\n        triggerEvent\n    );\n\n    // calculate the centroid of each segment\n    const centroidXYZ = new Map();\n\n    segmentsPixelIndices.forEach((imageIdIndexBufferIndex, segmentIndex) => {\n        const { xAcc, yAcc, zAcc, count } = calculateCentroid(\n            imageIdIndexBufferIndex,\n            multiframe\n        );\n\n        centroidXYZ.set(segmentIndex, {\n            x: Math.floor(xAcc / count),\n            y: Math.floor(yAcc / count),\n            z: Math.floor(zAcc / count)\n        });\n    });\n\n    return {\n        labelmapBufferArray,\n        segMetadata,\n        segmentsOnFrame,\n        segmentsOnFrameArray,\n        centroids: centroidXYZ,\n        overlappingSegments\n    };\n}\n\n// function insertPixelDataPerpendicular(\n//     segmentsOnFrame,\n//     labelmapBuffer,\n//     pixelData,\n//     multiframe,\n//     imageIds,\n//     validOrientations,\n//     metadataProvider\n// ) {\n//     const {\n//         SharedFunctionalGroupsSequence,\n//         PerFrameFunctionalGroupsSequence,\n//         Rows,\n//         Columns\n//     } = multiframe;\n\n//     const firstImagePlaneModule = metadataProvider.get(\n//         \"imagePlaneModule\",\n//         imageIds[0]\n//     );\n\n//     const lastImagePlaneModule = metadataProvider.get(\n//         \"imagePlaneModule\",\n//         imageIds[imageIds.length - 1]\n//     );\n\n//     console.log(firstImagePlaneModule);\n//     console.log(lastImagePlaneModule);\n\n//     const corners = [\n//         ...getCorners(firstImagePlaneModule),\n//         ...getCorners(lastImagePlaneModule)\n//     ];\n\n//     console.log(`corners:`);\n//     console.log(corners);\n\n//     const indexToWorld = mat4.create();\n\n//     const ippFirstFrame = firstImagePlaneModule.imagePositionPatient;\n//     const rowCosines = Array.isArray(firstImagePlaneModule.rowCosines)\n//         ? [...firstImagePlaneModule.rowCosines]\n//         : [\n//               firstImagePlaneModule.rowCosines.x,\n//               firstImagePlaneModule.rowCosines.y,\n//               firstImagePlaneModule.rowCosines.z\n//           ];\n\n//     const columnCosines = Array.isArray(firstImagePlaneModule.columnCosines)\n//         ? [...firstImagePlaneModule.columnCosines]\n//         : [\n//               firstImagePlaneModule.columnCosines.x,\n//               firstImagePlaneModule.columnCosines.y,\n//               firstImagePlaneModule.columnCosines.z\n//           ];\n\n//     const { pixelSpacing } = firstImagePlaneModule;\n\n//     mat4.set(\n//         indexToWorld,\n//         // Column 1\n//         0,\n//         0,\n//         0,\n//         ippFirstFrame[0],\n//         // Column 2\n//         0,\n//         0,\n//         0,\n//         ippFirstFrame[1],\n//         // Column 3\n//         0,\n//         0,\n//         0,\n//         ippFirstFrame[2],\n//         // Column 4\n//         0,\n//         0,\n//         0,\n//         1\n//     );\n\n//     // TODO -> Get origin and (x,y,z) increments to build a translation matrix:\n//     // TODO -> Equation C.7.6.2.1-1\n\n//     // | cx*di rx* Xx 0 |  |x|\n//     // | cy*di ry Xy 0 |  |y|\n//     // | cz*di rz Xz 0 |  |z|\n//     // | tx ty tz 1 |  |1|\n\n//     // const [\n//     //     0, 0 , 0 , 0,\n//     //     0, 0 , 0 , 0,\n//     //     0, 0 , 0 , 0,\n//     //     ipp[0], ipp[1] , ipp[2] , 1,\n//     // ]\n\n//     // Each frame:\n\n//     // Find which corner the first voxel lines up with (one of 8 corners.)\n\n//     // Find how i,j,k orient with respect to source volume.\n//     // Go through each frame, find location in source to start, and whether to increment +/ix,+/-y,+/-z\n//     //   through each voxel.\n\n//     // [1,0,0,0,1,0]\n\n//     // const [\n\n//     // ]\n\n//     // Invert transformation matrix to get worldToIndex\n\n//     // Apply world to index on each point to fill up the matrix.\n\n//     // const sharedImageOrientationPatient = SharedFunctionalGroupsSequence.PlaneOrientationSequence\n//     //     ? SharedFunctionalGroupsSequence.PlaneOrientationSequence\n//     //           .ImageOrientationPatient\n//     //     : undefined;\n//     // const sliceLength = Columns * Rows;\n// }\n\n// function getCorners(imagePlaneModule) {\n//     // console.log(imagePlaneModule);\n\n//     const {\n//         rows,\n//         columns,\n//         rowCosines,\n//         columnCosines,\n//         imagePositionPatient: ipp,\n//         rowPixelSpacing,\n//         columnPixelSpacing\n//     } = imagePlaneModule;\n\n//     const rowLength = columns * columnPixelSpacing;\n//     const columnLength = rows * rowPixelSpacing;\n\n//     const entireRowVector = [\n//         rowLength * columnCosines[0],\n//         rowLength * columnCosines[1],\n//         rowLength * columnCosines[2]\n//     ];\n\n//     const entireColumnVector = [\n//         columnLength * rowCosines[0],\n//         columnLength * rowCosines[1],\n//         columnLength * rowCosines[2]\n//     ];\n\n//     const topLeft = [ipp[0], ipp[1], ipp[2]];\n//     const topRight = [\n//         topLeft[0] + entireRowVector[0],\n//         topLeft[1] + entireRowVector[1],\n//         topLeft[2] + entireRowVector[2]\n//     ];\n//     const bottomLeft = [\n//         topLeft[0] + entireColumnVector[0],\n//         topLeft[1] + entireColumnVector[1],\n//         topLeft[2] + entireColumnVector[2]\n//     ];\n\n//     const bottomRight = [\n//         bottomLeft[0] + entireRowVector[0],\n//         bottomLeft[1] + entireRowVector[1],\n//         bottomLeft[2] + entireRowVector[2]\n//     ];\n\n//     return [topLeft, topRight, bottomLeft, bottomRight];\n// }\n\n/**\n * Find the reference frame of the segmentation frame in the source data.\n *\n * @param  {Object}      multiframe        dicom metadata\n * @param  {Int}         frameSegment      frame dicom index\n * @param  {String[]}    imageIds          A list of imageIds.\n * @param  {Object}      sopUIDImageIdIndexMap  A map of SOPInstanceUID to imageId\n * @param  {Float}       tolerance         The tolerance parameter\n *\n * @returns {String}     Returns the imageId\n */\nfunction findReferenceSourceImageId(\n    multiframe,\n    frameSegment,\n    imageIds,\n    metadataProvider,\n    tolerance,\n    sopUIDImageIdIndexMap\n) {\n    let imageId = undefined;\n\n    if (!multiframe) {\n        return imageId;\n    }\n\n    const {\n        FrameOfReferenceUID,\n        PerFrameFunctionalGroupsSequence,\n        SourceImageSequence,\n        ReferencedSeriesSequence\n    } = multiframe;\n\n    if (\n        !PerFrameFunctionalGroupsSequence ||\n        PerFrameFunctionalGroupsSequence.length === 0\n    ) {\n        return imageId;\n    }\n\n    const PerFrameFunctionalGroup =\n        PerFrameFunctionalGroupsSequence[frameSegment];\n\n    if (!PerFrameFunctionalGroup) {\n        return imageId;\n    }\n\n    let frameSourceImageSequence = undefined;\n    if (PerFrameFunctionalGroup.DerivationImageSequence) {\n        let DerivationImageSequence =\n            PerFrameFunctionalGroup.DerivationImageSequence;\n        if (Array.isArray(DerivationImageSequence)) {\n            if (DerivationImageSequence.length !== 0) {\n                DerivationImageSequence = DerivationImageSequence[0];\n            } else {\n                DerivationImageSequence = undefined;\n            }\n        }\n\n        if (DerivationImageSequence) {\n            frameSourceImageSequence =\n                DerivationImageSequence.SourceImageSequence;\n            if (Array.isArray(frameSourceImageSequence)) {\n                if (frameSourceImageSequence.length !== 0) {\n                    frameSourceImageSequence = frameSourceImageSequence[0];\n                } else {\n                    frameSourceImageSequence = undefined;\n                }\n            }\n        }\n    } else if (SourceImageSequence && SourceImageSequence.length !== 0) {\n        console.warn(\n            \"DerivationImageSequence not present, using SourceImageSequence assuming SEG has the same geometry as the source image.\"\n        );\n        frameSourceImageSequence = SourceImageSequence[frameSegment];\n    }\n\n    if (frameSourceImageSequence) {\n        imageId = getImageIdOfSourceImageBySourceImageSequence(\n            frameSourceImageSequence,\n            sopUIDImageIdIndexMap\n        );\n    }\n\n    if (imageId === undefined && ReferencedSeriesSequence) {\n        const referencedSeriesSequence = Array.isArray(ReferencedSeriesSequence)\n            ? ReferencedSeriesSequence[0]\n            : ReferencedSeriesSequence;\n        const ReferencedSeriesInstanceUID =\n            referencedSeriesSequence.SeriesInstanceUID;\n\n        imageId = getImageIdOfSourceImagebyGeometry(\n            ReferencedSeriesInstanceUID,\n            FrameOfReferenceUID,\n            PerFrameFunctionalGroup,\n            imageIds,\n            metadataProvider,\n            tolerance\n        );\n    }\n\n    return imageId;\n}\n\n/**\n * Checks if there is any overlapping segmentations.\n *  @returns {boolean} Returns a flag if segmentations overlapping\n */\n\nfunction checkSEGsOverlapping(\n    pixelData,\n    multiframe,\n    imageIds,\n    validOrientations,\n    metadataProvider,\n    tolerance,\n    TypedArrayConstructor,\n    sopUIDImageIdIndexMap\n) {\n    const {\n        SharedFunctionalGroupsSequence,\n        PerFrameFunctionalGroupsSequence,\n        SegmentSequence,\n        Rows,\n        Columns\n    } = multiframe;\n\n    let numberOfSegs = SegmentSequence.length;\n    if (numberOfSegs < 2) {\n        return false;\n    }\n\n    const sharedImageOrientationPatient =\n        SharedFunctionalGroupsSequence.PlaneOrientationSequence\n            ? SharedFunctionalGroupsSequence.PlaneOrientationSequence\n                  .ImageOrientationPatient\n            : undefined;\n    const sliceLength = Columns * Rows;\n    const groupsLen = PerFrameFunctionalGroupsSequence.length;\n\n    /** sort groupsLen to have all the segments for each frame in an array\n     * frame 2 : 1, 2\n     * frame 4 : 1, 3\n     * frame 5 : 4\n     */\n\n    let frameSegmentsMapping = new Map();\n    for (let frameSegment = 0; frameSegment < groupsLen; ++frameSegment) {\n        const segmentIndex = getSegmentIndex(multiframe, frameSegment);\n        if (segmentIndex === undefined) {\n            console.warn(\n                \"Could not retrieve the segment index for frame segment \" +\n                    frameSegment +\n                    \", skipping this frame.\"\n            );\n            continue;\n        }\n\n        const imageId = findReferenceSourceImageId(\n            multiframe,\n            frameSegment,\n            imageIds,\n            metadataProvider,\n            tolerance,\n            sopUIDImageIdIndexMap\n        );\n\n        if (!imageId) {\n            console.warn(\n                \"Image not present in stack, can't import frame : \" +\n                    frameSegment +\n                    \".\"\n            );\n            continue;\n        }\n\n        const imageIdIndex = imageIds.findIndex(element => element === imageId);\n\n        if (frameSegmentsMapping.has(imageIdIndex)) {\n            let segmentArray = frameSegmentsMapping.get(imageIdIndex);\n            if (!segmentArray.includes(frameSegment)) {\n                segmentArray.push(frameSegment);\n                frameSegmentsMapping.set(imageIdIndex, segmentArray);\n            }\n        } else {\n            frameSegmentsMapping.set(imageIdIndex, [frameSegment]);\n        }\n    }\n\n    for (let [, role] of frameSegmentsMapping.entries()) {\n        let temp2DArray = new TypedArrayConstructor(sliceLength).fill(0);\n\n        for (let i = 0; i < role.length; ++i) {\n            const frameSegment = role[i];\n\n            const PerFrameFunctionalGroups =\n                PerFrameFunctionalGroupsSequence[frameSegment];\n\n            const ImageOrientationPatientI =\n                sharedImageOrientationPatient ||\n                PerFrameFunctionalGroups.PlaneOrientationSequence\n                    .ImageOrientationPatient;\n\n            const view = readFromUnpackedChunks(\n                pixelData,\n                frameSegment * sliceLength,\n                sliceLength\n            );\n\n            const pixelDataI2D = ndarray(view, [Rows, Columns]);\n\n            const alignedPixelDataI = alignPixelDataWithSourceData(\n                pixelDataI2D,\n                ImageOrientationPatientI,\n                validOrientations,\n                tolerance\n            );\n\n            if (!alignedPixelDataI) {\n                console.warn(\n                    \"Individual SEG frames are out of plane with respect to the first SEG frame, this is not yet supported, skipping this frame.\"\n                );\n                continue;\n            }\n\n            const data = alignedPixelDataI.data;\n            for (let j = 0, len = data.length; j < len; ++j) {\n                if (data[j] !== 0) {\n                    temp2DArray[j]++;\n                    if (temp2DArray[j] > 1) {\n                        return true;\n                    }\n                }\n            }\n        }\n    }\n\n    return false;\n}\n\nfunction insertOverlappingPixelDataPlanar(\n    segmentsOnFrame,\n    segmentsOnFrameArray,\n    labelmapBufferArray,\n    pixelData,\n    multiframe,\n    imageIds,\n    validOrientations,\n    metadataProvider,\n    tolerance,\n    TypedArrayConstructor,\n    segmentsPixelIndices,\n    sopUIDImageIdIndexMap\n) {\n    const {\n        SharedFunctionalGroupsSequence,\n        PerFrameFunctionalGroupsSequence,\n        Rows,\n        Columns\n    } = multiframe;\n\n    const sharedImageOrientationPatient =\n        SharedFunctionalGroupsSequence.PlaneOrientationSequence\n            ? SharedFunctionalGroupsSequence.PlaneOrientationSequence\n                  .ImageOrientationPatient\n            : undefined;\n    const sliceLength = Columns * Rows;\n    const arrayBufferLength =\n        sliceLength * imageIds.length * TypedArrayConstructor.BYTES_PER_ELEMENT;\n    // indicate the number of labelMaps\n    let M = 1;\n\n    // indicate the current labelMap array index;\n    let m = 0;\n\n    // temp array for checking overlaps\n    let tempBuffer = labelmapBufferArray[m].slice(0);\n\n    // temp list for checking overlaps\n    let tempSegmentsOnFrame = cloneDeep(segmentsOnFrameArray[m]);\n\n    /** split overlapping SEGs algorithm for each segment:\n     *  A) copy the labelmapBuffer in the array with index 0\n     *  B) add the segment pixel per pixel on the copied buffer from (A)\n     *  C) if no overlap, copy the results back on the orignal array from (A)\n     *  D) if overlap, repeat increasing the index m up to M (if out of memory, add new buffer in the array and M++);\n     */\n\n    let numberOfSegs = multiframe.SegmentSequence.length;\n    for (\n        let segmentIndexToProcess = 1;\n        segmentIndexToProcess <= numberOfSegs;\n        ++segmentIndexToProcess\n    ) {\n        for (\n            let i = 0, groupsLen = PerFrameFunctionalGroupsSequence.length;\n            i < groupsLen;\n            ++i\n        ) {\n            const PerFrameFunctionalGroups =\n                PerFrameFunctionalGroupsSequence[i];\n\n            const segmentIndex = getSegmentIndex(multiframe, i);\n            if (segmentIndex === undefined) {\n                throw new Error(\n                    \"Could not retrieve the segment index. Aborting segmentation loading.\"\n                );\n            }\n\n            if (segmentIndex !== segmentIndexToProcess) {\n                continue;\n            }\n\n            const ImageOrientationPatientI =\n                sharedImageOrientationPatient ||\n                PerFrameFunctionalGroups.PlaneOrientationSequence\n                    .ImageOrientationPatient;\n\n            // Since we moved to the chunks approach, we need to read the data\n            // and handle scenarios where the portion of data is in one chunk\n            // and the other portion is in another chunk\n            const view = readFromUnpackedChunks(\n                pixelData,\n                i * sliceLength,\n                sliceLength\n            );\n\n            const pixelDataI2D = ndarray(view, [Rows, Columns]);\n\n            const alignedPixelDataI = alignPixelDataWithSourceData(\n                pixelDataI2D,\n                ImageOrientationPatientI,\n                validOrientations,\n                tolerance\n            );\n\n            if (!alignedPixelDataI) {\n                throw new Error(\n                    \"Individual SEG frames are out of plane with respect to the first SEG frame. \" +\n                        \"This is not yet supported. Aborting segmentation loading.\"\n                );\n            }\n\n            const imageId = findReferenceSourceImageId(\n                multiframe,\n                i,\n                imageIds,\n                metadataProvider,\n                tolerance,\n                sopUIDImageIdIndexMap\n            );\n\n            if (!imageId) {\n                console.warn(\n                    \"Image not present in stack, can't import frame : \" +\n                        i +\n                        \".\"\n                );\n                continue;\n            }\n\n            const sourceImageMetadata = metadataProvider.get(\n                \"instance\",\n                imageId\n            );\n            if (\n                Rows !== sourceImageMetadata.Rows ||\n                Columns !== sourceImageMetadata.Columns\n            ) {\n                throw new Error(\n                    \"Individual SEG frames have different geometry dimensions (Rows and Columns) \" +\n                        \"respect to the source image reference frame. This is not yet supported. \" +\n                        \"Aborting segmentation loading. \"\n                );\n            }\n\n            const imageIdIndex = imageIds.findIndex(\n                element => element === imageId\n            );\n            const byteOffset =\n                sliceLength *\n                imageIdIndex *\n                TypedArrayConstructor.BYTES_PER_ELEMENT;\n\n            const labelmap2DView = new TypedArrayConstructor(\n                tempBuffer,\n                byteOffset,\n                sliceLength\n            );\n\n            const data = alignedPixelDataI.data;\n\n            let segmentOnFrame = false;\n            for (let j = 0, len = alignedPixelDataI.data.length; j < len; ++j) {\n                if (data[j]) {\n                    if (labelmap2DView[j] !== 0) {\n                        m++;\n                        if (m >= M) {\n                            labelmapBufferArray[m] = new ArrayBuffer(\n                                arrayBufferLength\n                            );\n                            segmentsOnFrameArray[m] = [];\n                            M++;\n                        }\n                        tempBuffer = labelmapBufferArray[m].slice(0);\n                        tempSegmentsOnFrame = cloneDeep(\n                            segmentsOnFrameArray[m]\n                        );\n\n                        i = 0;\n                        break;\n                    } else {\n                        labelmap2DView[j] = segmentIndex;\n                        segmentOnFrame = true;\n                    }\n                }\n            }\n\n            if (segmentOnFrame) {\n                if (!tempSegmentsOnFrame[imageIdIndex]) {\n                    tempSegmentsOnFrame[imageIdIndex] = [];\n                }\n\n                tempSegmentsOnFrame[imageIdIndex].push(segmentIndex);\n\n                if (!segmentsOnFrame[imageIdIndex]) {\n                    segmentsOnFrame[imageIdIndex] = [];\n                }\n\n                segmentsOnFrame[imageIdIndex].push(segmentIndex);\n            }\n        }\n\n        labelmapBufferArray[m] = tempBuffer.slice(0);\n        segmentsOnFrameArray[m] = cloneDeep(tempSegmentsOnFrame);\n\n        // reset temp variables/buffers for new segment\n        m = 0;\n        tempBuffer = labelmapBufferArray[m].slice(0);\n        tempSegmentsOnFrame = cloneDeep(segmentsOnFrameArray[m]);\n    }\n}\n\nconst getSegmentIndex = (multiframe, frame) => {\n    const { PerFrameFunctionalGroupsSequence, SharedFunctionalGroupsSequence } =\n        multiframe;\n    const PerFrameFunctionalGroups = PerFrameFunctionalGroupsSequence[frame];\n    return PerFrameFunctionalGroups &&\n        PerFrameFunctionalGroups.SegmentIdentificationSequence\n        ? PerFrameFunctionalGroups.SegmentIdentificationSequence\n              .ReferencedSegmentNumber\n        : SharedFunctionalGroupsSequence.SegmentIdentificationSequence\n        ? SharedFunctionalGroupsSequence.SegmentIdentificationSequence\n              .ReferencedSegmentNumber\n        : undefined;\n};\n\nfunction insertPixelDataPlanar(\n    segmentsOnFrame,\n    segmentsOnFrameArray,\n    labelmapBufferArray,\n    pixelData,\n    multiframe,\n    imageIds,\n    validOrientations,\n    metadataProvider,\n    tolerance,\n    TypedArrayConstructor,\n    segmentsPixelIndices,\n    sopUIDImageIdIndexMap,\n    imageIdMaps,\n    eventTarget,\n    triggerEvent\n) {\n    const {\n        SharedFunctionalGroupsSequence,\n        PerFrameFunctionalGroupsSequence,\n        Rows,\n        Columns\n    } = multiframe;\n\n    const sharedImageOrientationPatient =\n        SharedFunctionalGroupsSequence.PlaneOrientationSequence\n            ? SharedFunctionalGroupsSequence.PlaneOrientationSequence\n                  .ImageOrientationPatient\n            : undefined;\n    const sliceLength = Columns * Rows;\n\n    let i = 0;\n    const groupsLen = PerFrameFunctionalGroupsSequence.length;\n    const chunkSize = Math.ceil(groupsLen / 10); // 10% of total length\n\n    const shouldTriggerEvent = triggerEvent && eventTarget;\n\n    let overlapping = false;\n    // Below, we chunk the processing of the frames to avoid blocking the main thread\n    // if the segmentation is large. We also use a promise to allow the caller to\n    // wait for the processing to finish.\n    return new Promise(resolve => {\n        function processInChunks() {\n            // process one chunk\n            for (let end = Math.min(i + chunkSize, groupsLen); i < end; ++i) {\n                const PerFrameFunctionalGroups =\n                    PerFrameFunctionalGroupsSequence[i];\n\n                const ImageOrientationPatientI =\n                    sharedImageOrientationPatient ||\n                    PerFrameFunctionalGroups.PlaneOrientationSequence\n                        .ImageOrientationPatient;\n\n                const view = readFromUnpackedChunks(\n                    pixelData,\n                    i * sliceLength,\n                    sliceLength\n                );\n\n                const pixelDataI2D = ndarray(view, [Rows, Columns]);\n\n                const alignedPixelDataI = alignPixelDataWithSourceData(\n                    pixelDataI2D,\n                    ImageOrientationPatientI,\n                    validOrientations,\n                    tolerance\n                );\n\n                if (!alignedPixelDataI) {\n                    throw new Error(\n                        \"Individual SEG frames are out of plane with respect to the first SEG frame. \" +\n                            \"This is not yet supported. Aborting segmentation loading.\"\n                    );\n                }\n\n                const segmentIndex = getSegmentIndex(multiframe, i);\n\n                if (segmentIndex === undefined) {\n                    throw new Error(\n                        \"Could not retrieve the segment index. Aborting segmentation loading.\"\n                    );\n                }\n\n                if (!segmentsPixelIndices.has(segmentIndex)) {\n                    segmentsPixelIndices.set(segmentIndex, {});\n                }\n\n                const imageId = findReferenceSourceImageId(\n                    multiframe,\n                    i,\n                    imageIds,\n                    metadataProvider,\n                    tolerance,\n                    sopUIDImageIdIndexMap\n                );\n\n                if (!imageId) {\n                    console.warn(\n                        \"Image not present in stack, can't import frame : \" +\n                            i +\n                            \".\"\n                    );\n                    continue;\n                }\n\n                const sourceImageMetadata = imageIdMaps.metadata[imageId];\n                if (\n                    Rows !== sourceImageMetadata.Rows ||\n                    Columns !== sourceImageMetadata.Columns\n                ) {\n                    throw new Error(\n                        \"Individual SEG frames have different geometry dimensions (Rows and Columns) \" +\n                            \"respect to the source image reference frame. This is not yet supported. \" +\n                            \"Aborting segmentation loading. \"\n                    );\n                }\n\n                const imageIdIndex = imageIdMaps.indices[imageId];\n\n                const byteOffset =\n                    sliceLength *\n                    imageIdIndex *\n                    TypedArrayConstructor.BYTES_PER_ELEMENT;\n\n                const labelmap2DView = new TypedArrayConstructor(\n                    labelmapBufferArray[0],\n                    byteOffset,\n                    sliceLength\n                );\n\n                const data = alignedPixelDataI.data;\n\n                const indexCache = [];\n                for (\n                    let j = 0, len = alignedPixelDataI.data.length;\n                    j < len;\n                    ++j\n                ) {\n                    if (data[j]) {\n                        for (let x = j; x < len; ++x) {\n                            if (data[x]) {\n                                if (!overlapping && labelmap2DView[x] !== 0) {\n                                    overlapping = true;\n                                }\n                                labelmap2DView[x] = segmentIndex;\n                                indexCache.push(x);\n                            }\n                        }\n\n                        if (!segmentsOnFrame[imageIdIndex]) {\n                            segmentsOnFrame[imageIdIndex] = [];\n                        }\n\n                        segmentsOnFrame[imageIdIndex].push(segmentIndex);\n\n                        break;\n                    }\n                }\n\n                const segmentIndexObject =\n                    segmentsPixelIndices.get(segmentIndex);\n                segmentIndexObject[imageIdIndex] = indexCache;\n                segmentsPixelIndices.set(segmentIndex, segmentIndexObject);\n            }\n\n            // trigger an event after each chunk\n            if (shouldTriggerEvent) {\n                const percentComplete = Math.round((i / groupsLen) * 100);\n                triggerEvent(eventTarget, Events.SEGMENTATION_LOAD_PROGRESS, {\n                    percentComplete\n                });\n            }\n\n            // schedule next chunk\n            if (i < groupsLen) {\n                setTimeout(processInChunks, 0);\n            } else {\n                // resolve the Promise when all chunks have been processed\n                resolve(overlapping);\n            }\n        }\n\n        processInChunks();\n    });\n}\n\nfunction checkOrientation(\n    multiframe,\n    validOrientations,\n    sourceDataDimensions,\n    tolerance\n) {\n    const { SharedFunctionalGroupsSequence, PerFrameFunctionalGroupsSequence } =\n        multiframe;\n\n    const sharedImageOrientationPatient =\n        SharedFunctionalGroupsSequence.PlaneOrientationSequence\n            ? SharedFunctionalGroupsSequence.PlaneOrientationSequence\n                  .ImageOrientationPatient\n            : undefined;\n\n    // Check if in plane.\n    const PerFrameFunctionalGroups = PerFrameFunctionalGroupsSequence[0];\n\n    const iop =\n        sharedImageOrientationPatient ||\n        PerFrameFunctionalGroups.PlaneOrientationSequence\n            .ImageOrientationPatient;\n\n    const inPlane = validOrientations.some(operation =>\n        compareArrays(iop, operation, tolerance)\n    );\n\n    if (inPlane) {\n        return \"Planar\";\n    }\n\n    if (\n        checkIfPerpendicular(iop, validOrientations[0], tolerance) &&\n        sourceDataDimensions.includes(multiframe.Rows) &&\n        sourceDataDimensions.includes(multiframe.Columns)\n    ) {\n        // Perpendicular and fits on same grid.\n        return \"Perpendicular\";\n    }\n\n    return \"Oblique\";\n}\n\n/**\n * checkIfPerpendicular - Returns true if iop1 and iop2 are perpendicular\n * within a tolerance.\n *\n * @param  {Number[6]} iop1 An ImageOrientationPatient array.\n * @param  {Number[6]} iop2 An ImageOrientationPatient array.\n * @param  {Number} tolerance.\n * @return {Boolean} True if iop1 and iop2 are equal.\n */\nfunction checkIfPerpendicular(iop1, iop2, tolerance) {\n    const absDotColumnCosines = Math.abs(\n        iop1[0] * iop2[0] + iop1[1] * iop2[1] + iop1[2] * iop2[2]\n    );\n    const absDotRowCosines = Math.abs(\n        iop1[3] * iop2[3] + iop1[4] * iop2[4] + iop1[5] * iop2[5]\n    );\n\n    return (\n        (absDotColumnCosines < tolerance ||\n            Math.abs(absDotColumnCosines - 1) < tolerance) &&\n        (absDotRowCosines < tolerance ||\n            Math.abs(absDotRowCosines - 1) < tolerance)\n    );\n}\n\n/**\n * unpackPixelData - Unpacks bit packed pixelData if the Segmentation is BINARY.\n *\n * @param  {Object} multiframe The multiframe dataset.\n * @param  {Object} options    Options for the unpacking.\n * @return {Uint8Array}      The unpacked pixelData.\n */\nfunction unpackPixelData(multiframe, options) {\n    const segType = multiframe.SegmentationType;\n\n    let data;\n    if (Array.isArray(multiframe.PixelData)) {\n        data = multiframe.PixelData[0];\n    } else {\n        data = multiframe.PixelData;\n    }\n\n    if (data === undefined) {\n        log.error(\"This segmentation pixeldata is undefined.\");\n    }\n\n    if (segType === \"BINARY\") {\n        // For extreme big data, we can't unpack the data at once and we need to\n        // chunk it and unpack each chunk separately.\n        // MAX 2GB is the limit right now to allocate a buffer\n        return getUnpackedChunks(data, options.maxBytesPerChunk);\n    }\n\n    const pixelData = new Uint8Array(data);\n\n    const max = multiframe.MaximumFractionalValue;\n    const onlyMaxAndZero =\n        pixelData.find(element => element !== 0 && element !== max) ===\n        undefined;\n\n    if (!onlyMaxAndZero) {\n        // This is a fractional segmentation, which is not currently supported.\n        return;\n    }\n\n    log.warn(\n        \"This segmentation object is actually binary... processing as such.\"\n    );\n\n    return pixelData;\n}\n\nfunction getUnpackedChunks(data, maxBytesPerChunk) {\n    var bitArray = new Uint8Array(data);\n    var chunks = [];\n\n    var maxBitsPerChunk = maxBytesPerChunk * 8;\n    var numberOfChunks = Math.ceil((bitArray.length * 8) / maxBitsPerChunk);\n\n    for (var i = 0; i < numberOfChunks; i++) {\n        var startBit = i * maxBitsPerChunk;\n        var endBit = Math.min(startBit + maxBitsPerChunk, bitArray.length * 8);\n\n        var startByte = Math.floor(startBit / 8);\n        var endByte = Math.ceil(endBit / 8);\n\n        var chunk = bitArray.slice(startByte, endByte);\n        var unpackedChunk = BitArray.unpack(chunk);\n\n        chunks.push(unpackedChunk);\n    }\n\n    return chunks;\n}\n\n/**\n * getImageIdOfSourceImageBySourceImageSequence - Returns the Cornerstone imageId of the source image.\n *\n * @param  {Object}   SourceImageSequence  Sequence describing the source image.\n * @param  {String[]} imageIds             A list of imageIds.\n * @param  {Object}   sopUIDImageIdIndexMap A map of SOPInstanceUIDs to imageIds.\n * @return {String}                        The corresponding imageId.\n */\nfunction getImageIdOfSourceImageBySourceImageSequence(\n    SourceImageSequence,\n    sopUIDImageIdIndexMap\n) {\n    const { ReferencedSOPInstanceUID, ReferencedFrameNumber } =\n        SourceImageSequence;\n\n    return ReferencedFrameNumber\n        ? getImageIdOfReferencedFrame(\n              ReferencedSOPInstanceUID,\n              ReferencedFrameNumber,\n              sopUIDImageIdIndexMap\n          )\n        : sopUIDImageIdIndexMap[ReferencedSOPInstanceUID];\n}\n\n/**\n * getImageIdOfSourceImagebyGeometry - Returns the Cornerstone imageId of the source image.\n *\n * @param  {String}    ReferencedSeriesInstanceUID    Referenced series of the source image.\n * @param  {String}    FrameOfReferenceUID            Frame of reference.\n * @param  {Object}    PerFrameFunctionalGroup        Sequence describing segmentation reference attributes per frame.\n * @param  {String[]}  imageIds                       A list of imageIds.\n * @param  {Object}    sopUIDImageIdIndexMap          A map of SOPInstanceUIDs to imageIds.\n * @param  {Float}     tolerance                      The tolerance parameter\n *\n * @return {String}                                   The corresponding imageId.\n */\nfunction getImageIdOfSourceImagebyGeometry(\n    ReferencedSeriesInstanceUID,\n    FrameOfReferenceUID,\n    PerFrameFunctionalGroup,\n    imageIds,\n    metadataProvider,\n    tolerance\n) {\n    if (\n        ReferencedSeriesInstanceUID === undefined ||\n        PerFrameFunctionalGroup.PlanePositionSequence === undefined ||\n        PerFrameFunctionalGroup.PlanePositionSequence[0] === undefined ||\n        PerFrameFunctionalGroup.PlanePositionSequence[0]\n            .ImagePositionPatient === undefined\n    ) {\n        return undefined;\n    }\n\n    for (\n        let imageIdsIndexc = 0;\n        imageIdsIndexc < imageIds.length;\n        ++imageIdsIndexc\n    ) {\n        const sourceImageMetadata = metadataProvider.get(\n            \"instance\",\n            imageIds[imageIdsIndexc]\n        );\n\n        if (\n            sourceImageMetadata === undefined ||\n            sourceImageMetadata.ImagePositionPatient === undefined ||\n            sourceImageMetadata.FrameOfReferenceUID !== FrameOfReferenceUID ||\n            sourceImageMetadata.SeriesInstanceUID !==\n                ReferencedSeriesInstanceUID\n        ) {\n            continue;\n        }\n\n        if (\n            compareArrays(\n                PerFrameFunctionalGroup.PlanePositionSequence[0]\n                    .ImagePositionPatient,\n                sourceImageMetadata.ImagePositionPatient,\n                tolerance\n            )\n        ) {\n            return imageIds[imageIdsIndexc];\n        }\n    }\n}\n\n/**\n * getImageIdOfReferencedFrame - Returns the imageId corresponding to the\n * specified sopInstanceUid and frameNumber for multi-frame images.\n *\n * @param  {String} sopInstanceUid   The sopInstanceUid of the desired image.\n * @param  {Number} frameNumber      The frame number.\n * @param  {String} imageIds         The list of imageIds.\n * @param  {Object} sopUIDImageIdIndexMap A map of SOPInstanceUIDs to imageIds.\n * @return {String}                  The imageId that corresponds to the sopInstanceUid.\n */\nfunction getImageIdOfReferencedFrame(\n    sopInstanceUid,\n    frameNumber,\n    sopUIDImageIdIndexMap\n) {\n    const imageId = sopUIDImageIdIndexMap[sopInstanceUid];\n\n    if (!imageId) {\n        return;\n    }\n\n    const imageIdFrameNumber = Number(imageId.split(\"frame=\")[1]);\n\n    return imageIdFrameNumber === frameNumber - 1 ? imageId : undefined;\n}\n\n/**\n * getValidOrientations - returns an array of valid orientations.\n *\n * @param  {Number[6]} iop The row (0..2) an column (3..5) direction cosines.\n * @return {Number[8][6]} An array of valid orientations.\n */\nfunction getValidOrientations(iop) {\n    const orientations = [];\n\n    // [0,  1,  2]: 0,   0hf,   0vf\n    // [3,  4,  5]: 90,  90hf,  90vf\n    // [6, 7]:      180, 270\n\n    orientations[0] = iop;\n    orientations[1] = flipIOP.h(iop);\n    orientations[2] = flipIOP.v(iop);\n\n    const iop90 = rotateDirectionCosinesInPlane(iop, Math.PI / 2);\n\n    orientations[3] = iop90;\n    orientations[4] = flipIOP.h(iop90);\n    orientations[5] = flipIOP.v(iop90);\n\n    orientations[6] = rotateDirectionCosinesInPlane(iop, Math.PI);\n    orientations[7] = rotateDirectionCosinesInPlane(iop, 1.5 * Math.PI);\n\n    return orientations;\n}\n\n/**\n * alignPixelDataWithSourceData -\n *\n * @param {Ndarray} pixelData2D - The data to align.\n * @param {Number[6]} iop - The orientation of the image slice.\n * @param {Number[8][6]} orientations - An array of valid imageOrientationPatient values.\n * @param {Number} tolerance.\n * @return {Ndarray} The aligned pixelData.\n */\nfunction alignPixelDataWithSourceData(\n    pixelData2D,\n    iop,\n    orientations,\n    tolerance\n) {\n    if (compareArrays(iop, orientations[0], tolerance)) {\n        return pixelData2D;\n    } else if (compareArrays(iop, orientations[1], tolerance)) {\n        // Flipped vertically.\n\n        // Undo Flip\n        return flipMatrix2D.v(pixelData2D);\n    } else if (compareArrays(iop, orientations[2], tolerance)) {\n        // Flipped horizontally.\n\n        // Unfo flip\n        return flipMatrix2D.h(pixelData2D);\n    } else if (compareArrays(iop, orientations[3], tolerance)) {\n        //Rotated 90 degrees\n\n        // Rotate back\n        return rotateMatrix902D(pixelData2D);\n    } else if (compareArrays(iop, orientations[4], tolerance)) {\n        //Rotated 90 degrees and fliped horizontally.\n\n        // Undo flip and rotate back.\n        return rotateMatrix902D(flipMatrix2D.h(pixelData2D));\n    } else if (compareArrays(iop, orientations[5], tolerance)) {\n        // Rotated 90 degrees and fliped vertically\n\n        // Unfo flip and rotate back.\n        return rotateMatrix902D(flipMatrix2D.v(pixelData2D));\n    } else if (compareArrays(iop, orientations[6], tolerance)) {\n        // Rotated 180 degrees. // TODO -> Do this more effeciently, there is a 1:1 mapping like 90 degree rotation.\n\n        return rotateMatrix902D(rotateMatrix902D(pixelData2D));\n    } else if (compareArrays(iop, orientations[7], tolerance)) {\n        // Rotated 270 degrees\n\n        // Rotate back.\n        return rotateMatrix902D(\n            rotateMatrix902D(rotateMatrix902D(pixelData2D))\n        );\n    }\n}\n\n/**\n * compareArrays - Returns true if array1 and array2 are equal\n * within a tolerance.\n *\n * @param  {Number[]} array1 - An array.\n * @param  {Number[]} array2 - An array.\n * @param {Number} tolerance.\n * @return {Boolean} True if array1 and array2 are equal.\n */\nfunction compareArrays(array1, array2, tolerance) {\n    if (array1.length != array2.length) {\n        return false;\n    }\n\n    for (let i = 0; i < array1.length; ++i) {\n        if (!nearlyEqual(array1[i], array2[i], tolerance)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nfunction getSegmentMetadata(multiframe, seriesInstanceUid) {\n    const segmentSequence = multiframe.SegmentSequence;\n    let data = [];\n\n    if (Array.isArray(segmentSequence)) {\n        data = [undefined, ...segmentSequence];\n    } else {\n        // Only one segment, will be stored as an object.\n        data = [undefined, segmentSequence];\n    }\n\n    return {\n        seriesInstanceUid,\n        data\n    };\n}\n\n/**\n * Reads a range of bytes from an array of ArrayBuffer chunks and\n * aggregate them into a new Uint8Array.\n *\n * @param {ArrayBuffer[]} chunks - An array of ArrayBuffer chunks.\n * @param {number} offset - The offset of the first byte to read.\n * @param {number} length - The number of bytes to read.\n * @returns {Uint8Array} A new Uint8Array containing the requested bytes.\n */\nfunction readFromUnpackedChunks(chunks, offset, length) {\n    const mapping = getUnpackedOffsetAndLength(chunks, offset, length);\n\n    // If all the data is in one chunk, we can just slice that chunk\n    if (mapping.start.chunkIndex === mapping.end.chunkIndex) {\n        return new Uint8Array(\n            chunks[mapping.start.chunkIndex].buffer,\n            mapping.start.offset,\n            length\n        );\n    } else {\n        // If the data spans multiple chunks, we need to create a new Uint8Array and copy the data from each chunk\n        let result = new Uint8Array(length);\n        let resultOffset = 0;\n\n        for (\n            let i = mapping.start.chunkIndex;\n            i <= mapping.end.chunkIndex;\n            i++\n        ) {\n            let start =\n                i === mapping.start.chunkIndex ? mapping.start.offset : 0;\n            let end =\n                i === mapping.end.chunkIndex\n                    ? mapping.end.offset\n                    : chunks[i].length;\n\n            result.set(\n                new Uint8Array(chunks[i].buffer, start, end - start),\n                resultOffset\n            );\n            resultOffset += end - start;\n        }\n\n        return result;\n    }\n}\n\nfunction getUnpackedOffsetAndLength(chunks, offset, length) {\n    var totalBytes = chunks.reduce((total, chunk) => total + chunk.length, 0);\n\n    if (offset < 0 || offset + length > totalBytes) {\n        throw new Error(\"Offset and length out of bounds\");\n    }\n\n    var startChunkIndex = 0;\n    var startOffsetInChunk = offset;\n\n    while (startOffsetInChunk >= chunks[startChunkIndex].length) {\n        startOffsetInChunk -= chunks[startChunkIndex].length;\n        startChunkIndex++;\n    }\n\n    var endChunkIndex = startChunkIndex;\n    var endOffsetInChunk = startOffsetInChunk + length;\n\n    while (endOffsetInChunk > chunks[endChunkIndex].length) {\n        endOffsetInChunk -= chunks[endChunkIndex].length;\n        endChunkIndex++;\n    }\n\n    return {\n        start: { chunkIndex: startChunkIndex, offset: startOffsetInChunk },\n        end: { chunkIndex: endChunkIndex, offset: endOffsetInChunk }\n    };\n}\n\nfunction calculateCentroid(imageIdIndexBufferIndex, multiframe) {\n    let xAcc = 0;\n    let yAcc = 0;\n    let zAcc = 0;\n    let count = 0;\n\n    for (const [imageIdIndex, bufferIndices] of Object.entries(\n        imageIdIndexBufferIndex\n    )) {\n        const z = Number(imageIdIndex);\n\n        if (!bufferIndices || bufferIndices.length === 0) {\n            continue;\n        }\n\n        for (const bufferIndex of bufferIndices) {\n            const y = Math.floor(bufferIndex / multiframe.Rows);\n            const x = bufferIndex % multiframe.Rows;\n\n            xAcc += x;\n            yAcc += y;\n            zAcc += z;\n\n            count++;\n        }\n    }\n\n    return { xAcc, yAcc, zAcc, count };\n}\n\nconst Segmentation = {\n    generateSegmentation,\n    generateToolState,\n    fillSegmentation\n};\n\nexport default Segmentation;\nexport { fillSegmentation, generateSegmentation, generateToolState };\n","import Segmentation_3X from \"./Segmentation_3X\";\nimport Segmentation_4X from \"./Segmentation_4X\";\n\nconst Segmentation = {\n    generateSegmentation,\n    generateToolState,\n    fillSegmentation\n};\n\nexport default Segmentation;\n\n/**\n * generateSegmentation - Generates a DICOM Segmentation object given cornerstoneTools data.\n *\n * @param  {object[]} images    An array of the cornerstone image objects.\n * @param  {Object|Object[]} labelmaps3DorBrushData For 4.X: The cornerstone `Labelmap3D` object, or an array of objects.\n *                                                  For 3.X: the BrushData.\n * @param  {number} cornerstoneToolsVersion The cornerstoneTools major version to map against.\n * @returns {Object}\n */\nfunction generateSegmentation(\n    images,\n    labelmaps3DorBrushData,\n    options = { includeSliceSpacing: true },\n    cornerstoneToolsVersion = 4\n) {\n    if (cornerstoneToolsVersion === 4) {\n        return Segmentation_4X.generateSegmentation(\n            images,\n            labelmaps3DorBrushData,\n            options\n        );\n    }\n\n    if (cornerstoneToolsVersion === 3) {\n        return Segmentation_3X.generateSegmentation(\n            images,\n            labelmaps3DorBrushData,\n            options\n        );\n    }\n\n    console.warn(\n        `No generateSegmentation adapater for cornerstone version ${cornerstoneToolsVersion}, exiting.`\n    );\n}\n\n/**\n * generateToolState - Given a set of cornrstoneTools imageIds and a Segmentation buffer,\n * derive cornerstoneTools toolState and brush metadata.\n *\n * @param  {string[]} imageIds    An array of the imageIds.\n * @param  {ArrayBuffer} arrayBuffer The SEG arrayBuffer.\n * @param {*} metadataProvider\n * @param  {bool} skipOverlapping - skip checks for overlapping segs, default value false.\n * @param  {number} tolerance - default value 1.e-3.\n * @param  {number} cornerstoneToolsVersion - default value 4.\n *\n * @returns {Object}  The toolState and an object from which the\n *                    segment metadata can be derived.\n */\nfunction generateToolState(\n    imageIds,\n    arrayBuffer,\n    metadataProvider,\n    skipOverlapping = false,\n    tolerance = 1e-3,\n    cornerstoneToolsVersion = 4\n) {\n    if (cornerstoneToolsVersion === 4) {\n        return Segmentation_4X.generateToolState(\n            imageIds,\n            arrayBuffer,\n            metadataProvider,\n            skipOverlapping,\n            tolerance\n        );\n    }\n\n    if (cornerstoneToolsVersion === 3) {\n        return Segmentation_3X.generateToolState(\n            imageIds,\n            arrayBuffer,\n            metadataProvider\n        );\n    }\n\n    console.warn(\n        `No generateToolState adapater for cornerstone version ${cornerstoneToolsVersion}, exiting.`\n    );\n}\n\n/**\n * fillSegmentation - Fills a derived segmentation dataset with cornerstoneTools `LabelMap3D` data.\n *\n * @param  {object[]} segmentation An empty segmentation derived dataset.\n * @param  {Object|Object[]} inputLabelmaps3D The cornerstone `Labelmap3D` object, or an array of objects.\n * @param  {Object} userOptions Options object to override default options.\n * @returns {Blob}           description\n */\nfunction fillSegmentation(\n    segmentation,\n    inputLabelmaps3D,\n    options = { includeSliceSpacing: true },\n    cornerstoneToolsVersion = 4\n) {\n    if (cornerstoneToolsVersion === 4) {\n        return Segmentation_4X.fillSegmentation(\n            segmentation,\n            inputLabelmaps3D,\n            options\n        );\n    }\n\n    console.warn(\n        `No generateSegmentation adapater for cornerstone version ${cornerstoneToolsVersion}, exiting.`\n    );\n}\n","import MeasurementReport from \"./MeasurementReport\";\nimport Length from \"./Length\";\nimport FreehandRoi from \"./FreehandRoi\";\nimport Bidirectional from \"./Bidirectional\";\nimport EllipticalRoi from \"./EllipticalRoi\";\nimport CircleRoi from \"./CircleRoi\";\nimport ArrowAnnotate from \"./ArrowAnnotate\";\nimport CobbAngle from \"./CobbAngle\";\nimport Angle from \"./Angle\";\nimport RectangleRoi from \"./RectangleRoi\";\n// Segmentation\nimport Segmentation from \"./Segmentation\";\n\nconst CornerstoneSR = {\n    Length,\n    FreehandRoi,\n    Bidirectional,\n    EllipticalRoi,\n    CircleRoi,\n    ArrowAnnotate,\n    MeasurementReport,\n    CobbAngle,\n    Angle,\n    RectangleRoi\n};\n\nconst CornerstoneSEG = {\n    Segmentation\n};\n\nexport { CornerstoneSR, CornerstoneSEG };\n","/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise, SuppressedError, Symbol */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\r\n    function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\r\n    var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\r\n    var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\r\n    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\r\n    var _, done = false;\r\n    for (var i = decorators.length - 1; i >= 0; i--) {\r\n        var context = {};\r\n        for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\r\n        for (var p in contextIn.access) context.access[p] = contextIn.access[p];\r\n        context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\r\n        var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\r\n        if (kind === \"accessor\") {\r\n            if (result === void 0) continue;\r\n            if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\r\n            if (_ = accept(result.get)) descriptor.get = _;\r\n            if (_ = accept(result.set)) descriptor.set = _;\r\n            if (_ = accept(result.init)) initializers.unshift(_);\r\n        }\r\n        else if (_ = accept(result)) {\r\n            if (kind === \"field\") initializers.unshift(_);\r\n            else descriptor[key] = _;\r\n        }\r\n    }\r\n    if (target) Object.defineProperty(target, contextIn.name, descriptor);\r\n    done = true;\r\n};\r\n\r\nexport function __runInitializers(thisArg, initializers, value) {\r\n    var useValue = arguments.length > 2;\r\n    for (var i = 0; i < initializers.length; i++) {\r\n        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\r\n    }\r\n    return useValue ? value : void 0;\r\n};\r\n\r\nexport function __propKey(x) {\r\n    return typeof x === \"symbol\" ? x : \"\".concat(x);\r\n};\r\n\r\nexport function __setFunctionName(f, name, prefix) {\r\n    if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\r\n    return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\r\n};\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n        desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\nexport function __classPrivateFieldIn(state, receiver) {\r\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n}\r\n\r\nexport function __addDisposableResource(env, value, async) {\r\n    if (value !== null && value !== void 0) {\r\n        if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\r\n        var dispose;\r\n        if (async) {\r\n            if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\r\n            dispose = value[Symbol.asyncDispose];\r\n        }\r\n        if (dispose === void 0) {\r\n            if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\r\n            dispose = value[Symbol.dispose];\r\n        }\r\n        if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\r\n        env.stack.push({ value: value, dispose: dispose, async: async });\r\n    }\r\n    else if (async) {\r\n        env.stack.push({ async: true });\r\n    }\r\n    return value;\r\n}\r\n\r\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\r\n\r\nexport function __disposeResources(env) {\r\n    function fail(e) {\r\n        env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\r\n        env.hasError = true;\r\n    }\r\n    function next() {\r\n        while (env.stack.length) {\r\n            var rec = env.stack.pop();\r\n            try {\r\n                var result = rec.dispose && rec.dispose.call(rec.value);\r\n                if (rec.async) return Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\r\n            }\r\n            catch (e) {\r\n                fail(e);\r\n            }\r\n        }\r\n        if (env.hasError) throw env.error;\r\n    }\r\n    return next();\r\n}\r\n\r\nexport default {\r\n    __extends: __extends,\r\n    __assign: __assign,\r\n    __rest: __rest,\r\n    __decorate: __decorate,\r\n    __param: __param,\r\n    __metadata: __metadata,\r\n    __awaiter: __awaiter,\r\n    __generator: __generator,\r\n    __createBinding: __createBinding,\r\n    __exportStar: __exportStar,\r\n    __values: __values,\r\n    __read: __read,\r\n    __spread: __spread,\r\n    __spreadArrays: __spreadArrays,\r\n    __spreadArray: __spreadArray,\r\n    __await: __await,\r\n    __asyncGenerator: __asyncGenerator,\r\n    __asyncDelegator: __asyncDelegator,\r\n    __asyncValues: __asyncValues,\r\n    __makeTemplateObject: __makeTemplateObject,\r\n    __importStar: __importStar,\r\n    __importDefault: __importDefault,\r\n    __classPrivateFieldGet: __classPrivateFieldGet,\r\n    __classPrivateFieldSet: __classPrivateFieldSet,\r\n    __classPrivateFieldIn: __classPrivateFieldIn,\r\n    __addDisposableResource: __addDisposableResource,\r\n    __disposeResources: __disposeResources,\r\n};\r\n","export default \"Cornerstone3DTools@^0.1.0\";\n","// This is a custom coding scheme defined to store some annotations from Cornerstone.\n// Note: CodeMeaning is VR type LO, which means we only actually support 64 characters\n// here this is fine for most labels, but may be problematic at some point.\nconst CORNERSTONEFREETEXT = \"CORNERSTONEFREETEXT\";\n\n// Cornerstone specified coding scheme for storing findings\nconst CodingSchemeDesignator = \"CORNERSTONEJS\";\n\nconst CodingScheme = {\n    CodingSchemeDesignator,\n    codeValues: {\n        CORNERSTONEFREETEXT\n    }\n};\n\nexport default CodingScheme;\n","import { normalizers, data, utilities, derivations } from \"dcmjs\";\n\nimport CORNERSTONE_3D_TAG from \"./cornerstone3DTag\";\nimport { toArray, codeMeaningEquals } from \"../helpers\";\nimport Cornerstone3DCodingScheme from \"./CodingScheme\";\n\nconst { TID1500, addAccessors } = utilities;\n\nconst { StructuredReport } = derivations;\n\nconst { Normalizer } = normalizers;\n\nconst { TID1500MeasurementReport, TID1501MeasurementGroup } = TID1500;\n\nconst { DicomMetaDictionary } = data;\n\nconst FINDING = { CodingSchemeDesignator: \"DCM\", CodeValue: \"121071\" };\nconst FINDING_SITE = { CodingSchemeDesignator: \"SCT\", CodeValue: \"363698007\" };\nconst FINDING_SITE_OLD = { CodingSchemeDesignator: \"SRT\", CodeValue: \"G-C0E3\" };\n\nconst codeValueMatch = (group, code, oldCode?) => {\n    const { ConceptNameCodeSequence } = group;\n    if (!ConceptNameCodeSequence) return;\n    const { CodingSchemeDesignator, CodeValue } = ConceptNameCodeSequence;\n    return (\n        (CodingSchemeDesignator == code.CodingSchemeDesignator &&\n            CodeValue == code.CodeValue) ||\n        (oldCode &&\n            CodingSchemeDesignator == oldCode.CodingSchemeDesignator &&\n            CodeValue == oldCode.CodeValue)\n    );\n};\n\nfunction getTID300ContentItem(\n    tool,\n    toolType,\n    ReferencedSOPSequence,\n    toolClass,\n    worldToImageCoords\n) {\n    const args = toolClass.getTID300RepresentationArguments(\n        tool,\n        worldToImageCoords\n    );\n    args.ReferencedSOPSequence = ReferencedSOPSequence;\n\n    const TID300Measurement = new toolClass.TID300Representation(args);\n\n    return TID300Measurement;\n}\n\nfunction getMeasurementGroup(\n    toolType,\n    toolData,\n    ReferencedSOPSequence,\n    worldToImageCoords\n) {\n    const toolTypeData = toolData[toolType];\n    const toolClass =\n        MeasurementReport.CORNERSTONE_TOOL_CLASSES_BY_TOOL_TYPE[toolType];\n    if (\n        !toolTypeData ||\n        !toolTypeData.data ||\n        !toolTypeData.data.length ||\n        !toolClass\n    ) {\n        return;\n    }\n\n    // Loop through the array of tool instances\n    // for this tool\n    const Measurements = toolTypeData.data.map(tool => {\n        return getTID300ContentItem(\n            tool,\n            toolType,\n            ReferencedSOPSequence,\n            toolClass,\n            worldToImageCoords\n        );\n    });\n\n    return new TID1501MeasurementGroup(Measurements);\n}\n\nexport default class MeasurementReport {\n    public static CORNERSTONE_3D_TAG = CORNERSTONE_3D_TAG;\n    public static MEASUREMENT_BY_TOOLTYPE = {};\n    public static CORNERSTONE_TOOL_CLASSES_BY_UTILITY_TYPE = {};\n    public static CORNERSTONE_TOOL_CLASSES_BY_TOOL_TYPE = {};\n\n    static getCornerstoneLabelFromDefaultState(defaultState) {\n        const { findingSites = [], finding } = defaultState;\n\n        const cornersoneFreeTextCodingValue =\n            Cornerstone3DCodingScheme.codeValues.CORNERSTONEFREETEXT;\n\n        const freeTextLabel = findingSites.find(\n            fs => fs.CodeValue === cornersoneFreeTextCodingValue\n        );\n\n        if (freeTextLabel) {\n            return freeTextLabel.CodeMeaning;\n        }\n\n        if (finding && finding.CodeValue === cornersoneFreeTextCodingValue) {\n            return finding.CodeMeaning;\n        }\n    }\n\n    static generateDatasetMeta() {\n        // TODO: what is the correct metaheader\n        // http://dicom.nema.org/medical/Dicom/current/output/chtml/part10/chapter_7.html\n        // TODO: move meta creation to happen in derivations.js\n        const fileMetaInformationVersionArray = new Uint8Array(2);\n        fileMetaInformationVersionArray[1] = 1;\n\n        const _meta = {\n            FileMetaInformationVersion: {\n                Value: [fileMetaInformationVersionArray.buffer],\n                vr: \"OB\"\n            },\n            //MediaStorageSOPClassUID\n            //MediaStorageSOPInstanceUID: sopCommonModule.sopInstanceUID,\n            TransferSyntaxUID: {\n                Value: [\"1.2.840.10008.1.2.1\"],\n                vr: \"UI\"\n            },\n            ImplementationClassUID: {\n                Value: [DicomMetaDictionary.uid()], // TODO: could be git hash or other valid id\n                vr: \"UI\"\n            },\n            ImplementationVersionName: {\n                Value: [\"dcmjs\"],\n                vr: \"SH\"\n            }\n        };\n\n        return _meta;\n    }\n\n    static generateDerivationSourceDataset = instance => {\n        const _vrMap = {\n            PixelData: \"OW\"\n        };\n\n        const _meta = MeasurementReport.generateDatasetMeta();\n\n        const derivationSourceDataset = {\n            ...instance,\n            _meta: _meta,\n            _vrMap: _vrMap\n        };\n\n        return derivationSourceDataset;\n    };\n\n    static getSetupMeasurementData(\n        MeasurementGroup,\n        sopInstanceUIDToImageIdMap,\n        metadata,\n        toolType\n    ) {\n        const { ContentSequence } = MeasurementGroup;\n\n        const contentSequenceArr = toArray(ContentSequence);\n        const findingGroup = contentSequenceArr.find(group =>\n            codeValueMatch(group, FINDING)\n        );\n        const findingSiteGroups =\n            contentSequenceArr.filter(group =>\n                codeValueMatch(group, FINDING_SITE, FINDING_SITE_OLD)\n            ) || [];\n        const NUMGroup = contentSequenceArr.find(\n            group => group.ValueType === \"NUM\"\n        );\n        const SCOORDGroup = toArray(NUMGroup.ContentSequence).find(\n            group => group.ValueType === \"SCOORD\"\n        );\n        const { ReferencedSOPSequence } = SCOORDGroup.ContentSequence;\n        const { ReferencedSOPInstanceUID, ReferencedFrameNumber } =\n            ReferencedSOPSequence;\n\n        const referencedImageId =\n            sopInstanceUIDToImageIdMap[ReferencedSOPInstanceUID];\n        const imagePlaneModule = metadata.get(\n            \"imagePlaneModule\",\n            referencedImageId\n        );\n\n        const finding = findingGroup\n            ? addAccessors(findingGroup.ConceptCodeSequence)\n            : undefined;\n        const findingSites = findingSiteGroups.map(fsg => {\n            return addAccessors(fsg.ConceptCodeSequence);\n        });\n\n        const defaultState = {\n            description: undefined,\n            sopInstanceUid: ReferencedSOPInstanceUID,\n            annotation: {\n                annotationUID: DicomMetaDictionary.uid(),\n                metadata: {\n                    toolName: toolType,\n                    referencedImageId,\n                    FrameOfReferenceUID: imagePlaneModule.frameOfReferenceUID,\n                    label: \"\"\n                },\n                data: undefined\n            },\n            finding,\n            findingSites\n        };\n        if (defaultState.finding) {\n            defaultState.description = defaultState.finding.CodeMeaning;\n        }\n\n        defaultState.annotation.metadata.label =\n            MeasurementReport.getCornerstoneLabelFromDefaultState(defaultState);\n\n        return {\n            defaultState,\n            NUMGroup,\n            SCOORDGroup,\n            ReferencedSOPSequence,\n            ReferencedSOPInstanceUID,\n            ReferencedFrameNumber\n        };\n    }\n\n    static generateReport(\n        toolState,\n        metadataProvider,\n        worldToImageCoords,\n        options\n    ) {\n        // ToolState for array of imageIDs to a Report\n        // Assume Cornerstone metadata provider has access to Study / Series / Sop Instance UID\n        let allMeasurementGroups = [];\n\n        /* Patient ID\n        Warning - Missing attribute or value that would be needed to build DICOMDIR - Patient ID\n        Warning - Missing attribute or value that would be needed to build DICOMDIR - Study Date\n        Warning - Missing attribute or value that would be needed to build DICOMDIR - Study Time\n        Warning - Missing attribute or value that would be needed to build DICOMDIR - Study ID\n        */\n\n        const sopInstanceUIDsToSeriesInstanceUIDMap = {};\n        const derivationSourceDatasets = [];\n\n        const _meta = MeasurementReport.generateDatasetMeta();\n\n        // Loop through each image in the toolData\n        Object.keys(toolState).forEach(imageId => {\n            const sopCommonModule = metadataProvider.get(\n                \"sopCommonModule\",\n                imageId\n            );\n            const instance = metadataProvider.get(\"instance\", imageId);\n\n            const { sopInstanceUID, sopClassUID } = sopCommonModule;\n            const { SeriesInstanceUID: seriesInstanceUID } = instance;\n\n            sopInstanceUIDsToSeriesInstanceUIDMap[sopInstanceUID] =\n                seriesInstanceUID;\n\n            if (\n                !derivationSourceDatasets.find(\n                    dsd => dsd.SeriesInstanceUID === seriesInstanceUID\n                )\n            ) {\n                // Entry not present for series, create one.\n                const derivationSourceDataset =\n                    MeasurementReport.generateDerivationSourceDataset(instance);\n\n                derivationSourceDatasets.push(derivationSourceDataset);\n            }\n\n            const frameNumber = metadataProvider.get(\"frameNumber\", imageId);\n            const toolData = toolState[imageId];\n            const toolTypes = Object.keys(toolData);\n\n            const ReferencedSOPSequence = {\n                ReferencedSOPClassUID: sopClassUID,\n                ReferencedSOPInstanceUID: sopInstanceUID,\n                ReferencedFrameNumber: undefined\n            };\n\n            if (\n                (instance &&\n                    instance.NumberOfFrames &&\n                    instance.NumberOfFrames > 1) ||\n                Normalizer.isMultiframeSOPClassUID(sopClassUID)\n            ) {\n                ReferencedSOPSequence.ReferencedFrameNumber = frameNumber;\n            }\n\n            // Loop through each tool type for the image\n            const measurementGroups = [];\n\n            toolTypes.forEach(toolType => {\n                const group = getMeasurementGroup(\n                    toolType,\n                    toolData,\n                    ReferencedSOPSequence,\n                    worldToImageCoords\n                );\n                if (group) {\n                    measurementGroups.push(group);\n                }\n            });\n\n            allMeasurementGroups =\n                allMeasurementGroups.concat(measurementGroups);\n        });\n\n        const tid1500MeasurementReport = new TID1500MeasurementReport(\n            { TID1501MeasurementGroups: allMeasurementGroups },\n            options\n        );\n\n        const report = new StructuredReport(derivationSourceDatasets, options);\n\n        const contentItem = tid1500MeasurementReport.contentItem(\n            derivationSourceDatasets,\n            { ...options, sopInstanceUIDsToSeriesInstanceUIDMap }\n        );\n\n        // Merge the derived dataset with the content from the Measurement Report\n        report.dataset = Object.assign(report.dataset, contentItem);\n        report.dataset._meta = _meta;\n\n        return report;\n    }\n\n    /**\n     * Generate Cornerstone tool state from dataset\n     */\n    static generateToolState(\n        dataset,\n        sopInstanceUIDToImageIdMap,\n        imageToWorldCoords,\n        metadata,\n        hooks\n    ) {\n        // For now, bail out if the dataset is not a TID1500 SR with length measurements\n        if (dataset.ContentTemplateSequence.TemplateIdentifier !== \"1500\") {\n            throw new Error(\n                \"This package can currently only interpret DICOM SR TID 1500\"\n            );\n        }\n\n        const REPORT = \"Imaging Measurements\";\n        const GROUP = \"Measurement Group\";\n        const TRACKING_IDENTIFIER = \"Tracking Identifier\";\n        const TRACKING_UNIQUE_IDENTIFIER = \"Tracking Unique Identifier\";\n\n        // Identify the Imaging Measurements\n        const imagingMeasurementContent = toArray(dataset.ContentSequence).find(\n            codeMeaningEquals(REPORT)\n        );\n\n        // Retrieve the Measurements themselves\n        const measurementGroups = toArray(\n            imagingMeasurementContent.ContentSequence\n        ).filter(codeMeaningEquals(GROUP));\n\n        // For each of the supported measurement types, compute the measurement data\n        const measurementData = {};\n\n        const cornerstoneToolClasses =\n            MeasurementReport.CORNERSTONE_TOOL_CLASSES_BY_UTILITY_TYPE;\n\n        const registeredToolClasses = [];\n\n        Object.keys(cornerstoneToolClasses).forEach(key => {\n            registeredToolClasses.push(cornerstoneToolClasses[key]);\n            measurementData[key] = [];\n        });\n\n        measurementGroups.forEach(measurementGroup => {\n            try {\n                const measurementGroupContentSequence = toArray(\n                    measurementGroup.ContentSequence\n                );\n\n                const TrackingIdentifierGroup =\n                    measurementGroupContentSequence.find(\n                        contentItem =>\n                            contentItem.ConceptNameCodeSequence.CodeMeaning ===\n                            TRACKING_IDENTIFIER\n                    );\n\n                const TrackingIdentifierValue =\n                    TrackingIdentifierGroup.TextValue;\n\n                const TrackingUniqueIdentifierGroup =\n                    measurementGroupContentSequence.find(\n                        contentItem =>\n                            contentItem.ConceptNameCodeSequence.CodeMeaning ===\n                            TRACKING_UNIQUE_IDENTIFIER\n                    );\n\n                const TrackingUniqueIdentifierValue =\n                    TrackingUniqueIdentifierGroup?.UID;\n\n                const toolClass =\n                    hooks?.getToolClass?.(\n                        measurementGroup,\n                        dataset,\n                        registeredToolClasses\n                    ) ||\n                    registeredToolClasses.find(tc =>\n                        tc.isValidCornerstoneTrackingIdentifier(\n                            TrackingIdentifierValue\n                        )\n                    );\n\n                if (toolClass) {\n                    const measurement = toolClass.getMeasurementData(\n                        measurementGroup,\n                        sopInstanceUIDToImageIdMap,\n                        imageToWorldCoords,\n                        metadata\n                    );\n\n                    measurement.TrackingUniqueIdentifier =\n                        TrackingUniqueIdentifierValue;\n\n                    console.log(`=== ${toolClass.toolType} ===`);\n                    console.log(measurement);\n\n                    measurementData[toolClass.toolType].push(measurement);\n                }\n            } catch (e) {\n                console.warn(\n                    \"Unable to generate tool state for\",\n                    measurementGroup,\n                    e\n                );\n            }\n        });\n\n        // NOTE: There is no way of knowing the cornerstone imageIds as that could be anything.\n        // That is up to the consumer to derive from the SOPInstanceUIDs.\n        return measurementData;\n    }\n\n    /**\n     * Register a new tool type.\n     * @param toolClass to perform I/O to DICOM for this tool\n     */\n    public static registerTool(toolClass) {\n        MeasurementReport.CORNERSTONE_TOOL_CLASSES_BY_UTILITY_TYPE[\n            toolClass.utilityToolType\n        ] = toolClass;\n        MeasurementReport.CORNERSTONE_TOOL_CLASSES_BY_TOOL_TYPE[\n            toolClass.toolType\n        ] = toolClass;\n        MeasurementReport.MEASUREMENT_BY_TOOLTYPE[toolClass.toolType] =\n            toolClass.utilityToolType;\n    }\n}\n","import MeasurementReport from \"./MeasurementReport\";\nimport { utilities } from \"dcmjs\";\nimport CORNERSTONE_3D_TAG from \"./cornerstone3DTag\";\nimport CodingScheme from \"./CodingScheme\";\n\nconst { Point: TID300Point } = utilities.TID300;\n\nconst ARROW_ANNOTATE = \"ArrowAnnotate\";\nconst trackingIdentifierTextValue = `${CORNERSTONE_3D_TAG}:${ARROW_ANNOTATE}`;\n\nconst { codeValues, CodingSchemeDesignator } = CodingScheme;\n\nclass ArrowAnnotate {\n    static getMeasurementData(\n        MeasurementGroup,\n        sopInstanceUIDToImageIdMap,\n        imageToWorldCoords,\n        metadata\n    ) {\n        const { defaultState, SCOORDGroup, ReferencedFrameNumber } =\n            MeasurementReport.getSetupMeasurementData(\n                MeasurementGroup,\n                sopInstanceUIDToImageIdMap,\n                metadata,\n                ArrowAnnotate.toolType\n            );\n\n        const referencedImageId =\n            defaultState.annotation.metadata.referencedImageId;\n\n        const text = defaultState.annotation.metadata.label;\n\n        const { GraphicData } = SCOORDGroup;\n\n        const worldCoords = [];\n        for (let i = 0; i < GraphicData.length; i += 2) {\n            const point = imageToWorldCoords(referencedImageId, [\n                GraphicData[i],\n                GraphicData[i + 1]\n            ]);\n            worldCoords.push(point);\n        }\n\n        // Since the arrowAnnotate measurement is just a point, to generate the tool state\n        // we derive the second point based on the image size relative to the first point.\n        if (worldCoords.length === 1) {\n            const imagePixelModule = metadata.get(\n                \"imagePixelModule\",\n                referencedImageId\n            );\n\n            let xOffset = 10;\n            let yOffset = 10;\n\n            if (imagePixelModule) {\n                const { columns, rows } = imagePixelModule;\n                xOffset = columns / 10;\n                yOffset = rows / 10;\n            }\n\n            const secondPoint = imageToWorldCoords(referencedImageId, [\n                GraphicData[0] + xOffset,\n                GraphicData[1] + yOffset\n            ]);\n\n            worldCoords.push(secondPoint);\n        }\n\n        const state = defaultState;\n\n        state.annotation.data = {\n            text,\n            handles: {\n                arrowFirst: true,\n                points: [worldCoords[0], worldCoords[1]],\n                activeHandleIndex: 0,\n                textBox: {\n                    hasMoved: false\n                }\n            },\n            frameNumber: ReferencedFrameNumber\n        };\n\n        return state;\n    }\n\n    static getTID300RepresentationArguments(tool, worldToImageCoords) {\n        const { data, metadata } = tool;\n        let { finding, findingSites } = tool;\n        const { referencedImageId } = metadata;\n\n        if (!referencedImageId) {\n            throw new Error(\n                \"ArrowAnnotate.getTID300RepresentationArguments: referencedImageId is not defined\"\n            );\n        }\n\n        const { points, arrowFirst } = data.handles;\n\n        let point;\n\n        if (arrowFirst) {\n            point = points[0];\n        } else {\n            point = points[1];\n        }\n\n        const pointImage = worldToImageCoords(referencedImageId, point);\n\n        const TID300RepresentationArguments = {\n            points: [\n                {\n                    x: pointImage[0],\n                    y: pointImage[1]\n                }\n            ],\n            trackingIdentifierTextValue,\n            findingSites: findingSites || []\n        };\n\n        // If freetext finding isn't present, add it from the tool text.\n        if (!finding || finding.CodeValue !== codeValues.CORNERSTONEFREETEXT) {\n            finding = {\n                CodeValue: codeValues.CORNERSTONEFREETEXT,\n                CodingSchemeDesignator,\n                CodeMeaning: data.text\n            };\n        }\n\n        TID300RepresentationArguments.finding = finding;\n\n        return TID300RepresentationArguments;\n    }\n}\n\nArrowAnnotate.toolType = ARROW_ANNOTATE;\nArrowAnnotate.utilityToolType = ARROW_ANNOTATE;\nArrowAnnotate.TID300Representation = TID300Point;\nArrowAnnotate.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n    if (!TrackingIdentifier.includes(\":\")) {\n        return false;\n    }\n\n    const [cornerstone3DTag, toolType] = TrackingIdentifier.split(\":\");\n\n    if (cornerstone3DTag !== CORNERSTONE_3D_TAG) {\n        return false;\n    }\n\n    return toolType === ARROW_ANNOTATE;\n};\n\nMeasurementReport.registerTool(ArrowAnnotate);\n\nexport default ArrowAnnotate;\n","import { utilities } from \"dcmjs\";\nimport CORNERSTONE_3D_TAG from \"./cornerstone3DTag\";\nimport MeasurementReport from \"./MeasurementReport\";\nimport { toArray } from \"../helpers\";\n\nconst { Bidirectional: TID300Bidirectional } = utilities.TID300;\n\nconst BIDIRECTIONAL = \"Bidirectional\";\nconst LONG_AXIS = \"Long Axis\";\nconst SHORT_AXIS = \"Short Axis\";\nconst trackingIdentifierTextValue = `${CORNERSTONE_3D_TAG}:${BIDIRECTIONAL}`;\n\nclass Bidirectional {\n    public static toolType = BIDIRECTIONAL;\n    public static utilityToolType = BIDIRECTIONAL;\n    public static TID300Representation = TID300Bidirectional;\n    public static isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n        if (!TrackingIdentifier.includes(\":\")) {\n            return false;\n        }\n\n        const [cornerstone3DTag, toolType] = TrackingIdentifier.split(\":\");\n\n        if (cornerstone3DTag !== CORNERSTONE_3D_TAG) {\n            return false;\n        }\n\n        return toolType === BIDIRECTIONAL;\n    };\n\n    public static getMeasurementData(\n        MeasurementGroup,\n        sopInstanceUIDToImageIdMap,\n        imageToWorldCoords,\n        metadata\n    ) {\n        const { defaultState, ReferencedFrameNumber } =\n            MeasurementReport.getSetupMeasurementData(\n                MeasurementGroup,\n                sopInstanceUIDToImageIdMap,\n                metadata,\n                Bidirectional.toolType\n            );\n\n        const referencedImageId =\n            defaultState.annotation.metadata.referencedImageId;\n        const { ContentSequence } = MeasurementGroup;\n\n        const longAxisNUMGroup = toArray(ContentSequence).find(\n            group => group.ConceptNameCodeSequence.CodeMeaning === LONG_AXIS\n        );\n\n        const longAxisSCOORDGroup = toArray(\n            longAxisNUMGroup.ContentSequence\n        ).find(group => group.ValueType === \"SCOORD\");\n\n        const shortAxisNUMGroup = toArray(ContentSequence).find(\n            group => group.ConceptNameCodeSequence.CodeMeaning === SHORT_AXIS\n        );\n\n        const shortAxisSCOORDGroup = toArray(\n            shortAxisNUMGroup.ContentSequence\n        ).find(group => group.ValueType === \"SCOORD\");\n\n        const worldCoords = [];\n\n        [longAxisSCOORDGroup, shortAxisSCOORDGroup].forEach(group => {\n            const { GraphicData } = group;\n            for (let i = 0; i < GraphicData.length; i += 2) {\n                const point = imageToWorldCoords(referencedImageId, [\n                    GraphicData[i],\n                    GraphicData[i + 1]\n                ]);\n                worldCoords.push(point);\n            }\n        });\n\n        const state = defaultState;\n\n        state.annotation.data = {\n            handles: {\n                points: [\n                    worldCoords[0],\n                    worldCoords[1],\n                    worldCoords[2],\n                    worldCoords[3]\n                ],\n                activeHandleIndex: 0,\n                textBox: {\n                    hasMoved: false\n                }\n            },\n            cachedStats: {\n                [`imageId:${referencedImageId}`]: {\n                    length: longAxisNUMGroup.MeasuredValueSequence.NumericValue,\n                    width: shortAxisNUMGroup.MeasuredValueSequence.NumericValue\n                }\n            },\n            frameNumber: ReferencedFrameNumber\n        };\n\n        return state;\n    }\n\n    static getTID300RepresentationArguments(tool, worldToImageCoords) {\n        const { data, finding, findingSites, metadata } = tool;\n        const { cachedStats = {}, handles } = data;\n\n        const { referencedImageId } = metadata;\n\n        if (!referencedImageId) {\n            throw new Error(\n                \"Bidirectional.getTID300RepresentationArguments: referencedImageId is not defined\"\n            );\n        }\n\n        const { length, width } =\n            cachedStats[`imageId:${referencedImageId}`] || {};\n        const { points } = handles;\n\n        // Find the length and width point pairs by comparing the distances of the points at 0,1 to points at 2,3\n        const firstPointPairs = [points[0], points[1]];\n        const secondPointPairs = [points[2], points[3]];\n\n        const firstPointPairsDistance = Math.sqrt(\n            Math.pow(firstPointPairs[0][0] - firstPointPairs[1][0], 2) +\n                Math.pow(firstPointPairs[0][1] - firstPointPairs[1][1], 2) +\n                Math.pow(firstPointPairs[0][2] - firstPointPairs[1][2], 2)\n        );\n\n        const secondPointPairsDistance = Math.sqrt(\n            Math.pow(secondPointPairs[0][0] - secondPointPairs[1][0], 2) +\n                Math.pow(secondPointPairs[0][1] - secondPointPairs[1][1], 2) +\n                Math.pow(secondPointPairs[0][2] - secondPointPairs[1][2], 2)\n        );\n\n        let shortAxisPoints;\n        let longAxisPoints;\n        if (firstPointPairsDistance > secondPointPairsDistance) {\n            shortAxisPoints = firstPointPairs;\n            longAxisPoints = secondPointPairs;\n        } else {\n            shortAxisPoints = secondPointPairs;\n            longAxisPoints = firstPointPairs;\n        }\n\n        const longAxisStartImage = worldToImageCoords(\n            referencedImageId,\n            shortAxisPoints[0]\n        );\n        const longAxisEndImage = worldToImageCoords(\n            referencedImageId,\n            shortAxisPoints[1]\n        );\n        const shortAxisStartImage = worldToImageCoords(\n            referencedImageId,\n            longAxisPoints[0]\n        );\n        const shortAxisEndImage = worldToImageCoords(\n            referencedImageId,\n            longAxisPoints[1]\n        );\n\n        return {\n            longAxis: {\n                point1: {\n                    x: longAxisStartImage[0],\n                    y: longAxisStartImage[1]\n                },\n                point2: {\n                    x: longAxisEndImage[0],\n                    y: longAxisEndImage[1]\n                }\n            },\n            shortAxis: {\n                point1: {\n                    x: shortAxisStartImage[0],\n                    y: shortAxisStartImage[1]\n                },\n                point2: {\n                    x: shortAxisEndImage[0],\n                    y: shortAxisEndImage[1]\n                }\n            },\n            longAxisLength: length,\n            shortAxisLength: width,\n            trackingIdentifierTextValue,\n            finding: finding,\n            findingSites: findingSites || []\n        };\n    }\n}\n\nMeasurementReport.registerTool(Bidirectional);\n\nexport default Bidirectional;\n","import { utilities } from \"dcmjs\";\nimport CORNERSTONE_3D_TAG from \"./cornerstone3DTag\";\nimport MeasurementReport from \"./MeasurementReport\";\n\nconst { CobbAngle: TID300CobbAngle } = utilities.TID300;\n\nconst MEASUREMENT_TYPE = \"Angle\";\nconst trackingIdentifierTextValue = `${CORNERSTONE_3D_TAG}:${MEASUREMENT_TYPE}`;\n\nclass Angle {\n    public static toolType = MEASUREMENT_TYPE;\n    public static utilityToolType = MEASUREMENT_TYPE;\n    public static TID300Representation = TID300CobbAngle;\n    public static isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n        if (!TrackingIdentifier.includes(\":\")) {\n            return false;\n        }\n\n        const [cornerstone3DTag, toolType] = TrackingIdentifier.split(\":\");\n\n        if (cornerstone3DTag !== CORNERSTONE_3D_TAG) {\n            return false;\n        }\n\n        return toolType === MEASUREMENT_TYPE;\n    };\n\n    // TODO: this function is required for all Cornerstone Tool Adapters, since it is called by MeasurementReport.\n    public static getMeasurementData(\n        MeasurementGroup,\n        sopInstanceUIDToImageIdMap,\n        imageToWorldCoords,\n        metadata\n    ) {\n        const { defaultState, NUMGroup, SCOORDGroup, ReferencedFrameNumber } =\n            MeasurementReport.getSetupMeasurementData(\n                MeasurementGroup,\n                sopInstanceUIDToImageIdMap,\n                metadata,\n                Angle.toolType\n            );\n\n        const referencedImageId =\n            defaultState.annotation.metadata.referencedImageId;\n\n        const { GraphicData } = SCOORDGroup;\n        const worldCoords = [];\n        for (let i = 0; i < GraphicData.length; i += 2) {\n            const point = imageToWorldCoords(referencedImageId, [\n                GraphicData[i],\n                GraphicData[i + 1]\n            ]);\n            worldCoords.push(point);\n        }\n\n        const state = defaultState;\n\n        state.annotation.data = {\n            handles: {\n                points: [worldCoords[0], worldCoords[1], worldCoords[3]],\n                activeHandleIndex: 0,\n                textBox: {\n                    hasMoved: false\n                }\n            },\n            cachedStats: {\n                [`imageId:${referencedImageId}`]: {\n                    angle: NUMGroup\n                        ? NUMGroup.MeasuredValueSequence.NumericValue\n                        : null\n                }\n            },\n            frameNumber: ReferencedFrameNumber\n        };\n\n        return state;\n    }\n\n    public static getTID300RepresentationArguments(tool, worldToImageCoords) {\n        const { data, finding, findingSites, metadata } = tool;\n        const { cachedStats = {}, handles } = data;\n\n        const { referencedImageId } = metadata;\n\n        if (!referencedImageId) {\n            throw new Error(\n                \"Angle.getTID300RepresentationArguments: referencedImageId is not defined\"\n            );\n        }\n\n        const start1 = worldToImageCoords(referencedImageId, handles.points[0]);\n        const middle = worldToImageCoords(referencedImageId, handles.points[1]);\n\n        const end = worldToImageCoords(referencedImageId, handles.points[2]);\n\n        const point1 = { x: start1[0], y: start1[1] };\n        const point2 = { x: middle[0], y: middle[1] };\n        const point3 = point2;\n        const point4 = { x: end[0], y: end[1] };\n\n        const { angle } = cachedStats[`imageId:${referencedImageId}`] || {};\n\n        // Represented as a cobb angle\n        return {\n            point1,\n            point2,\n            point3,\n            point4,\n            rAngle: angle,\n            trackingIdentifierTextValue,\n            finding,\n            findingSites: findingSites || []\n        };\n    }\n}\n\nMeasurementReport.registerTool(Angle);\n\nexport default Angle;\n","import { utilities } from \"dcmjs\";\nimport CORNERSTONE_3D_TAG from \"./cornerstone3DTag\";\nimport MeasurementReport from \"./MeasurementReport\";\n\nconst { CobbAngle: TID300CobbAngle } = utilities.TID300;\n\nconst MEASUREMENT_TYPE = \"CobbAngle\";\nconst trackingIdentifierTextValue = `${CORNERSTONE_3D_TAG}:${MEASUREMENT_TYPE}`;\n\nclass CobbAngle {\n    public static toolType = MEASUREMENT_TYPE;\n    public static utilityToolType = MEASUREMENT_TYPE;\n    public static TID300Representation = TID300CobbAngle;\n    public static isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n        if (!TrackingIdentifier.includes(\":\")) {\n            return false;\n        }\n\n        const [cornerstone3DTag, toolType] = TrackingIdentifier.split(\":\");\n\n        if (cornerstone3DTag !== CORNERSTONE_3D_TAG) {\n            return false;\n        }\n\n        return toolType === MEASUREMENT_TYPE;\n    };\n\n    // TODO: this function is required for all Cornerstone Tool Adapters, since it is called by MeasurementReport.\n    public static getMeasurementData(\n        MeasurementGroup,\n        sopInstanceUIDToImageIdMap,\n        imageToWorldCoords,\n        metadata\n    ) {\n        const { defaultState, NUMGroup, SCOORDGroup, ReferencedFrameNumber } =\n            MeasurementReport.getSetupMeasurementData(\n                MeasurementGroup,\n                sopInstanceUIDToImageIdMap,\n                metadata,\n                CobbAngle.toolType\n            );\n\n        const referencedImageId =\n            defaultState.annotation.metadata.referencedImageId;\n\n        const { GraphicData } = SCOORDGroup;\n        const worldCoords = [];\n        for (let i = 0; i < GraphicData.length; i += 2) {\n            const point = imageToWorldCoords(referencedImageId, [\n                GraphicData[i],\n                GraphicData[i + 1]\n            ]);\n            worldCoords.push(point);\n        }\n\n        const state = defaultState;\n\n        state.annotation.data = {\n            handles: {\n                points: [\n                    worldCoords[0],\n                    worldCoords[1],\n                    worldCoords[2],\n                    worldCoords[3]\n                ],\n                activeHandleIndex: 0,\n                textBox: {\n                    hasMoved: false\n                }\n            },\n            cachedStats: {\n                [`imageId:${referencedImageId}`]: {\n                    angle: NUMGroup\n                        ? NUMGroup.MeasuredValueSequence.NumericValue\n                        : null\n                }\n            },\n            frameNumber: ReferencedFrameNumber\n        };\n\n        return state;\n    }\n\n    public static getTID300RepresentationArguments(tool, worldToImageCoords) {\n        const { data, finding, findingSites, metadata } = tool;\n        const { cachedStats = {}, handles } = data;\n\n        const { referencedImageId } = metadata;\n\n        if (!referencedImageId) {\n            throw new Error(\n                \"CobbAngle.getTID300RepresentationArguments: referencedImageId is not defined\"\n            );\n        }\n\n        const start1 = worldToImageCoords(referencedImageId, handles.points[0]);\n        const end1 = worldToImageCoords(referencedImageId, handles.points[1]);\n\n        const start2 = worldToImageCoords(referencedImageId, handles.points[2]);\n        const end2 = worldToImageCoords(referencedImageId, handles.points[3]);\n\n        const point1 = { x: start1[0], y: start1[1] };\n        const point2 = { x: end1[0], y: end1[1] };\n        const point3 = { x: start2[0], y: start2[1] };\n        const point4 = { x: end2[0], y: end2[1] };\n\n        const { angle } = cachedStats[`imageId:${referencedImageId}`] || {};\n\n        return {\n            point1,\n            point2,\n            point3,\n            point4,\n            rAngle: angle,\n            trackingIdentifierTextValue,\n            finding,\n            findingSites: findingSites || []\n        };\n    }\n}\n\nMeasurementReport.registerTool(CobbAngle);\n\nexport default CobbAngle;\n","import CORNERSTONE_3D_TAG from \"./cornerstone3DTag\";\n\nexport default function isValidCornerstoneTrackingIdentifier(\n    trackingIdentifier: string\n): boolean {\n    if (!trackingIdentifier.includes(\":\")) {\n        return false;\n    }\n\n    const [cornerstone3DTag, toolType] = trackingIdentifier.split(\":\");\n\n    if (cornerstone3DTag !== CORNERSTONE_3D_TAG) {\n        return false;\n    }\n\n    // The following is needed since the new cornerstone3D has changed\n    // case names such as EllipticalRoi to EllipticalROI\n    return toolType.toLowerCase() === this.toolType.toLowerCase();\n}\n","import { utilities } from \"dcmjs\";\nimport MeasurementReport from \"./MeasurementReport\";\nimport CORNERSTONE_3D_TAG from \"./cornerstone3DTag\";\nimport isValidCornerstoneTrackingIdentifier from \"./isValidCornerstoneTrackingIdentifier\";\n\nconst { Circle: TID300Circle } = utilities.TID300;\n\nconst CIRCLEROI = \"CircleROI\";\n\nclass CircleROI {\n    static trackingIdentifierTextValue = `${CORNERSTONE_3D_TAG}:${CIRCLEROI}`;\n    static toolType = CIRCLEROI;\n    static utilityToolType = CIRCLEROI;\n    static TID300Representation = TID300Circle;\n    static isValidCornerstoneTrackingIdentifier =\n        isValidCornerstoneTrackingIdentifier;\n\n    /** Gets the measurement data for cornerstone, given DICOM SR measurement data. */\n    static getMeasurementData(\n        MeasurementGroup,\n        sopInstanceUIDToImageIdMap,\n        imageToWorldCoords,\n        metadata\n    ) {\n        const { defaultState, NUMGroup, SCOORDGroup, ReferencedFrameNumber } =\n            MeasurementReport.getSetupMeasurementData(\n                MeasurementGroup,\n                sopInstanceUIDToImageIdMap,\n                metadata,\n                CircleROI.toolType\n            );\n\n        const referencedImageId =\n            defaultState.annotation.metadata.referencedImageId;\n\n        const { GraphicData } = SCOORDGroup;\n\n        // GraphicData is ordered as [centerX, centerY, endX, endY]\n        const pointsWorld = [];\n        for (let i = 0; i < GraphicData.length; i += 2) {\n            const worldPos = imageToWorldCoords(referencedImageId, [\n                GraphicData[i],\n                GraphicData[i + 1]\n            ]);\n\n            pointsWorld.push(worldPos);\n        }\n\n        const state = defaultState;\n\n        state.annotation.data = {\n            handles: {\n                points: [...pointsWorld],\n                activeHandleIndex: 0,\n                textBox: {\n                    hasMoved: false\n                }\n            },\n            cachedStats: {\n                [`imageId:${referencedImageId}`]: {\n                    area: NUMGroup\n                        ? NUMGroup.MeasuredValueSequence.NumericValue\n                        : 0,\n                    // Dummy values to be updated by cornerstone\n                    radius: 0,\n                    perimeter: 0\n                }\n            },\n            frameNumber: ReferencedFrameNumber\n        };\n\n        return state;\n    }\n\n    /**\n     * Gets the TID 300 representation of a circle, given the cornerstone representation.\n     *\n     * @param {Object} tool\n     * @returns\n     */\n    static getTID300RepresentationArguments(tool, worldToImageCoords) {\n        const { data, finding, findingSites, metadata } = tool;\n        const { cachedStats = {}, handles } = data;\n\n        const { referencedImageId } = metadata;\n\n        if (!referencedImageId) {\n            throw new Error(\n                \"CircleROI.getTID300RepresentationArguments: referencedImageId is not defined\"\n            );\n        }\n\n        const center = worldToImageCoords(referencedImageId, handles.points[0]);\n        const end = worldToImageCoords(referencedImageId, handles.points[1]);\n\n        const points = [];\n        points.push({ x: center[0], y: center[1] });\n        points.push({ x: end[0], y: end[1] });\n\n        const { area, radius } =\n            cachedStats[`imageId:${referencedImageId}`] || {};\n        const perimeter = 2 * Math.PI * radius;\n\n        return {\n            area,\n            perimeter,\n            radius,\n            points,\n            trackingIdentifierTextValue: this.trackingIdentifierTextValue,\n            finding,\n            findingSites: findingSites || []\n        };\n    }\n}\n\nMeasurementReport.registerTool(CircleROI);\n\nexport default CircleROI;\n","import { vec3 } from \"gl-matrix\";\nimport { utilities } from \"dcmjs\";\nimport CORNERSTONE_3D_TAG from \"./cornerstone3DTag\";\nimport MeasurementReport from \"./MeasurementReport\";\nimport isValidCornerstoneTrackingIdentifier from \"./isValidCornerstoneTrackingIdentifier\";\n\ntype Point3 = [number, number, number];\n\nconst { Ellipse: TID300Ellipse } = utilities.TID300;\n\nconst ELLIPTICALROI = \"EllipticalROI\";\nconst EPSILON = 1e-4;\n\nclass EllipticalROI {\n    static trackingIdentifierTextValue = `${CORNERSTONE_3D_TAG}:${ELLIPTICALROI}`;\n    static toolType = ELLIPTICALROI;\n    static utilityToolType = ELLIPTICALROI;\n    static TID300Representation = TID300Ellipse;\n    static isValidCornerstoneTrackingIdentifier =\n        isValidCornerstoneTrackingIdentifier;\n\n    static getMeasurementData(\n        MeasurementGroup,\n        sopInstanceUIDToImageIdMap,\n        imageToWorldCoords,\n        metadata\n    ) {\n        const { defaultState, NUMGroup, SCOORDGroup, ReferencedFrameNumber } =\n            MeasurementReport.getSetupMeasurementData(\n                MeasurementGroup,\n                sopInstanceUIDToImageIdMap,\n                metadata,\n                EllipticalROI.toolType\n            );\n\n        const referencedImageId =\n            defaultState.annotation.metadata.referencedImageId;\n\n        const { GraphicData } = SCOORDGroup;\n\n        // GraphicData is ordered as [majorAxisStartX, majorAxisStartY, majorAxisEndX, majorAxisEndY, minorAxisStartX, minorAxisStartY, minorAxisEndX, minorAxisEndY]\n        // But Cornerstone3D points are ordered as top, bottom, left, right for the\n        // ellipse so we need to identify if the majorAxis is horizontal or vertical\n        // in the image plane and then choose the correct points to use for the ellipse.\n        const pointsWorld: Point3[] = [];\n        for (let i = 0; i < GraphicData.length; i += 2) {\n            const worldPos = imageToWorldCoords(referencedImageId, [\n                GraphicData[i],\n                GraphicData[i + 1]\n            ]);\n\n            pointsWorld.push(worldPos);\n        }\n\n        const majorAxisStart = vec3.fromValues(...pointsWorld[0]);\n        const majorAxisEnd = vec3.fromValues(...pointsWorld[1]);\n        const minorAxisStart = vec3.fromValues(...pointsWorld[2]);\n        const minorAxisEnd = vec3.fromValues(...pointsWorld[3]);\n\n        const majorAxisVec = vec3.create();\n        vec3.sub(majorAxisVec, majorAxisEnd, majorAxisStart);\n\n        // normalize majorAxisVec to avoid scaling issues\n        vec3.normalize(majorAxisVec, majorAxisVec);\n\n        const minorAxisVec = vec3.create();\n        vec3.sub(minorAxisVec, minorAxisEnd, minorAxisStart);\n        vec3.normalize(minorAxisVec, minorAxisVec);\n\n        const imagePlaneModule = metadata.get(\n            \"imagePlaneModule\",\n            referencedImageId\n        );\n\n        if (!imagePlaneModule) {\n            throw new Error(\"imageId does not have imagePlaneModule metadata\");\n        }\n\n        const { columnCosines } = imagePlaneModule;\n\n        // find which axis is parallel to the columnCosines\n        const columnCosinesVec = vec3.fromValues(\n            columnCosines[0],\n            columnCosines[1],\n            columnCosines[2]\n        );\n        const projectedMajorAxisOnColVec = vec3.dot(\n            columnCosinesVec,\n            majorAxisVec\n        );\n\n        const projectedMinorAxisOnColVec = vec3.dot(\n            columnCosinesVec,\n            minorAxisVec\n        );\n\n        const absoluteOfMajorDotProduct = Math.abs(projectedMajorAxisOnColVec);\n        const absoluteOfMinorDotProduct = Math.abs(projectedMinorAxisOnColVec);\n\n        let ellipsePoints = [];\n        if (Math.abs(absoluteOfMajorDotProduct - 1) < EPSILON) {\n            ellipsePoints = [\n                pointsWorld[0],\n                pointsWorld[1],\n                pointsWorld[2],\n                pointsWorld[3]\n            ];\n        } else if (Math.abs(absoluteOfMinorDotProduct - 1) < EPSILON) {\n            ellipsePoints = [\n                pointsWorld[2],\n                pointsWorld[3],\n                pointsWorld[0],\n                pointsWorld[1]\n            ];\n        } else {\n            console.warn(\"OBLIQUE ELLIPSE NOT YET SUPPORTED\");\n        }\n\n        const state = defaultState;\n\n        state.annotation.data = {\n            handles: {\n                points: [...ellipsePoints],\n                activeHandleIndex: 0,\n                textBox: {\n                    hasMoved: false\n                }\n            },\n            cachedStats: {\n                [`imageId:${referencedImageId}`]: {\n                    area: NUMGroup\n                        ? NUMGroup.MeasuredValueSequence.NumericValue\n                        : 0\n                }\n            },\n            frameNumber: ReferencedFrameNumber\n        };\n\n        return state;\n    }\n\n    static getTID300RepresentationArguments(tool, worldToImageCoords) {\n        const { data, finding, findingSites, metadata } = tool;\n        const { cachedStats = {}, handles } = data;\n        const rotation = data.initialRotation || 0;\n        const { referencedImageId } = metadata;\n\n        if (!referencedImageId) {\n            throw new Error(\n                \"EllipticalROI.getTID300RepresentationArguments: referencedImageId is not defined\"\n            );\n        }\n        let top, bottom, left, right;\n        // this way when it's restored we can assume the initial rotation is 0.\n        if (rotation == 90 || rotation == 270) {\n            bottom = worldToImageCoords(referencedImageId, handles.points[2]);\n            top = worldToImageCoords(referencedImageId, handles.points[3]);\n            left = worldToImageCoords(referencedImageId, handles.points[0]);\n            right = worldToImageCoords(referencedImageId, handles.points[1]);\n        } else {\n            top = worldToImageCoords(referencedImageId, handles.points[0]);\n            bottom = worldToImageCoords(referencedImageId, handles.points[1]);\n            left = worldToImageCoords(referencedImageId, handles.points[2]);\n            right = worldToImageCoords(referencedImageId, handles.points[3]);\n        }\n\n        // find the major axis and minor axis\n        const topBottomLength = Math.abs(top[1] - bottom[1]);\n        const leftRightLength = Math.abs(left[0] - right[0]);\n\n        const points = [];\n        if (topBottomLength > leftRightLength) {\n            // major axis is bottom to top\n            points.push({ x: top[0], y: top[1] });\n            points.push({ x: bottom[0], y: bottom[1] });\n\n            // minor axis is left to right\n            points.push({ x: left[0], y: left[1] });\n            points.push({ x: right[0], y: right[1] });\n        } else {\n            // major axis is left to right\n            points.push({ x: left[0], y: left[1] });\n            points.push({ x: right[0], y: right[1] });\n\n            // minor axis is bottom to top\n            points.push({ x: top[0], y: top[1] });\n            points.push({ x: bottom[0], y: bottom[1] });\n        }\n\n        const { area } = cachedStats[`imageId:${referencedImageId}`] || {};\n\n        return {\n            area,\n            points,\n            trackingIdentifierTextValue: this.trackingIdentifierTextValue,\n            finding,\n            findingSites: findingSites || []\n        };\n    }\n}\n\nMeasurementReport.registerTool(EllipticalROI);\n\nexport default EllipticalROI;\n","import { utilities } from \"dcmjs\";\nimport CORNERSTONE_3D_TAG from \"./cornerstone3DTag\";\nimport MeasurementReport from \"./MeasurementReport\";\n\nconst { Polyline: TID300Polyline } = utilities.TID300;\n\nconst TOOLTYPE = \"RectangleROI\";\nconst trackingIdentifierTextValue = `${CORNERSTONE_3D_TAG}:${TOOLTYPE}`;\n\nclass RectangleROI {\n    public static toolType = TOOLTYPE;\n    public static utilityToolType = TOOLTYPE;\n    public static TID300Representation = TID300Polyline;\n\n    public static isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n        if (!TrackingIdentifier.includes(\":\")) {\n            return false;\n        }\n\n        const [cornerstone3DTag, toolType] = TrackingIdentifier.split(\":\");\n\n        if (cornerstone3DTag !== CORNERSTONE_3D_TAG) {\n            return false;\n        }\n\n        return toolType === TOOLTYPE;\n    };\n\n    public static getMeasurementData(\n        MeasurementGroup,\n        sopInstanceUIDToImageIdMap,\n        imageToWorldCoords,\n        metadata\n    ) {\n        const { defaultState, NUMGroup, SCOORDGroup, ReferencedFrameNumber } =\n            MeasurementReport.getSetupMeasurementData(\n                MeasurementGroup,\n                sopInstanceUIDToImageIdMap,\n                metadata,\n                RectangleROI.toolType\n            );\n\n        const referencedImageId =\n            defaultState.annotation.metadata.referencedImageId;\n\n        const { GraphicData } = SCOORDGroup;\n        const worldCoords = [];\n        for (let i = 0; i < GraphicData.length; i += 2) {\n            const point = imageToWorldCoords(referencedImageId, [\n                GraphicData[i],\n                GraphicData[i + 1]\n            ]);\n            worldCoords.push(point);\n        }\n\n        const state = defaultState;\n\n        state.annotation.data = {\n            handles: {\n                points: [\n                    worldCoords[0],\n                    worldCoords[1],\n                    worldCoords[3],\n                    worldCoords[2]\n                ],\n                activeHandleIndex: 0,\n                textBox: {\n                    hasMoved: false\n                }\n            },\n            cachedStats: {\n                [`imageId:${referencedImageId}`]: {\n                    area: NUMGroup\n                        ? NUMGroup.MeasuredValueSequence.NumericValue\n                        : null\n                }\n            },\n            frameNumber: ReferencedFrameNumber\n        };\n\n        return state;\n    }\n\n    static getTID300RepresentationArguments(tool, worldToImageCoords) {\n        const { data, finding, findingSites, metadata } = tool;\n        const { cachedStats = {}, handles } = data;\n\n        const { referencedImageId } = metadata;\n\n        if (!referencedImageId) {\n            throw new Error(\n                \"CobbAngle.getTID300RepresentationArguments: referencedImageId is not defined\"\n            );\n        }\n\n        const corners = handles.points.map(point =>\n            worldToImageCoords(referencedImageId, point)\n        );\n\n        const { area, perimeter } = cachedStats;\n\n        return {\n            points: [\n                corners[0],\n                corners[1],\n                corners[3],\n                corners[2],\n                corners[0]\n            ],\n            area,\n            perimeter,\n            trackingIdentifierTextValue,\n            finding,\n            findingSites: findingSites || []\n        };\n    }\n}\n\nMeasurementReport.registerTool(RectangleROI);\n\nexport default RectangleROI;\n","import { utilities } from \"dcmjs\";\nimport CORNERSTONE_3D_TAG from \"./cornerstone3DTag\";\nimport MeasurementReport from \"./MeasurementReport\";\n\nconst { Length: TID300Length } = utilities.TID300;\n\nconst LENGTH = \"Length\";\nconst trackingIdentifierTextValue = `${CORNERSTONE_3D_TAG}:${LENGTH}`;\n\nclass Length {\n    // TODO: this function is required for all Cornerstone Tool Adapters, since it is called by MeasurementReport.\n    static getMeasurementData(\n        MeasurementGroup,\n        sopInstanceUIDToImageIdMap,\n        imageToWorldCoords,\n        metadata\n    ) {\n        const { defaultState, NUMGroup, SCOORDGroup, ReferencedFrameNumber } =\n            MeasurementReport.getSetupMeasurementData(\n                MeasurementGroup,\n                sopInstanceUIDToImageIdMap,\n                metadata,\n                Length.toolType\n            );\n\n        const referencedImageId =\n            defaultState.annotation.metadata.referencedImageId;\n\n        const { GraphicData } = SCOORDGroup;\n        const worldCoords = [];\n        for (let i = 0; i < GraphicData.length; i += 2) {\n            const point = imageToWorldCoords(referencedImageId, [\n                GraphicData[i],\n                GraphicData[i + 1]\n            ]);\n            worldCoords.push(point);\n        }\n\n        const state = defaultState;\n\n        state.annotation.data = {\n            handles: {\n                points: [worldCoords[0], worldCoords[1]],\n                activeHandleIndex: 0,\n                textBox: {\n                    hasMoved: false\n                }\n            },\n            cachedStats: {\n                [`imageId:${referencedImageId}`]: {\n                    length: NUMGroup\n                        ? NUMGroup.MeasuredValueSequence.NumericValue\n                        : 0\n                }\n            },\n            frameNumber: ReferencedFrameNumber\n        };\n\n        return state;\n    }\n\n    static getTID300RepresentationArguments(tool, worldToImageCoords) {\n        const { data, finding, findingSites, metadata } = tool;\n        const { cachedStats = {}, handles } = data;\n\n        const { referencedImageId } = metadata;\n\n        if (!referencedImageId) {\n            throw new Error(\n                \"Length.getTID300RepresentationArguments: referencedImageId is not defined\"\n            );\n        }\n\n        const start = worldToImageCoords(referencedImageId, handles.points[0]);\n        const end = worldToImageCoords(referencedImageId, handles.points[1]);\n\n        const point1 = { x: start[0], y: start[1] };\n        const point2 = { x: end[0], y: end[1] };\n\n        const { length: distance } =\n            cachedStats[`imageId:${referencedImageId}`] || {};\n\n        return {\n            point1,\n            point2,\n            distance,\n            trackingIdentifierTextValue,\n            finding,\n            findingSites: findingSites || []\n        };\n    }\n}\n\nLength.toolType = LENGTH;\nLength.utilityToolType = LENGTH;\nLength.TID300Representation = TID300Length;\nLength.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n    if (!TrackingIdentifier.includes(\":\")) {\n        return false;\n    }\n\n    const [cornerstone3DTag, toolType] = TrackingIdentifier.split(\":\");\n\n    if (cornerstone3DTag !== CORNERSTONE_3D_TAG) {\n        return false;\n    }\n\n    return toolType === LENGTH;\n};\n\nMeasurementReport.registerTool(Length);\n\nexport default Length;\n","import MeasurementReport from \"./MeasurementReport\";\nimport { utilities } from \"dcmjs\";\nimport CORNERSTONE_3D_TAG from \"./cornerstone3DTag\";\nimport { vec3 } from \"gl-matrix\";\n\nconst { Polyline: TID300Polyline } = utilities.TID300;\n\nconst PLANARFREEHANDROI = \"PlanarFreehandROI\";\nconst trackingIdentifierTextValue = `${CORNERSTONE_3D_TAG}:${PLANARFREEHANDROI}`;\nconst closedContourThreshold = 1e-5;\n\nclass PlanarFreehandROI {\n    public static toolType = PLANARFREEHANDROI;\n    public static utilityToolType = PLANARFREEHANDROI;\n    public static TID300Representation = TID300Polyline;\n    public static isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n        if (!TrackingIdentifier.includes(\":\")) {\n            return false;\n        }\n\n        const [cornerstone3DTag, toolType] = TrackingIdentifier.split(\":\");\n\n        if (cornerstone3DTag !== CORNERSTONE_3D_TAG) {\n            return false;\n        }\n\n        return toolType === PLANARFREEHANDROI;\n    };\n\n    static getMeasurementData(\n        MeasurementGroup,\n        sopInstanceUIDToImageIdMap,\n        imageToWorldCoords,\n        metadata\n    ) {\n        const { defaultState, SCOORDGroup, ReferencedFrameNumber } =\n            MeasurementReport.getSetupMeasurementData(\n                MeasurementGroup,\n                sopInstanceUIDToImageIdMap,\n                metadata,\n                PlanarFreehandROI.toolType\n            );\n\n        const referencedImageId =\n            defaultState.annotation.metadata.referencedImageId;\n        const { GraphicData } = SCOORDGroup;\n\n        const worldCoords = [];\n\n        for (let i = 0; i < GraphicData.length; i += 2) {\n            const point = imageToWorldCoords(referencedImageId, [\n                GraphicData[i],\n                GraphicData[i + 1]\n            ]);\n\n            worldCoords.push(point);\n        }\n\n        const distanceBetweenFirstAndLastPoint = vec3.distance(\n            worldCoords[worldCoords.length - 1],\n            worldCoords[0]\n        );\n\n        let isOpenContour = true;\n\n        // If the contour is closed, this should have been encoded as exactly the same point, so check for a very small difference.\n        if (distanceBetweenFirstAndLastPoint < closedContourThreshold) {\n            worldCoords.pop(); // Remove the last element which is duplicated.\n\n            isOpenContour = false;\n        }\n\n        const points = [];\n\n        if (isOpenContour) {\n            points.push(worldCoords[0], worldCoords[worldCoords.length - 1]);\n        }\n\n        const state = defaultState;\n\n        state.annotation.data = {\n            polyline: worldCoords,\n            isOpenContour,\n            handles: {\n                points,\n                activeHandleIndex: null,\n                textBox: {\n                    hasMoved: false\n                }\n            },\n            frameNumber: ReferencedFrameNumber\n        };\n\n        return state;\n    }\n\n    static getTID300RepresentationArguments(tool, worldToImageCoords) {\n        const { data, finding, findingSites, metadata } = tool;\n        const { isOpenContour, polyline } = data;\n\n        const { referencedImageId } = metadata;\n\n        if (!referencedImageId) {\n            throw new Error(\n                \"PlanarFreehandROI.getTID300RepresentationArguments: referencedImageId is not defined\"\n            );\n        }\n\n        const points = polyline.map(worldPos =>\n            worldToImageCoords(referencedImageId, worldPos)\n        );\n\n        if (!isOpenContour) {\n            // Need to repeat the first point at the end of to have an explicitly closed contour.\n            const firstPoint = points[0];\n\n            // Explicitly expand to avoid ciruclar references.\n            points.push([firstPoint[0], firstPoint[1]]);\n        }\n\n        const area = 0; // TODO -> The tool doesn't have these stats yet.\n        const perimeter = 0;\n\n        return {\n            points,\n            area,\n            perimeter,\n            trackingIdentifierTextValue,\n            finding,\n            findingSites: findingSites || []\n        };\n    }\n}\n\nMeasurementReport.registerTool(PlanarFreehandROI);\n\nexport default PlanarFreehandROI;\n","import { utilities } from \"dcmjs\";\nimport CORNERSTONE_3D_TAG from \"./cornerstone3DTag\";\nimport MeasurementReport from \"./MeasurementReport\";\n\nconst { Point: TID300Point } = utilities.TID300;\n\nconst PROBE = \"Probe\";\nconst trackingIdentifierTextValue = `${CORNERSTONE_3D_TAG}:${PROBE}`;\n\nclass Probe {\n    static getMeasurementData(\n        MeasurementGroup,\n        sopInstanceUIDToImageIdMap,\n        imageToWorldCoords,\n        metadata\n    ) {\n        const { defaultState, SCOORDGroup, ReferencedFrameNumber } =\n            MeasurementReport.getSetupMeasurementData(\n                MeasurementGroup,\n                sopInstanceUIDToImageIdMap,\n                metadata,\n                Probe.toolType\n            );\n\n        const referencedImageId =\n            defaultState.annotation.metadata.referencedImageId;\n\n        const { GraphicData } = SCOORDGroup;\n\n        const worldCoords = [];\n        for (let i = 0; i < GraphicData.length; i += 2) {\n            const point = imageToWorldCoords(referencedImageId, [\n                GraphicData[i],\n                GraphicData[i + 1]\n            ]);\n            worldCoords.push(point);\n        }\n\n        const state = defaultState;\n\n        state.annotation.data = {\n            handles: {\n                points: worldCoords,\n                activeHandleIndex: null,\n                textBox: {\n                    hasMoved: false\n                }\n            },\n            frameNumber: ReferencedFrameNumber\n        };\n\n        return state;\n    }\n\n    static getTID300RepresentationArguments(tool, worldToImageCoords) {\n        const { data, metadata } = tool;\n        let { finding, findingSites } = tool;\n        const { referencedImageId } = metadata;\n\n        if (!referencedImageId) {\n            throw new Error(\n                \"Probe.getTID300RepresentationArguments: referencedImageId is not defined\"\n            );\n        }\n\n        const { points } = data.handles;\n\n        const pointsImage = points.map(point => {\n            const pointImage = worldToImageCoords(referencedImageId, point);\n            return {\n                x: pointImage[0],\n                y: pointImage[1]\n            };\n        });\n\n        const TID300RepresentationArguments = {\n            points: pointsImage,\n            trackingIdentifierTextValue,\n            findingSites: findingSites || [],\n            finding\n        };\n\n        return TID300RepresentationArguments;\n    }\n}\n\nProbe.toolType = PROBE;\nProbe.utilityToolType = PROBE;\nProbe.TID300Representation = TID300Point;\nProbe.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n    if (!TrackingIdentifier.includes(\":\")) {\n        return false;\n    }\n\n    const [cornerstone3DTag, toolType] = TrackingIdentifier.split(\":\");\n\n    if (cornerstone3DTag !== CORNERSTONE_3D_TAG) {\n        return false;\n    }\n\n    return toolType === PROBE;\n};\n\nMeasurementReport.registerTool(Probe);\n\nexport default Probe;\n","import { normalizers, derivations } from \"dcmjs\";\nimport { fillSegmentation } from \"../../Cornerstone/Segmentation_4X\";\n\nconst { Normalizer } = normalizers;\nconst { Segmentation: SegmentationDerivation } = derivations;\n\n/**\n * generateSegmentation - Generates a DICOM Segmentation object given cornerstoneTools data.\n *\n * @param images - An array of the cornerstone image objects, which includes imageId and metadata\n * @param labelmaps - An array of the 3D Volumes that contain the segmentation data.\n */\nfunction generateSegmentation(images, labelmaps, metadata, options = {}) {\n    const segmentation = _createMultiframeSegmentationFromReferencedImages(\n        images,\n        metadata,\n        options\n    );\n    return fillSegmentation(segmentation, labelmaps, options);\n}\n\n/**\n * _createMultiframeSegmentationFromReferencedImages - description\n *\n * @param images - An array of the cornerstone image objects related to the reference\n * series that the segmentation is derived from. You can use methods such as\n * volume.getCornerstoneImages() to get this array.\n *\n * @param options - the options object for the SegmentationDerivation.\n * @returns The Seg derived dataSet.\n */\nfunction _createMultiframeSegmentationFromReferencedImages(\n    images,\n    metadata,\n    options\n) {\n    const datasets = images.map(image => {\n        // add the sopClassUID to the dataset\n        const instance = metadata.get(\"instance\", image.imageId);\n        return {\n            ...image,\n            ...instance,\n            // Todo: move to dcmjs tag style\n            SOPClassUID: instance.SopClassUID || instance.SOPClassUID,\n            SOPInstanceUID: instance.SopInstanceUID || instance.SOPInstanceUID,\n            PixelData: image.getPixelData(),\n            _vrMap: {\n                PixelData: \"OW\"\n            },\n            _meta: {}\n        };\n    });\n\n    const multiframe = Normalizer.normalizeToDataset(datasets);\n\n    return new SegmentationDerivation([multiframe], options);\n}\n\nexport { generateSegmentation };\n","import { CornerstoneSEG } from \"../../Cornerstone\";\n\nconst { Segmentation } = CornerstoneSEG;\nconst { generateToolState: generateToolStateCornerstoneLegacy } = Segmentation;\n\n/**\n * generateToolState - Given a set of cornerstoneTools imageIds and a Segmentation buffer,\n * derive cornerstoneTools toolState and brush metadata.\n *\n * @param   imageIds - An array of the imageIds.\n * @param   arrayBuffer - The SEG arrayBuffer.\n * @param   skipOverlapping - skip checks for overlapping segs, default value false.\n * @param   tolerance - default value 1.e-3.\n *\n * @returns a list of array buffer for each labelMap\n *  an object from which the segment metadata can be derived\n *  list containing the track of segments per frame\n *  list containing the track of segments per frame for each labelMap                   (available only for the overlapping case).\n */\nfunction generateToolState(\n    imageIds,\n    arrayBuffer,\n    metadataProvider,\n    skipOverlapping = false,\n    tolerance = 1e-3\n) {\n    return generateToolStateCornerstoneLegacy(\n        imageIds,\n        arrayBuffer,\n        metadataProvider,\n        skipOverlapping,\n        tolerance\n    );\n}\n\nexport { generateToolState };\n","var Events;\n(function (Events) {\n    Events[\"CACHE_SIZE_EXCEEDED\"] = \"CACHE_SIZE_EXCEEDED\";\n    Events[\"IMAGE_LOAD_ERROR\"] = \"IMAGE_LOAD_ERROR\";\n    Events[\"CAMERA_MODIFIED\"] = \"CORNERSTONE_CAMERA_MODIFIED\";\n    Events[\"CAMERA_RESET\"] = \"CORNERSTONE_CAMERA_RESET\";\n    Events[\"VOI_MODIFIED\"] = \"CORNERSTONE_VOI_MODIFIED\";\n    Events[\"DISPLAY_AREA_MODIFIED\"] = \"CORNERSTONE_DISPLAY_AREA_MODIFIED\";\n    Events[\"ELEMENT_DISABLED\"] = \"CORNERSTONE_ELEMENT_DISABLED\";\n    Events[\"ELEMENT_ENABLED\"] = \"CORNERSTONE_ELEMENT_ENABLED\";\n    Events[\"IMAGE_RENDERED\"] = \"CORNERSTONE_IMAGE_RENDERED\";\n    Events[\"IMAGE_VOLUME_MODIFIED\"] = \"CORNERSTONE_IMAGE_VOLUME_MODIFIED\";\n    Events[\"IMAGE_VOLUME_LOADING_COMPLETED\"] = \"CORNERSTONE_IMAGE_VOLUME_LOADING_COMPLETED\";\n    Events[\"IMAGE_LOADED\"] = \"CORNERSTONE_IMAGE_LOADED\";\n    Events[\"IMAGE_RETRIEVAL_STAGE\"] = \"CORNERSTONE_IMAGE_RETRIEVAL_STAGE\";\n    Events[\"IMAGE_LOAD_FAILED\"] = \"CORNERSTONE_IMAGE_LOAD_FAILED\";\n    Events[\"VOLUME_VIEWPORT_NEW_VOLUME\"] = \"CORNERSTONE_VOLUME_VIEWPORT_NEW_VOLUME\";\n    Events[\"VOLUME_LOADED\"] = \"CORNERSTONE_VOLUME_LOADED\";\n    Events[\"VOLUME_LOADED_FAILED\"] = \"CORNERSTONE_VOLUME_LOADED_FAILED\";\n    Events[\"IMAGE_CACHE_IMAGE_ADDED\"] = \"CORNERSTONE_IMAGE_CACHE_IMAGE_ADDED\";\n    Events[\"IMAGE_CACHE_IMAGE_REMOVED\"] = \"CORNERSTONE_IMAGE_CACHE_IMAGE_REMOVED\";\n    Events[\"VOLUME_CACHE_VOLUME_ADDED\"] = \"CORNERSTONE_VOLUME_CACHE_VOLUME_ADDED\";\n    Events[\"VOLUME_CACHE_VOLUME_REMOVED\"] = \"CORNERSTONE_VOLUME_CACHE_VOLUME_REMOVED\";\n    Events[\"STACK_NEW_IMAGE\"] = \"CORNERSTONE_STACK_NEW_IMAGE\";\n    Events[\"VOLUME_NEW_IMAGE\"] = \"CORNERSTONE_VOLUME_NEW_IMAGE\";\n    Events[\"PRE_STACK_NEW_IMAGE\"] = \"CORNERSTONE_PRE_STACK_NEW_IMAGE\";\n    Events[\"IMAGE_SPACING_CALIBRATED\"] = \"CORNERSTONE_IMAGE_SPACING_CALIBRATED\";\n    Events[\"STACK_VIEWPORT_NEW_STACK\"] = \"CORNERSTONE_STACK_VIEWPORT_NEW_STACK\";\n    Events[\"STACK_VIEWPORT_SCROLL\"] = \"CORNERSTONE_STACK_VIEWPORT_SCROLL\";\n    Events[\"GEOMETRY_CACHE_GEOMETRY_ADDED\"] = \"CORNERSTONE_GEOMETRY_CACHE_GEOMETRY_ADDED\";\n    Events[\"VOLUME_SCROLL_OUT_OF_BOUNDS\"] = \"CORNERSTONE_VOLUME_SCROLL_OUT_OF_BOUNDS\";\n    Events[\"CLIPPING_PLANES_UPDATED\"] = \"CORNERSTONE_CLIPPING_PLANES_UPDATED\";\n})(Events || (Events = {}));\nexport default Events;\n//# sourceMappingURL=Events.js.map","/**\n * Generates 2D label maps from a 3D label map.\n * @param labelmap3D - The 3D label map object to generate 2D label maps from. It is derived\n * from the volume labelmap.\n * @returns The label map object containing the 2D label maps and segments on label maps.\n */\nfunction generateLabelMaps2DFrom3D(labelmap3D): {\n    scalarData: number[];\n    dimensions: number[];\n    segmentsOnLabelmap: number[];\n    labelmaps2D: {\n        segmentsOnLabelmap: number[];\n        pixelData: number[];\n        rows: number;\n        columns: number;\n    }[];\n} {\n    // 1. we need to generate labelmaps2D from labelmaps3D, a labelmap2D is for each\n    // slice\n    const { scalarData, dimensions } = labelmap3D;\n\n    // scalarData is a flat array of all the pixels in the volume.\n    const labelmaps2D = [];\n    const segmentsOnLabelmap3D = new Set();\n\n    // X-Y are the row and column dimensions, Z is the number of slices.\n    for (let z = 0; z < dimensions[2]; z++) {\n        const pixelData = scalarData.slice(\n            z * dimensions[0] * dimensions[1],\n            (z + 1) * dimensions[0] * dimensions[1]\n        );\n\n        const segmentsOnLabelmap = [];\n\n        for (let i = 0; i < pixelData.length; i++) {\n            const segment = pixelData[i];\n            if (!segmentsOnLabelmap.includes(segment) && segment !== 0) {\n                segmentsOnLabelmap.push(segment);\n            }\n        }\n\n        const labelmap2D = {\n            segmentsOnLabelmap,\n            pixelData,\n            rows: dimensions[1],\n            columns: dimensions[0]\n        };\n\n        if (segmentsOnLabelmap.length === 0) {\n            continue;\n        }\n\n        segmentsOnLabelmap.forEach(segmentIndex => {\n            segmentsOnLabelmap3D.add(segmentIndex);\n        });\n\n        labelmaps2D[dimensions[2] - 1 - z] = labelmap2D;\n    }\n\n    // remove segment 0 from segmentsOnLabelmap3D\n    labelmap3D.segmentsOnLabelmap = Array.from(segmentsOnLabelmap3D);\n\n    labelmap3D.labelmaps2D = labelmaps2D;\n\n    return labelmap3D;\n}\n\nexport { generateLabelMaps2DFrom3D };\n","var SharedArrayBufferModes;\n(function (SharedArrayBufferModes) {\n    SharedArrayBufferModes[\"TRUE\"] = \"true\";\n    SharedArrayBufferModes[\"FALSE\"] = \"false\";\n    SharedArrayBufferModes[\"AUTO\"] = \"auto\";\n})(SharedArrayBufferModes || (SharedArrayBufferModes = {}));\nexport default SharedArrayBufferModes;\n//# sourceMappingURL=SharedArrayBufferModes.js.map","class CornerstoneEventTarget {\n    constructor() {\n        this.listeners = {};\n    }\n    reset() {\n        this.listeners = {};\n    }\n    addEventListenerOnce(type, callback) {\n        const onceWrapper = (event) => {\n            this.removeEventListener(type, onceWrapper);\n            callback.call(this, event);\n        };\n        this.addEventListener(type, onceWrapper);\n    }\n    addEventListener(type, callback) {\n        if (!this.listeners[type]) {\n            this.listeners[type] = [];\n        }\n        if (this.listeners[type].indexOf(callback) !== -1) {\n            return;\n        }\n        this.listeners[type].push(callback);\n    }\n    removeEventListener(type, callback) {\n        if (!this.listeners[type]) {\n            return;\n        }\n        const stack = this.listeners[type];\n        const stackLength = stack.length;\n        for (let i = 0; i < stackLength; i++) {\n            if (stack[i] === callback) {\n                stack.splice(i, 1);\n                return;\n            }\n        }\n    }\n    dispatchEvent(event) {\n        if (!this.listeners[event.type]) {\n            return;\n        }\n        const stack = this.listeners[event.type].slice();\n        const stackLength = stack.length;\n        for (let i = 0; i < stackLength; i++) {\n            try {\n                stack[i].call(this, event);\n            }\n            catch (error) {\n                console.error(`error in event listener of type:  ${event.type}`, error);\n            }\n        }\n        return !event.defaultPrevented;\n    }\n}\nconst eventTarget = new CornerstoneEventTarget();\nexport default eventTarget;\n//# sourceMappingURL=eventTarget.js.map","'use strict';\n\n// do not edit .js files directly - edit src/index.jst\n\n\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n","'use strict';\n\nvar toStr = Object.prototype.toString;\n\nmodule.exports = function isArguments(value) {\n\tvar str = toStr.call(value);\n\tvar isArgs = str === '[object Arguments]';\n\tif (!isArgs) {\n\t\tisArgs = str !== '[object Array]' &&\n\t\t\tvalue !== null &&\n\t\t\ttypeof value === 'object' &&\n\t\t\ttypeof value.length === 'number' &&\n\t\t\tvalue.length >= 0 &&\n\t\t\ttoStr.call(value.callee) === '[object Function]';\n\t}\n\treturn isArgs;\n};\n","'use strict';\n\nvar slice = Array.prototype.slice;\nvar isArgs = require('./isArguments');\n\nvar origKeys = Object.keys;\nvar keysShim = origKeys ? function keys(o) { return origKeys(o); } : require('./implementation');\n\nvar originalKeys = Object.keys;\n\nkeysShim.shim = function shimObjectKeys() {\n\tif (Object.keys) {\n\t\tvar keysWorksWithArguments = (function () {\n\t\t\t// Safari 5.0 bug\n\t\t\tvar args = Object.keys(arguments);\n\t\t\treturn args && args.length === arguments.length;\n\t\t}(1, 2));\n\t\tif (!keysWorksWithArguments) {\n\t\t\tObject.keys = function keys(object) { // eslint-disable-line func-name-matching\n\t\t\t\tif (isArgs(object)) {\n\t\t\t\t\treturn originalKeys(slice.call(object));\n\t\t\t\t}\n\t\t\t\treturn originalKeys(object);\n\t\t\t};\n\t\t}\n\t} else {\n\t\tObject.keys = keysShim;\n\t}\n\treturn Object.keys || keysShim;\n};\n\nmodule.exports = keysShim;\n","'use strict';\n\nvar keysShim;\nif (!Object.keys) {\n\t// modified from https://github.com/es-shims/es5-shim\n\tvar has = Object.prototype.hasOwnProperty;\n\tvar toStr = Object.prototype.toString;\n\tvar isArgs = require('./isArguments'); // eslint-disable-line global-require\n\tvar isEnumerable = Object.prototype.propertyIsEnumerable;\n\tvar hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');\n\tvar hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');\n\tvar dontEnums = [\n\t\t'toString',\n\t\t'toLocaleString',\n\t\t'valueOf',\n\t\t'hasOwnProperty',\n\t\t'isPrototypeOf',\n\t\t'propertyIsEnumerable',\n\t\t'constructor'\n\t];\n\tvar equalsConstructorPrototype = function (o) {\n\t\tvar ctor = o.constructor;\n\t\treturn ctor && ctor.prototype === o;\n\t};\n\tvar excludedKeys = {\n\t\t$applicationCache: true,\n\t\t$console: true,\n\t\t$external: true,\n\t\t$frame: true,\n\t\t$frameElement: true,\n\t\t$frames: true,\n\t\t$innerHeight: true,\n\t\t$innerWidth: true,\n\t\t$onmozfullscreenchange: true,\n\t\t$onmozfullscreenerror: true,\n\t\t$outerHeight: true,\n\t\t$outerWidth: true,\n\t\t$pageXOffset: true,\n\t\t$pageYOffset: true,\n\t\t$parent: true,\n\t\t$scrollLeft: true,\n\t\t$scrollTop: true,\n\t\t$scrollX: true,\n\t\t$scrollY: true,\n\t\t$self: true,\n\t\t$webkitIndexedDB: true,\n\t\t$webkitStorageInfo: true,\n\t\t$window: true\n\t};\n\tvar hasAutomationEqualityBug = (function () {\n\t\t/* global window */\n\t\tif (typeof window === 'undefined') { return false; }\n\t\tfor (var k in window) {\n\t\t\ttry {\n\t\t\t\tif (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tequalsConstructorPrototype(window[k]);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}());\n\tvar equalsConstructorPrototypeIfNotBuggy = function (o) {\n\t\t/* global window */\n\t\tif (typeof window === 'undefined' || !hasAutomationEqualityBug) {\n\t\t\treturn equalsConstructorPrototype(o);\n\t\t}\n\t\ttry {\n\t\t\treturn equalsConstructorPrototype(o);\n\t\t} catch (e) {\n\t\t\treturn false;\n\t\t}\n\t};\n\n\tkeysShim = function keys(object) {\n\t\tvar isObject = object !== null && typeof object === 'object';\n\t\tvar isFunction = toStr.call(object) === '[object Function]';\n\t\tvar isArguments = isArgs(object);\n\t\tvar isString = isObject && toStr.call(object) === '[object String]';\n\t\tvar theKeys = [];\n\n\t\tif (!isObject && !isFunction && !isArguments) {\n\t\t\tthrow new TypeError('Object.keys called on a non-object');\n\t\t}\n\n\t\tvar skipProto = hasProtoEnumBug && isFunction;\n\t\tif (isString && object.length > 0 && !has.call(object, 0)) {\n\t\t\tfor (var i = 0; i < object.length; ++i) {\n\t\t\t\ttheKeys.push(String(i));\n\t\t\t}\n\t\t}\n\n\t\tif (isArguments && object.length > 0) {\n\t\t\tfor (var j = 0; j < object.length; ++j) {\n\t\t\t\ttheKeys.push(String(j));\n\t\t\t}\n\t\t} else {\n\t\t\tfor (var name in object) {\n\t\t\t\tif (!(skipProto && name === 'prototype') && has.call(object, name)) {\n\t\t\t\t\ttheKeys.push(String(name));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (hasDontEnumBug) {\n\t\t\tvar skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);\n\n\t\t\tfor (var k = 0; k < dontEnums.length; ++k) {\n\t\t\t\tif (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {\n\t\t\t\t\ttheKeys.push(dontEnums[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn theKeys;\n\t};\n}\nmodule.exports = keysShim;\n","'use strict';\n\nvar undefined;\n\nvar $SyntaxError = SyntaxError;\nvar $Function = Function;\nvar $TypeError = TypeError;\n\n// eslint-disable-next-line consistent-return\nvar getEvalledConstructor = function (expressionSyntax) {\n\ttry {\n\t\treturn $Function('\"use strict\"; return (' + expressionSyntax + ').constructor;')();\n\t} catch (e) {}\n};\n\nvar $gOPD = Object.getOwnPropertyDescriptor;\nif ($gOPD) {\n\ttry {\n\t\t$gOPD({}, '');\n\t} catch (e) {\n\t\t$gOPD = null; // this is IE 8, which has a broken gOPD\n\t}\n}\n\nvar throwTypeError = function () {\n\tthrow new $TypeError();\n};\nvar ThrowTypeError = $gOPD\n\t? (function () {\n\t\ttry {\n\t\t\t// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties\n\t\t\targuments.callee; // IE 8 does not throw here\n\t\t\treturn throwTypeError;\n\t\t} catch (calleeThrows) {\n\t\t\ttry {\n\t\t\t\t// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')\n\t\t\t\treturn $gOPD(arguments, 'callee').get;\n\t\t\t} catch (gOPDthrows) {\n\t\t\t\treturn throwTypeError;\n\t\t\t}\n\t\t}\n\t}())\n\t: throwTypeError;\n\nvar hasSymbols = require('has-symbols')();\nvar hasProto = require('has-proto')();\n\nvar getProto = Object.getPrototypeOf || (\n\thasProto\n\t\t? function (x) { return x.__proto__; } // eslint-disable-line no-proto\n\t\t: null\n);\n\nvar needsEval = {};\n\nvar TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined : getProto(Uint8Array);\n\nvar INTRINSICS = {\n\t'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,\n\t'%Array%': Array,\n\t'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,\n\t'%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined,\n\t'%AsyncFromSyncIteratorPrototype%': undefined,\n\t'%AsyncFunction%': needsEval,\n\t'%AsyncGenerator%': needsEval,\n\t'%AsyncGeneratorFunction%': needsEval,\n\t'%AsyncIteratorPrototype%': needsEval,\n\t'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,\n\t'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,\n\t'%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined : BigInt64Array,\n\t'%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined : BigUint64Array,\n\t'%Boolean%': Boolean,\n\t'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,\n\t'%Date%': Date,\n\t'%decodeURI%': decodeURI,\n\t'%decodeURIComponent%': decodeURIComponent,\n\t'%encodeURI%': encodeURI,\n\t'%encodeURIComponent%': encodeURIComponent,\n\t'%Error%': Error,\n\t'%eval%': eval, // eslint-disable-line no-eval\n\t'%EvalError%': EvalError,\n\t'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,\n\t'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,\n\t'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,\n\t'%Function%': $Function,\n\t'%GeneratorFunction%': needsEval,\n\t'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,\n\t'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,\n\t'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,\n\t'%isFinite%': isFinite,\n\t'%isNaN%': isNaN,\n\t'%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined,\n\t'%JSON%': typeof JSON === 'object' ? JSON : undefined,\n\t'%Map%': typeof Map === 'undefined' ? undefined : Map,\n\t'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Map()[Symbol.iterator]()),\n\t'%Math%': Math,\n\t'%Number%': Number,\n\t'%Object%': Object,\n\t'%parseFloat%': parseFloat,\n\t'%parseInt%': parseInt,\n\t'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,\n\t'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,\n\t'%RangeError%': RangeError,\n\t'%ReferenceError%': ReferenceError,\n\t'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,\n\t'%RegExp%': RegExp,\n\t'%Set%': typeof Set === 'undefined' ? undefined : Set,\n\t'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Set()[Symbol.iterator]()),\n\t'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,\n\t'%String%': String,\n\t'%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined,\n\t'%Symbol%': hasSymbols ? Symbol : undefined,\n\t'%SyntaxError%': $SyntaxError,\n\t'%ThrowTypeError%': ThrowTypeError,\n\t'%TypedArray%': TypedArray,\n\t'%TypeError%': $TypeError,\n\t'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,\n\t'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,\n\t'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,\n\t'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,\n\t'%URIError%': URIError,\n\t'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,\n\t'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,\n\t'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet\n};\n\nif (getProto) {\n\ttry {\n\t\tnull.error; // eslint-disable-line no-unused-expressions\n\t} catch (e) {\n\t\t// https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229\n\t\tvar errorProto = getProto(getProto(e));\n\t\tINTRINSICS['%Error.prototype%'] = errorProto;\n\t}\n}\n\nvar doEval = function doEval(name) {\n\tvar value;\n\tif (name === '%AsyncFunction%') {\n\t\tvalue = getEvalledConstructor('async function () {}');\n\t} else if (name === '%GeneratorFunction%') {\n\t\tvalue = getEvalledConstructor('function* () {}');\n\t} else if (name === '%AsyncGeneratorFunction%') {\n\t\tvalue = getEvalledConstructor('async function* () {}');\n\t} else if (name === '%AsyncGenerator%') {\n\t\tvar fn = doEval('%AsyncGeneratorFunction%');\n\t\tif (fn) {\n\t\t\tvalue = fn.prototype;\n\t\t}\n\t} else if (name === '%AsyncIteratorPrototype%') {\n\t\tvar gen = doEval('%AsyncGenerator%');\n\t\tif (gen && getProto) {\n\t\t\tvalue = getProto(gen.prototype);\n\t\t}\n\t}\n\n\tINTRINSICS[name] = value;\n\n\treturn value;\n};\n\nvar LEGACY_ALIASES = {\n\t'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],\n\t'%ArrayPrototype%': ['Array', 'prototype'],\n\t'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],\n\t'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],\n\t'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],\n\t'%ArrayProto_values%': ['Array', 'prototype', 'values'],\n\t'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],\n\t'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],\n\t'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],\n\t'%BooleanPrototype%': ['Boolean', 'prototype'],\n\t'%DataViewPrototype%': ['DataView', 'prototype'],\n\t'%DatePrototype%': ['Date', 'prototype'],\n\t'%ErrorPrototype%': ['Error', 'prototype'],\n\t'%EvalErrorPrototype%': ['EvalError', 'prototype'],\n\t'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],\n\t'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],\n\t'%FunctionPrototype%': ['Function', 'prototype'],\n\t'%Generator%': ['GeneratorFunction', 'prototype'],\n\t'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],\n\t'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],\n\t'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],\n\t'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],\n\t'%JSONParse%': ['JSON', 'parse'],\n\t'%JSONStringify%': ['JSON', 'stringify'],\n\t'%MapPrototype%': ['Map', 'prototype'],\n\t'%NumberPrototype%': ['Number', 'prototype'],\n\t'%ObjectPrototype%': ['Object', 'prototype'],\n\t'%ObjProto_toString%': ['Object', 'prototype', 'toString'],\n\t'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],\n\t'%PromisePrototype%': ['Promise', 'prototype'],\n\t'%PromiseProto_then%': ['Promise', 'prototype', 'then'],\n\t'%Promise_all%': ['Promise', 'all'],\n\t'%Promise_reject%': ['Promise', 'reject'],\n\t'%Promise_resolve%': ['Promise', 'resolve'],\n\t'%RangeErrorPrototype%': ['RangeError', 'prototype'],\n\t'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],\n\t'%RegExpPrototype%': ['RegExp', 'prototype'],\n\t'%SetPrototype%': ['Set', 'prototype'],\n\t'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],\n\t'%StringPrototype%': ['String', 'prototype'],\n\t'%SymbolPrototype%': ['Symbol', 'prototype'],\n\t'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],\n\t'%TypedArrayPrototype%': ['TypedArray', 'prototype'],\n\t'%TypeErrorPrototype%': ['TypeError', 'prototype'],\n\t'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],\n\t'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],\n\t'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],\n\t'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],\n\t'%URIErrorPrototype%': ['URIError', 'prototype'],\n\t'%WeakMapPrototype%': ['WeakMap', 'prototype'],\n\t'%WeakSetPrototype%': ['WeakSet', 'prototype']\n};\n\nvar bind = require('function-bind');\nvar hasOwn = require('hasown');\nvar $concat = bind.call(Function.call, Array.prototype.concat);\nvar $spliceApply = bind.call(Function.apply, Array.prototype.splice);\nvar $replace = bind.call(Function.call, String.prototype.replace);\nvar $strSlice = bind.call(Function.call, String.prototype.slice);\nvar $exec = bind.call(Function.call, RegExp.prototype.exec);\n\n/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */\nvar rePropName = /[^%.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|%$))/g;\nvar reEscapeChar = /\\\\(\\\\)?/g; /** Used to match backslashes in property paths. */\nvar stringToPath = function stringToPath(string) {\n\tvar first = $strSlice(string, 0, 1);\n\tvar last = $strSlice(string, -1);\n\tif (first === '%' && last !== '%') {\n\t\tthrow new $SyntaxError('invalid intrinsic syntax, expected closing `%`');\n\t} else if (last === '%' && first !== '%') {\n\t\tthrow new $SyntaxError('invalid intrinsic syntax, expected opening `%`');\n\t}\n\tvar result = [];\n\t$replace(string, rePropName, function (match, number, quote, subString) {\n\t\tresult[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;\n\t});\n\treturn result;\n};\n/* end adaptation */\n\nvar getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {\n\tvar intrinsicName = name;\n\tvar alias;\n\tif (hasOwn(LEGACY_ALIASES, intrinsicName)) {\n\t\talias = LEGACY_ALIASES[intrinsicName];\n\t\tintrinsicName = '%' + alias[0] + '%';\n\t}\n\n\tif (hasOwn(INTRINSICS, intrinsicName)) {\n\t\tvar value = INTRINSICS[intrinsicName];\n\t\tif (value === needsEval) {\n\t\t\tvalue = doEval(intrinsicName);\n\t\t}\n\t\tif (typeof value === 'undefined' && !allowMissing) {\n\t\t\tthrow new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');\n\t\t}\n\n\t\treturn {\n\t\t\talias: alias,\n\t\t\tname: intrinsicName,\n\t\t\tvalue: value\n\t\t};\n\t}\n\n\tthrow new $SyntaxError('intrinsic ' + name + ' does not exist!');\n};\n\nmodule.exports = function GetIntrinsic(name, allowMissing) {\n\tif (typeof name !== 'string' || name.length === 0) {\n\t\tthrow new $TypeError('intrinsic name must be a non-empty string');\n\t}\n\tif (arguments.length > 1 && typeof allowMissing !== 'boolean') {\n\t\tthrow new $TypeError('\"allowMissing\" argument must be a boolean');\n\t}\n\n\tif ($exec(/^%?[^%]*%?$/, name) === null) {\n\t\tthrow new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');\n\t}\n\tvar parts = stringToPath(name);\n\tvar intrinsicBaseName = parts.length > 0 ? parts[0] : '';\n\n\tvar intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);\n\tvar intrinsicRealName = intrinsic.name;\n\tvar value = intrinsic.value;\n\tvar skipFurtherCaching = false;\n\n\tvar alias = intrinsic.alias;\n\tif (alias) {\n\t\tintrinsicBaseName = alias[0];\n\t\t$spliceApply(parts, $concat([0, 1], alias));\n\t}\n\n\tfor (var i = 1, isOwn = true; i < parts.length; i += 1) {\n\t\tvar part = parts[i];\n\t\tvar first = $strSlice(part, 0, 1);\n\t\tvar last = $strSlice(part, -1);\n\t\tif (\n\t\t\t(\n\t\t\t\t(first === '\"' || first === \"'\" || first === '`')\n\t\t\t\t|| (last === '\"' || last === \"'\" || last === '`')\n\t\t\t)\n\t\t\t&& first !== last\n\t\t) {\n\t\t\tthrow new $SyntaxError('property names with quotes must have matching quotes');\n\t\t}\n\t\tif (part === 'constructor' || !isOwn) {\n\t\t\tskipFurtherCaching = true;\n\t\t}\n\n\t\tintrinsicBaseName += '.' + part;\n\t\tintrinsicRealName = '%' + intrinsicBaseName + '%';\n\n\t\tif (hasOwn(INTRINSICS, intrinsicRealName)) {\n\t\t\tvalue = INTRINSICS[intrinsicRealName];\n\t\t} else if (value != null) {\n\t\t\tif (!(part in value)) {\n\t\t\t\tif (!allowMissing) {\n\t\t\t\t\tthrow new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');\n\t\t\t\t}\n\t\t\t\treturn void undefined;\n\t\t\t}\n\t\t\tif ($gOPD && (i + 1) >= parts.length) {\n\t\t\t\tvar desc = $gOPD(value, part);\n\t\t\t\tisOwn = !!desc;\n\n\t\t\t\t// By convention, when a data property is converted to an accessor\n\t\t\t\t// property to emulate a data property that does not suffer from\n\t\t\t\t// the override mistake, that accessor's getter is marked with\n\t\t\t\t// an `originalValue` property. Here, when we detect this, we\n\t\t\t\t// uphold the illusion by pretending to see that original data\n\t\t\t\t// property, i.e., returning the value rather than the getter\n\t\t\t\t// itself.\n\t\t\t\tif (isOwn && 'get' in desc && !('originalValue' in desc.get)) {\n\t\t\t\t\tvalue = desc.get;\n\t\t\t\t} else {\n\t\t\t\t\tvalue = value[part];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tisOwn = hasOwn(value, part);\n\t\t\t\tvalue = value[part];\n\t\t\t}\n\n\t\t\tif (isOwn && !skipFurtherCaching) {\n\t\t\t\tINTRINSICS[intrinsicRealName] = value;\n\t\t\t}\n\t\t}\n\t}\n\treturn value;\n};\n","'use strict';\n\nvar origSymbol = typeof Symbol !== 'undefined' && Symbol;\nvar hasSymbolSham = require('./shams');\n\nmodule.exports = function hasNativeSymbols() {\n\tif (typeof origSymbol !== 'function') { return false; }\n\tif (typeof Symbol !== 'function') { return false; }\n\tif (typeof origSymbol('foo') !== 'symbol') { return false; }\n\tif (typeof Symbol('bar') !== 'symbol') { return false; }\n\n\treturn hasSymbolSham();\n};\n","'use strict';\n\n/* eslint complexity: [2, 18], max-statements: [2, 33] */\nmodule.exports = function hasSymbols() {\n\tif (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }\n\tif (typeof Symbol.iterator === 'symbol') { return true; }\n\n\tvar obj = {};\n\tvar sym = Symbol('test');\n\tvar symObj = Object(sym);\n\tif (typeof sym === 'string') { return false; }\n\n\tif (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }\n\tif (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }\n\n\t// temp disabled per https://github.com/ljharb/object.assign/issues/17\n\t// if (sym instanceof Symbol) { return false; }\n\t// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4\n\t// if (!(symObj instanceof Symbol)) { return false; }\n\n\t// if (typeof Symbol.prototype.toString !== 'function') { return false; }\n\t// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }\n\n\tvar symVal = 42;\n\tobj[sym] = symVal;\n\tfor (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop\n\tif (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }\n\n\tif (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }\n\n\tvar syms = Object.getOwnPropertySymbols(obj);\n\tif (syms.length !== 1 || syms[0] !== sym) { return false; }\n\n\tif (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }\n\n\tif (typeof Object.getOwnPropertyDescriptor === 'function') {\n\t\tvar descriptor = Object.getOwnPropertyDescriptor(obj, sym);\n\t\tif (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }\n\t}\n\n\treturn true;\n};\n","'use strict';\n\nvar test = {\n\tfoo: {}\n};\n\nvar $Object = Object;\n\nmodule.exports = function hasProto() {\n\treturn { __proto__: test }.foo === test.foo && !({ __proto__: null } instanceof $Object);\n};\n","'use strict';\n\n/* eslint no-invalid-this: 1 */\n\nvar ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';\nvar toStr = Object.prototype.toString;\nvar max = Math.max;\nvar funcType = '[object Function]';\n\nvar concatty = function concatty(a, b) {\n    var arr = [];\n\n    for (var i = 0; i < a.length; i += 1) {\n        arr[i] = a[i];\n    }\n    for (var j = 0; j < b.length; j += 1) {\n        arr[j + a.length] = b[j];\n    }\n\n    return arr;\n};\n\nvar slicy = function slicy(arrLike, offset) {\n    var arr = [];\n    for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {\n        arr[j] = arrLike[i];\n    }\n    return arr;\n};\n\nvar joiny = function (arr, joiner) {\n    var str = '';\n    for (var i = 0; i < arr.length; i += 1) {\n        str += arr[i];\n        if (i + 1 < arr.length) {\n            str += joiner;\n        }\n    }\n    return str;\n};\n\nmodule.exports = function bind(that) {\n    var target = this;\n    if (typeof target !== 'function' || toStr.apply(target) !== funcType) {\n        throw new TypeError(ERROR_MESSAGE + target);\n    }\n    var args = slicy(arguments, 1);\n\n    var bound;\n    var binder = function () {\n        if (this instanceof bound) {\n            var result = target.apply(\n                this,\n                concatty(args, arguments)\n            );\n            if (Object(result) === result) {\n                return result;\n            }\n            return this;\n        }\n        return target.apply(\n            that,\n            concatty(args, arguments)\n        );\n\n    };\n\n    var boundLength = max(0, target.length - args.length);\n    var boundArgs = [];\n    for (var i = 0; i < boundLength; i++) {\n        boundArgs[i] = '$' + i;\n    }\n\n    bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);\n\n    if (target.prototype) {\n        var Empty = function Empty() {};\n        Empty.prototype = target.prototype;\n        bound.prototype = new Empty();\n        Empty.prototype = null;\n    }\n\n    return bound;\n};\n","'use strict';\n\nvar implementation = require('./implementation');\n\nmodule.exports = Function.prototype.bind || implementation;\n","'use strict';\n\nvar call = Function.prototype.call;\nvar $hasOwn = Object.prototype.hasOwnProperty;\nvar bind = require('function-bind');\n\n/** @type {(o: {}, p: PropertyKey) => p is keyof o} */\nmodule.exports = bind.call(call, $hasOwn);\n","'use strict';\n\nvar GetIntrinsic = require('get-intrinsic');\n\nvar $defineProperty = GetIntrinsic('%Object.defineProperty%', true);\n\nvar hasPropertyDescriptors = function hasPropertyDescriptors() {\n\tif ($defineProperty) {\n\t\ttry {\n\t\t\t$defineProperty({}, 'a', { value: 1 });\n\t\t\treturn true;\n\t\t} catch (e) {\n\t\t\t// IE 8 has a broken defineProperty\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn false;\n};\n\nhasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {\n\t// node v0.6 has a bug where array lengths can be Set but not Defined\n\tif (!hasPropertyDescriptors()) {\n\t\treturn null;\n\t}\n\ttry {\n\t\treturn $defineProperty([], 'length', { value: 1 }).length !== 1;\n\t} catch (e) {\n\t\t// In Firefox 4-22, defining length on an array throws an exception.\n\t\treturn true;\n\t}\n};\n\nmodule.exports = hasPropertyDescriptors;\n","'use strict';\n\nvar hasPropertyDescriptors = require('has-property-descriptors')();\n\nvar GetIntrinsic = require('get-intrinsic');\n\nvar $defineProperty = hasPropertyDescriptors && GetIntrinsic('%Object.defineProperty%', true);\nif ($defineProperty) {\n\ttry {\n\t\t$defineProperty({}, 'a', { value: 1 });\n\t} catch (e) {\n\t\t// IE 8 has a broken defineProperty\n\t\t$defineProperty = false;\n\t}\n}\n\nvar $SyntaxError = GetIntrinsic('%SyntaxError%');\nvar $TypeError = GetIntrinsic('%TypeError%');\n\nvar gopd = require('gopd');\n\n/** @type {(obj: Record<PropertyKey, unknown>, property: PropertyKey, value: unknown, nonEnumerable?: boolean | null, nonWritable?: boolean | null, nonConfigurable?: boolean | null, loose?: boolean) => void} */\nmodule.exports = function defineDataProperty(\n\tobj,\n\tproperty,\n\tvalue\n) {\n\tif (!obj || (typeof obj !== 'object' && typeof obj !== 'function')) {\n\t\tthrow new $TypeError('`obj` must be an object or a function`');\n\t}\n\tif (typeof property !== 'string' && typeof property !== 'symbol') {\n\t\tthrow new $TypeError('`property` must be a string or a symbol`');\n\t}\n\tif (arguments.length > 3 && typeof arguments[3] !== 'boolean' && arguments[3] !== null) {\n\t\tthrow new $TypeError('`nonEnumerable`, if provided, must be a boolean or null');\n\t}\n\tif (arguments.length > 4 && typeof arguments[4] !== 'boolean' && arguments[4] !== null) {\n\t\tthrow new $TypeError('`nonWritable`, if provided, must be a boolean or null');\n\t}\n\tif (arguments.length > 5 && typeof arguments[5] !== 'boolean' && arguments[5] !== null) {\n\t\tthrow new $TypeError('`nonConfigurable`, if provided, must be a boolean or null');\n\t}\n\tif (arguments.length > 6 && typeof arguments[6] !== 'boolean') {\n\t\tthrow new $TypeError('`loose`, if provided, must be a boolean');\n\t}\n\n\tvar nonEnumerable = arguments.length > 3 ? arguments[3] : null;\n\tvar nonWritable = arguments.length > 4 ? arguments[4] : null;\n\tvar nonConfigurable = arguments.length > 5 ? arguments[5] : null;\n\tvar loose = arguments.length > 6 ? arguments[6] : false;\n\n\t/* @type {false | TypedPropertyDescriptor<unknown>} */\n\tvar desc = !!gopd && gopd(obj, property);\n\n\tif ($defineProperty) {\n\t\t$defineProperty(obj, property, {\n\t\t\tconfigurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,\n\t\t\tenumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,\n\t\t\tvalue: value,\n\t\t\twritable: nonWritable === null && desc ? desc.writable : !nonWritable\n\t\t});\n\t} else if (loose || (!nonEnumerable && !nonWritable && !nonConfigurable)) {\n\t\t// must fall back to [[Set]], and was not explicitly asked to make non-enumerable, non-writable, or non-configurable\n\t\tobj[property] = value; // eslint-disable-line no-param-reassign\n\t} else {\n\t\tthrow new $SyntaxError('This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.');\n\t}\n};\n","'use strict';\n\nvar GetIntrinsic = require('get-intrinsic');\n\nvar $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);\n\nif ($gOPD) {\n\ttry {\n\t\t$gOPD([], 'length');\n\t} catch (e) {\n\t\t// IE 8 has a broken gOPD\n\t\t$gOPD = null;\n\t}\n}\n\nmodule.exports = $gOPD;\n","'use strict';\n\nvar keys = require('object-keys');\nvar hasSymbols = typeof Symbol === 'function' && typeof Symbol('foo') === 'symbol';\n\nvar toStr = Object.prototype.toString;\nvar concat = Array.prototype.concat;\nvar defineDataProperty = require('define-data-property');\n\nvar isFunction = function (fn) {\n\treturn typeof fn === 'function' && toStr.call(fn) === '[object Function]';\n};\n\nvar supportsDescriptors = require('has-property-descriptors')();\n\nvar defineProperty = function (object, name, value, predicate) {\n\tif (name in object) {\n\t\tif (predicate === true) {\n\t\t\tif (object[name] === value) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else if (!isFunction(predicate) || !predicate()) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (supportsDescriptors) {\n\t\tdefineDataProperty(object, name, value, true);\n\t} else {\n\t\tdefineDataProperty(object, name, value);\n\t}\n};\n\nvar defineProperties = function (object, map) {\n\tvar predicates = arguments.length > 2 ? arguments[2] : {};\n\tvar props = keys(map);\n\tif (hasSymbols) {\n\t\tprops = concat.call(props, Object.getOwnPropertySymbols(map));\n\t}\n\tfor (var i = 0; i < props.length; i += 1) {\n\t\tdefineProperty(object, props[i], map[props[i]], predicates[props[i]]);\n\t}\n};\n\ndefineProperties.supportsDescriptors = !!supportsDescriptors;\n\nmodule.exports = defineProperties;\n","/* eslint no-negated-condition: 0, no-new-func: 0 */\n\n'use strict';\n\nif (typeof self !== 'undefined') {\n\tmodule.exports = self;\n} else if (typeof window !== 'undefined') {\n\tmodule.exports = window;\n} else {\n\tmodule.exports = Function('return this')();\n}\n","'use strict';\n\nvar implementation = require('./implementation');\n\nmodule.exports = function getPolyfill() {\n\tif (typeof global !== 'object' || !global || global.Math !== Math || global.Array !== Array) {\n\t\treturn implementation;\n\t}\n\treturn global;\n};\n","'use strict';\n\nvar define = require('define-properties');\nvar getPolyfill = require('./polyfill');\n\nmodule.exports = function shimGlobal() {\n\tvar polyfill = getPolyfill();\n\tif (define.supportsDescriptors) {\n\t\tvar descriptor = Object.getOwnPropertyDescriptor(polyfill, 'globalThis');\n\t\tif (!descriptor || (descriptor.configurable && (descriptor.enumerable || !descriptor.writable || globalThis !== polyfill))) { // eslint-disable-line max-len\n\t\t\tObject.defineProperty(polyfill, 'globalThis', {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: false,\n\t\t\t\tvalue: polyfill,\n\t\t\t\twritable: true\n\t\t\t});\n\t\t}\n\t} else if (typeof globalThis !== 'object' || globalThis !== polyfill) {\n\t\tpolyfill.globalThis = polyfill;\n\t}\n\treturn polyfill;\n};\n","'use strict';\n\nvar defineProperties = require('define-properties');\n\nvar implementation = require('./implementation');\nvar getPolyfill = require('./polyfill');\nvar shim = require('./shim');\n\nvar polyfill = getPolyfill();\n\nvar getGlobal = function () { return polyfill; };\n\ndefineProperties(getGlobal, {\n\tgetPolyfill: getPolyfill,\n\timplementation: implementation,\n\tshim: shim\n});\n\nmodule.exports = getGlobal;\n","import globalThisShim from 'globalthis';\n\nconst vtkGlobal = globalThisShim(); // returns native globalThis if compliant\n\nconst factoryMapping = {\n  vtkObject: () => null\n};\nfunction vtk(obj) {\n  if (obj === null || obj === undefined) {\n    return obj;\n  }\n  if (obj.isA) {\n    return obj;\n  }\n  if (!obj.vtkClass) {\n    if (vtkGlobal.console && vtkGlobal.console.error) {\n      vtkGlobal.console.error('Invalid VTK object');\n    }\n    return null;\n  }\n  const constructor = factoryMapping[obj.vtkClass];\n  if (!constructor) {\n    if (vtkGlobal.console && vtkGlobal.console.error) {\n      vtkGlobal.console.error(`No vtk class found for Object of type ${obj.vtkClass}`);\n    }\n    return null;\n  }\n\n  // Shallow copy object\n  const model = {\n    ...obj\n  };\n\n  // Convert into vtkObject any nested key\n  Object.keys(model).forEach(keyName => {\n    if (model[keyName] && typeof model[keyName] === 'object' && model[keyName].vtkClass) {\n      model[keyName] = vtk(model[keyName]);\n    }\n  });\n\n  // Return the root\n  const newInst = constructor(model);\n  if (newInst && newInst.modified) {\n    newInst.modified();\n  }\n  return newInst;\n}\nfunction register(vtkClassName, constructor) {\n  factoryMapping[vtkClassName] = constructor;\n}\n\n// Nest register method under the vtk function\nvtk.register = register;\n\nexport { vtk as default, vtkGlobal };\n","/* eslint-disable prefer-rest-params */\nclass ClassHierarchy extends Array {\n  push() {\n    for (let i = 0; i < arguments.length; i++) {\n      if (!this.includes(arguments[i])) {\n        super.push(arguments[i]);\n      }\n    }\n    return this.length;\n  }\n}\n\nexport { ClassHierarchy as default };\n","import DeepEqual from 'fast-deep-equal';\nimport vtk, { vtkGlobal } from './vtk.js';\nimport ClassHierarchy from './Common/Core/ClassHierarchy.js';\n\n/**\n * macros.js is the old macro.js.\n * The name change is so we do not get eaten by babel-plugin-macros.\n */\nlet globalMTime = 0;\nconst VOID = Symbol('void');\nfunction getCurrentGlobalMTime() {\n  return globalMTime;\n}\n\n// ----------------------------------------------------------------------------\n// Logging function calls\n// ----------------------------------------------------------------------------\n/* eslint-disable no-prototype-builtins                                      */\n\nconst fakeConsole = {};\nfunction noOp() {}\nconst consoleMethods = ['log', 'debug', 'info', 'warn', 'error', 'time', 'timeEnd', 'group', 'groupEnd'];\nconsoleMethods.forEach(methodName => {\n  fakeConsole[methodName] = noOp;\n});\nvtkGlobal.console = console.hasOwnProperty('log') ? console : fakeConsole;\nconst loggerFunctions = {\n  debug: noOp,\n  // Don't print debug by default\n  error: vtkGlobal.console.error || noOp,\n  info: vtkGlobal.console.info || noOp,\n  log: vtkGlobal.console.log || noOp,\n  warn: vtkGlobal.console.warn || noOp\n};\nfunction setLoggerFunction(name, fn) {\n  if (loggerFunctions[name]) {\n    loggerFunctions[name] = fn || noOp;\n  }\n}\nfunction vtkLogMacro() {\n  loggerFunctions.log(...arguments);\n}\nfunction vtkInfoMacro() {\n  loggerFunctions.info(...arguments);\n}\nfunction vtkDebugMacro() {\n  loggerFunctions.debug(...arguments);\n}\nfunction vtkErrorMacro() {\n  loggerFunctions.error(...arguments);\n}\nfunction vtkWarningMacro() {\n  loggerFunctions.warn(...arguments);\n}\nconst ERROR_ONCE_MAP = {};\nfunction vtkOnceErrorMacro(str) {\n  if (!ERROR_ONCE_MAP[str]) {\n    loggerFunctions.error(str);\n    ERROR_ONCE_MAP[str] = true;\n  }\n}\n\n// ----------------------------------------------------------------------------\n// TypedArray\n// ----------------------------------------------------------------------------\n\nconst TYPED_ARRAYS = Object.create(null);\nTYPED_ARRAYS.Float32Array = Float32Array;\nTYPED_ARRAYS.Float64Array = Float64Array;\nTYPED_ARRAYS.Uint8Array = Uint8Array;\nTYPED_ARRAYS.Int8Array = Int8Array;\nTYPED_ARRAYS.Uint16Array = Uint16Array;\nTYPED_ARRAYS.Int16Array = Int16Array;\nTYPED_ARRAYS.Uint32Array = Uint32Array;\nTYPED_ARRAYS.Int32Array = Int32Array;\nTYPED_ARRAYS.Uint8ClampedArray = Uint8ClampedArray;\ntry {\n  TYPED_ARRAYS.BigInt64Array = BigInt64Array;\n  TYPED_ARRAYS.BigUint64Array = BigUint64Array;\n} catch {\n  // ignore\n}\nfunction newTypedArray(type) {\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n  return new (TYPED_ARRAYS[type] || Float64Array)(...args);\n}\nfunction newTypedArrayFrom(type) {\n  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    args[_key2 - 1] = arguments[_key2];\n  }\n  return (TYPED_ARRAYS[type] || Float64Array).from(...args);\n}\n\n// ----------------------------------------------------------------------------\n// capitilize provided string\n// ----------------------------------------------------------------------------\n\nfunction capitalize(str) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\nfunction _capitalize(str) {\n  return capitalize(str[0] === '_' ? str.slice(1) : str);\n}\nfunction uncapitalize(str) {\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\n\n// ----------------------------------------------------------------------------\n// Convert byte size into a well formatted string\n// ----------------------------------------------------------------------------\n\nfunction formatBytesToProperUnit(size) {\n  let precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n  let chunkSize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1000;\n  const units = ['TB', 'GB', 'MB', 'KB'];\n  let value = Number(size);\n  let currentUnit = 'B';\n  while (value > chunkSize) {\n    value /= chunkSize;\n    currentUnit = units.pop();\n  }\n  return `${value.toFixed(precision)} ${currentUnit}`;\n}\n\n// ----------------------------------------------------------------------------\n// Convert thousand number with proper separator\n// ----------------------------------------------------------------------------\n\nfunction formatNumbersWithThousandSeparator(n) {\n  let separator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ' ';\n  const sections = [];\n  let size = n;\n  while (size > 1000) {\n    sections.push(`000${size % 1000}`.slice(-3));\n    size = Math.floor(size / 1000);\n  }\n  if (size > 0) {\n    sections.push(size);\n  }\n  sections.reverse();\n  return sections.join(separator);\n}\n\n// ----------------------------------------------------------------------------\n// Array helper\n// ----------------------------------------------------------------------------\n\nfunction safeArrays(model) {\n  Object.keys(model).forEach(key => {\n    if (Array.isArray(model[key])) {\n      model[key] = [].concat(model[key]);\n    }\n  });\n}\nfunction isTypedArray(value) {\n  return Object.values(TYPED_ARRAYS).some(ctor => value instanceof ctor);\n}\n\n// ----------------------------------------------------------------------------\n// shallow equals\n// ----------------------------------------------------------------------------\n\nfunction shallowEquals(a, b) {\n  if (a === b) {\n    return true;\n  }\n  if (Array.isArray(a) && Array.isArray(b)) {\n    if (a.length !== b.length) {\n      return false;\n    }\n    for (let i = 0; i < a.length; i++) {\n      if (a[i] !== b[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return false;\n}\n\n// ----------------------------------------------------------------------------\n\nfunction enumToString(e, value) {\n  return Object.keys(e).find(key => e[key] === value);\n}\nfunction getStateArrayMapFunc(item) {\n  if (item && item.isA) {\n    return item.getState();\n  }\n  return item;\n}\n\n// ----------------------------------------------------------------------------\n// setImmediate\n// ----------------------------------------------------------------------------\n\nfunction setImmediateVTK(fn) {\n  setTimeout(fn, 0);\n}\n\n// ----------------------------------------------------------------------------\n// measurePromiseExecution\n//\n// Measures the time it takes for a promise to finish from\n//   the time this function is invoked.\n// The callback receives the time it took for the promise to resolve or reject.\n// ----------------------------------------------------------------------------\n\nfunction measurePromiseExecution(promise, callback) {\n  const start = performance.now();\n  promise.finally(() => {\n    const delta = performance.now() - start;\n    callback(delta);\n  });\n}\n\n// ----------------------------------------------------------------------------\n// vtkObject: modified(), onModified(callback), delete()\n// ----------------------------------------------------------------------------\n\nfunction obj() {\n  let publicAPI = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let model = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  // Ensure each instance as a unique ref of array\n  safeArrays(model);\n  const callbacks = [];\n  if (!Number.isInteger(model.mtime)) {\n    model.mtime = ++globalMTime;\n  }\n  if (!('classHierarchy' in model)) {\n    model.classHierarchy = new ClassHierarchy('vtkObject');\n  } else if (!(model.classHierarchy instanceof ClassHierarchy)) {\n    const hierarchy = new ClassHierarchy();\n    for (let i = 0; i < model.classHierarchy.length; i++) {\n      hierarchy.push(model.classHierarchy[i]);\n    }\n    model.classHierarchy = hierarchy;\n  }\n  function off(index) {\n    callbacks[index] = null;\n  }\n  function on(index) {\n    function unsubscribe() {\n      off(index);\n    }\n    return Object.freeze({\n      unsubscribe\n    });\n  }\n  publicAPI.isDeleted = () => !!model.deleted;\n  publicAPI.modified = otherMTime => {\n    if (model.deleted) {\n      vtkErrorMacro('instance deleted - cannot call any method');\n      return;\n    }\n    if (otherMTime && otherMTime < publicAPI.getMTime()) {\n      return;\n    }\n    model.mtime = ++globalMTime;\n    callbacks.forEach(callback => callback && callback(publicAPI));\n  };\n  publicAPI.onModified = callback => {\n    if (model.deleted) {\n      vtkErrorMacro('instance deleted - cannot call any method');\n      return null;\n    }\n    const index = callbacks.length;\n    callbacks.push(callback);\n    return on(index);\n  };\n  publicAPI.getMTime = () => model.mtime;\n  publicAPI.isA = className => {\n    let count = model.classHierarchy.length;\n    // we go backwards as that is more likely for\n    // early termination\n    while (count--) {\n      if (model.classHierarchy[count] === className) {\n        return true;\n      }\n    }\n    return false;\n  };\n  publicAPI.getClassName = function () {\n    let depth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    return model.classHierarchy[model.classHierarchy.length - 1 - depth];\n  };\n  publicAPI.set = function () {\n    let map = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let noWarning = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let noFunction = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let ret = false;\n    Object.keys(map).forEach(name => {\n      const fn = noFunction ? null : publicAPI[`set${capitalize(name)}`];\n      if (fn && Array.isArray(map[name]) && fn.length > 1) {\n        ret = fn(...map[name]) || ret;\n      } else if (fn) {\n        ret = fn(map[name]) || ret;\n      } else {\n        // Set data on model directly\n        if (['mtime'].indexOf(name) === -1 && !noWarning) {\n          vtkWarningMacro(`Warning: Set value to model directly ${name}, ${map[name]}`);\n        }\n        ret = model[name] !== map[name] || ret;\n        model[name] = map[name];\n      }\n    });\n    return ret;\n  };\n  publicAPI.get = function () {\n    for (var _len3 = arguments.length, list = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      list[_key3] = arguments[_key3];\n    }\n    if (!list.length) {\n      return model;\n    }\n    const subset = {};\n    list.forEach(name => {\n      subset[name] = model[name];\n    });\n    return subset;\n  };\n  publicAPI.getReferenceByName = val => model[val];\n  publicAPI.delete = () => {\n    Object.keys(model).forEach(field => delete model[field]);\n    callbacks.forEach((el, index) => off(index));\n\n    // Flag the instance being deleted\n    model.deleted = true;\n  };\n\n  // Add serialization support\n  publicAPI.getState = () => {\n    if (model.deleted) {\n      return null;\n    }\n    const jsonArchive = {\n      ...model,\n      vtkClass: publicAPI.getClassName()\n    };\n\n    // Convert every vtkObject to its serializable form\n    Object.keys(jsonArchive).forEach(keyName => {\n      if (jsonArchive[keyName] === null || jsonArchive[keyName] === undefined || keyName[0] === '_' // protected members start with _\n      ) {\n        delete jsonArchive[keyName];\n      } else if (jsonArchive[keyName].isA) {\n        jsonArchive[keyName] = jsonArchive[keyName].getState();\n      } else if (Array.isArray(jsonArchive[keyName])) {\n        jsonArchive[keyName] = jsonArchive[keyName].map(getStateArrayMapFunc);\n      } else if (isTypedArray(jsonArchive[keyName])) {\n        jsonArchive[keyName] = Array.from(jsonArchive[keyName]);\n      }\n    });\n\n    // Sort resulting object by key name\n    const sortedObj = {};\n    Object.keys(jsonArchive).sort().forEach(name => {\n      sortedObj[name] = jsonArchive[name];\n    });\n\n    // Remove mtime\n    if (sortedObj.mtime) {\n      delete sortedObj.mtime;\n    }\n    return sortedObj;\n  };\n\n  // Add shallowCopy(otherInstance) support\n  publicAPI.shallowCopy = function (other) {\n    let debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (other.getClassName() !== publicAPI.getClassName()) {\n      throw new Error(`Cannot ShallowCopy ${other.getClassName()} into ${publicAPI.getClassName()}`);\n    }\n    const otherModel = other.get();\n    const keyList = Object.keys(model).sort();\n    const otherKeyList = Object.keys(otherModel).sort();\n    otherKeyList.forEach(key => {\n      const keyIdx = keyList.indexOf(key);\n      if (keyIdx === -1) {\n        if (debug) {\n          vtkDebugMacro(`add ${key} in shallowCopy`);\n        }\n      } else {\n        keyList.splice(keyIdx, 1);\n      }\n      model[key] = otherModel[key];\n    });\n    if (keyList.length && debug) {\n      vtkDebugMacro(`Untouched keys: ${keyList.join(', ')}`);\n    }\n    publicAPI.modified();\n  };\n\n  // This function will get called when one invoke JSON.stringify(vtkObject)\n  // JSON.stringify will only stringify the return value of this function\n  publicAPI.toJSON = function vtkObjToJSON() {\n    return publicAPI.getState();\n  };\n\n  // Allow usage as decorator\n  return publicAPI;\n}\n\n// ----------------------------------------------------------------------------\n// getXXX: add getters\n// ----------------------------------------------------------------------------\n\nconst objectGetterMap = {\n  object(publicAPI, model, field) {\n    return function getter() {\n      return {\n        ...model[field.name]\n      };\n    };\n  }\n};\nfunction get(publicAPI, model, fieldNames) {\n  fieldNames.forEach(field => {\n    if (typeof field === 'object') {\n      const getter = objectGetterMap[field.type];\n      if (getter) {\n        publicAPI[`get${_capitalize(field.name)}`] = getter(publicAPI, model, field);\n      } else {\n        publicAPI[`get${_capitalize(field.name)}`] = () => model[field.name];\n      }\n    } else {\n      publicAPI[`get${_capitalize(field)}`] = () => model[field];\n    }\n  });\n}\n\n// ----------------------------------------------------------------------------\n// setXXX: add setters\n// ----------------------------------------------------------------------------\n\nconst objectSetterMap = {\n  enum(publicAPI, model, field) {\n    const onChanged = `_on${_capitalize(field.name)}Changed`;\n    return value => {\n      if (typeof value === 'string') {\n        if (field.enum[value] !== undefined) {\n          if (model[field.name] !== field.enum[value]) {\n            model[field.name] = field.enum[value];\n            publicAPI.modified();\n            return true;\n          }\n          return false;\n        }\n        vtkErrorMacro(`Set Enum with invalid argument ${field}, ${value}`);\n        throw new RangeError('Set Enum with invalid string argument');\n      }\n      if (typeof value === 'number') {\n        if (model[field.name] !== value) {\n          if (Object.keys(field.enum).map(key => field.enum[key]).indexOf(value) !== -1) {\n            const previousValue = model[field.name];\n            model[field.name] = value;\n            model[onChanged]?.(publicAPI, model, value, previousValue);\n            publicAPI.modified();\n            return true;\n          }\n          vtkErrorMacro(`Set Enum outside numeric range ${field}, ${value}`);\n          throw new RangeError('Set Enum outside numeric range');\n        }\n        return false;\n      }\n      vtkErrorMacro(`Set Enum with invalid argument (String/Number) ${field}, ${value}`);\n      throw new TypeError('Set Enum with invalid argument (String/Number)');\n    };\n  },\n  object(publicAPI, model, field) {\n    const onChanged = `_on${_capitalize(field.name)}Changed`;\n    return value => {\n      if (!DeepEqual(model[field.name], value)) {\n        const previousValue = model[field.name];\n        model[field.name] = value;\n        model[onChanged]?.(publicAPI, model, value, previousValue);\n        publicAPI.modified();\n        return true;\n      }\n      return false;\n    };\n  }\n};\nfunction findSetter(field) {\n  if (typeof field === 'object') {\n    const fn = objectSetterMap[field.type];\n    if (fn) {\n      return (publicAPI, model) => fn(publicAPI, model, field);\n    }\n    vtkErrorMacro(`No setter for field ${field}`);\n    throw new TypeError('No setter for field');\n  }\n  return function getSetter(publicAPI, model) {\n    const onChanged = `_on${_capitalize(field)}Changed`;\n    return function setter(value) {\n      if (model.deleted) {\n        vtkErrorMacro('instance deleted - cannot call any method');\n        return false;\n      }\n      if (model[field] !== value) {\n        const previousValue = model[field.name];\n        model[field] = value;\n        model[onChanged]?.(publicAPI, model, value, previousValue);\n        publicAPI.modified();\n        return true;\n      }\n      return false;\n    };\n  };\n}\nfunction set(publicAPI, model, fields) {\n  fields.forEach(field => {\n    if (typeof field === 'object') {\n      publicAPI[`set${_capitalize(field.name)}`] = findSetter(field)(publicAPI, model);\n    } else {\n      publicAPI[`set${_capitalize(field)}`] = findSetter(field)(publicAPI, model);\n    }\n  });\n}\n\n// ----------------------------------------------------------------------------\n// set/get XXX: add both setters and getters\n// ----------------------------------------------------------------------------\n\nfunction setGet(publicAPI, model, fieldNames) {\n  get(publicAPI, model, fieldNames);\n  set(publicAPI, model, fieldNames);\n}\n\n// ----------------------------------------------------------------------------\n// getXXX: add getters for object of type array with copy to be safe\n// getXXXByReference: add getters for object of type array without copy\n// ----------------------------------------------------------------------------\n\nfunction getArray(publicAPI, model, fieldNames) {\n  fieldNames.forEach(field => {\n    publicAPI[`get${_capitalize(field)}`] = () => model[field] ? Array.from(model[field]) : model[field];\n    publicAPI[`get${_capitalize(field)}ByReference`] = () => model[field];\n  });\n}\n\n// ----------------------------------------------------------------------------\n// setXXX: add setter for object of type array\n// if 'defaultVal' is supplied, shorter arrays will be padded to 'size' with 'defaultVal'\n// set...From: fast path to copy the content of an array to the current one without call to modified.\n// ----------------------------------------------------------------------------\n\nfunction setArray(publicAPI, model, fieldNames, size) {\n  let defaultVal = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : undefined;\n  fieldNames.forEach(field => {\n    if (model[field] && size && model[field].length !== size) {\n      throw new RangeError(`Invalid initial number of values for array (${field})`);\n    }\n    const onChanged = `_on${_capitalize(field)}Changed`;\n    publicAPI[`set${_capitalize(field)}`] = function () {\n      if (model.deleted) {\n        vtkErrorMacro('instance deleted - cannot call any method');\n        return false;\n      }\n      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n      let array = args;\n      let changeDetected;\n      let needCopy = false;\n      // allow null or an array to be passed as a single arg.\n      if (array.length === 1 && (array[0] == null || array[0].length >= 0)) {\n        /* eslint-disable prefer-destructuring */\n        array = array[0];\n        /* eslint-enable prefer-destructuring */\n        needCopy = true;\n      }\n      if (array == null) {\n        changeDetected = model[field] !== array;\n      } else {\n        if (size && array.length !== size) {\n          if (array.length < size && defaultVal !== undefined) {\n            array = Array.from(array);\n            needCopy = false;\n            while (array.length < size) array.push(defaultVal);\n          } else {\n            throw new RangeError(`Invalid number of values for array setter (${field})`);\n          }\n        }\n        changeDetected = model[field] == null || model[field].length !== array.length;\n        for (let i = 0; !changeDetected && i < array.length; ++i) {\n          changeDetected = model[field][i] !== array[i];\n        }\n        if (changeDetected && needCopy) {\n          array = Array.from(array);\n        }\n      }\n      if (changeDetected) {\n        const previousValue = model[field.name];\n        model[field] = array;\n        model[onChanged]?.(publicAPI, model, array, previousValue);\n        publicAPI.modified();\n      }\n      return changeDetected;\n    };\n    publicAPI[`set${_capitalize(field)}From`] = otherArray => {\n      const target = model[field];\n      otherArray.forEach((v, i) => {\n        target[i] = v;\n      });\n    };\n  });\n}\n\n// ----------------------------------------------------------------------------\n// set/get XXX: add setter and getter for object of type array\n// ----------------------------------------------------------------------------\n\nfunction setGetArray(publicAPI, model, fieldNames, size) {\n  let defaultVal = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : undefined;\n  getArray(publicAPI, model, fieldNames);\n  setArray(publicAPI, model, fieldNames, size, defaultVal);\n}\nfunction moveToProtected(publicAPI, model, fieldNames) {\n  for (let i = 0; i < fieldNames.length; i++) {\n    const fieldName = fieldNames[i];\n    if (model[fieldName] !== undefined) {\n      model[`_${fieldName}`] = model[fieldName];\n      delete model[fieldName];\n    }\n  }\n}\n// ----------------------------------------------------------------------------\n// vtkAlgorithm: setInputData(), setInputConnection(), getOutputData(), getOutputPort()\n// ----------------------------------------------------------------------------\n\nfunction algo(publicAPI, model, numberOfInputs, numberOfOutputs) {\n  if (model.inputData) {\n    model.inputData = model.inputData.map(vtk);\n  } else {\n    model.inputData = [];\n  }\n  if (model.inputConnection) {\n    model.inputConnection = model.inputConnection.map(vtk);\n  } else {\n    model.inputConnection = [];\n  }\n  if (model.output) {\n    model.output = model.output.map(vtk);\n  } else {\n    model.output = [];\n  }\n  if (model.inputArrayToProcess) {\n    model.inputArrayToProcess = model.inputArrayToProcess.map(vtk);\n  } else {\n    model.inputArrayToProcess = [];\n  }\n\n  // Cache the argument for later manipulation\n  model.numberOfInputs = numberOfInputs;\n\n  // Methods\n  function setInputData(dataset) {\n    let port = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    if (model.deleted) {\n      vtkErrorMacro('instance deleted - cannot call any method');\n      return;\n    }\n    if (port >= model.numberOfInputs) {\n      vtkErrorMacro(`algorithm ${publicAPI.getClassName()} only has ${model.numberOfInputs} input ports. To add more input ports, use addInputData()`);\n      return;\n    }\n    if (model.inputData[port] !== dataset || model.inputConnection[port]) {\n      model.inputData[port] = dataset;\n      model.inputConnection[port] = null;\n      if (publicAPI.modified) {\n        publicAPI.modified();\n      }\n    }\n  }\n  function getInputData() {\n    let port = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    if (model.inputConnection[port]) {\n      model.inputData[port] = model.inputConnection[port]();\n    }\n    return model.inputData[port];\n  }\n  function setInputConnection(outputPort) {\n    let port = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    if (model.deleted) {\n      vtkErrorMacro('instance deleted - cannot call any method');\n      return;\n    }\n    if (port >= model.numberOfInputs) {\n      let msg = `algorithm ${publicAPI.getClassName()} only has `;\n      msg += `${model.numberOfInputs}`;\n      msg += ' input ports. To add more input ports, use addInputConnection()';\n      vtkErrorMacro(msg);\n      return;\n    }\n    model.inputData[port] = null;\n    model.inputConnection[port] = outputPort;\n  }\n  function getInputConnection() {\n    let port = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    return model.inputConnection[port];\n  }\n  function getPortToFill() {\n    let portToFill = model.numberOfInputs;\n    while (portToFill && !model.inputData[portToFill - 1] && !model.inputConnection[portToFill - 1]) {\n      portToFill--;\n    }\n    if (portToFill === model.numberOfInputs) {\n      model.numberOfInputs++;\n    }\n    return portToFill;\n  }\n  function addInputConnection(outputPort) {\n    if (model.deleted) {\n      vtkErrorMacro('instance deleted - cannot call any method');\n      return;\n    }\n    setInputConnection(outputPort, getPortToFill());\n  }\n  function addInputData(dataset) {\n    if (model.deleted) {\n      vtkErrorMacro('instance deleted - cannot call any method');\n      return;\n    }\n    setInputData(dataset, getPortToFill());\n  }\n  function getOutputData() {\n    let port = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    if (model.deleted) {\n      vtkErrorMacro('instance deleted - cannot call any method');\n      return null;\n    }\n    if (publicAPI.shouldUpdate()) {\n      publicAPI.update();\n    }\n    return model.output[port];\n  }\n  publicAPI.shouldUpdate = () => {\n    const localMTime = publicAPI.getMTime();\n    let minOutputMTime = Infinity;\n    let count = numberOfOutputs;\n    while (count--) {\n      if (!model.output[count] || model.output[count].isDeleted()) {\n        return true;\n      }\n      const mt = model.output[count].getMTime();\n      if (mt < localMTime) {\n        return true;\n      }\n      if (mt < minOutputMTime) {\n        minOutputMTime = mt;\n      }\n    }\n    count = model.numberOfInputs;\n    while (count--) {\n      if (model.inputConnection[count]?.filter.shouldUpdate() || publicAPI.getInputData(count)?.getMTime() > minOutputMTime) {\n        return true;\n      }\n    }\n    return false;\n  };\n  function getOutputPort() {\n    let port = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    const outputPortAccess = () => getOutputData(port);\n    // Add reference to filter\n    outputPortAccess.filter = publicAPI;\n    return outputPortAccess;\n  }\n\n  // Handle input if needed\n  if (model.numberOfInputs) {\n    // Reserve inputs\n    let count = model.numberOfInputs;\n    while (count--) {\n      model.inputData.push(null);\n      model.inputConnection.push(null);\n    }\n\n    // Expose public methods\n    publicAPI.setInputData = setInputData;\n    publicAPI.setInputConnection = setInputConnection;\n    publicAPI.addInputData = addInputData;\n    publicAPI.addInputConnection = addInputConnection;\n    publicAPI.getInputData = getInputData;\n    publicAPI.getInputConnection = getInputConnection;\n  }\n  if (numberOfOutputs) {\n    publicAPI.getOutputData = getOutputData;\n    publicAPI.getOutputPort = getOutputPort;\n  }\n  publicAPI.update = () => {\n    const ins = [];\n    if (model.numberOfInputs) {\n      let count = 0;\n      while (count < model.numberOfInputs) {\n        ins[count] = publicAPI.getInputData(count);\n        count++;\n      }\n    }\n    if (publicAPI.shouldUpdate() && publicAPI.requestData) {\n      publicAPI.requestData(ins, model.output);\n    }\n  };\n  publicAPI.getNumberOfInputPorts = () => model.numberOfInputs;\n  publicAPI.getNumberOfOutputPorts = () => numberOfOutputs || model.output.length;\n  publicAPI.getInputArrayToProcess = inputPort => {\n    const arrayDesc = model.inputArrayToProcess[inputPort];\n    const ds = model.inputData[inputPort];\n    if (arrayDesc && ds) {\n      return ds[`get${arrayDesc.fieldAssociation}`]().getArray(arrayDesc.arrayName);\n    }\n    return null;\n  };\n  publicAPI.setInputArrayToProcess = function (inputPort, arrayName, fieldAssociation) {\n    let attributeType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'Scalars';\n    while (model.inputArrayToProcess.length < inputPort) {\n      model.inputArrayToProcess.push(null);\n    }\n    model.inputArrayToProcess[inputPort] = {\n      arrayName,\n      fieldAssociation,\n      attributeType\n    };\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Event handling: onXXX(callback), invokeXXX(args...)\n// ----------------------------------------------------------------------------\n\nconst EVENT_ABORT = Symbol('Event abort');\nfunction event(publicAPI, model, eventName) {\n  const callbacks = [];\n  const previousDelete = publicAPI.delete;\n  let curCallbackID = 1;\n  function off(callbackID) {\n    for (let i = 0; i < callbacks.length; ++i) {\n      const [cbID] = callbacks[i];\n      if (cbID === callbackID) {\n        callbacks.splice(i, 1);\n        return;\n      }\n    }\n  }\n  function on(callbackID) {\n    function unsubscribe() {\n      off(callbackID);\n    }\n    return Object.freeze({\n      unsubscribe\n    });\n  }\n  function invoke() {\n    if (model.deleted) {\n      vtkErrorMacro('instance deleted - cannot call any method');\n      return;\n    }\n    /* eslint-disable prefer-rest-params */\n    // Go through a copy of the callbacks array in case new callbacks\n    // get prepended within previous callbacks\n    const currentCallbacks = callbacks.slice();\n    for (let index = 0; index < currentCallbacks.length; ++index) {\n      const [, cb, priority] = currentCallbacks[index];\n      if (!cb) {\n        continue; // eslint-disable-line\n      }\n\n      if (priority < 0) {\n        setTimeout(() => cb.apply(publicAPI, arguments), 1 - priority);\n      } else {\n        // Abort only if the callback explicitly returns false\n        const continueNext = cb.apply(publicAPI, arguments);\n        if (continueNext === EVENT_ABORT) {\n          break;\n        }\n      }\n    }\n    /* eslint-enable prefer-rest-params */\n  }\n\n  publicAPI[`invoke${_capitalize(eventName)}`] = invoke;\n  publicAPI[`on${_capitalize(eventName)}`] = function (callback) {\n    let priority = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.0;\n    if (!callback.apply) {\n      console.error(`Invalid callback for event ${eventName}`);\n      return null;\n    }\n    if (model.deleted) {\n      vtkErrorMacro('instance deleted - cannot call any method');\n      return null;\n    }\n    const callbackID = curCallbackID++;\n    callbacks.push([callbackID, callback, priority]);\n    callbacks.sort((cb1, cb2) => cb2[2] - cb1[2]);\n    return on(callbackID);\n  };\n  publicAPI.delete = () => {\n    previousDelete();\n    callbacks.forEach(_ref => {\n      let [cbID] = _ref;\n      return off(cbID);\n    });\n  };\n}\n\n// ----------------------------------------------------------------------------\n// newInstance\n// ----------------------------------------------------------------------------\n\nfunction newInstance(extend, className) {\n  const constructor = function () {\n    let initialValues = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const model = {};\n    const publicAPI = {};\n    extend(publicAPI, model, initialValues);\n    return Object.freeze(publicAPI);\n  };\n\n  // Register constructor to factory\n  if (className) {\n    vtk.register(className, constructor);\n  }\n  return constructor;\n}\n\n// ----------------------------------------------------------------------------\n// Chain function calls\n// ----------------------------------------------------------------------------\n\nfunction chain() {\n  for (var _len5 = arguments.length, fn = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n    fn[_key5] = arguments[_key5];\n  }\n  return function () {\n    for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n      args[_key6] = arguments[_key6];\n    }\n    return fn.filter(i => !!i).map(i => i(...args));\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Some utility methods for vtk objects\n// ----------------------------------------------------------------------------\n\nfunction isVtkObject(instance) {\n  return instance && instance.isA && instance.isA('vtkObject');\n}\nfunction traverseInstanceTree(instance, extractFunction) {\n  let accumulator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  let visitedInstances = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n  if (isVtkObject(instance)) {\n    if (visitedInstances.indexOf(instance) >= 0) {\n      // avoid cycles\n      return accumulator;\n    }\n    visitedInstances.push(instance);\n    const result = extractFunction(instance);\n    if (result !== undefined) {\n      accumulator.push(result);\n    }\n\n    // Now go through this instance's model\n    const model = instance.get();\n    Object.keys(model).forEach(key => {\n      const modelObj = model[key];\n      if (Array.isArray(modelObj)) {\n        modelObj.forEach(subObj => {\n          traverseInstanceTree(subObj, extractFunction, accumulator, visitedInstances);\n        });\n      } else {\n        traverseInstanceTree(modelObj, extractFunction, accumulator, visitedInstances);\n      }\n    });\n  }\n  return accumulator;\n}\n\n// ----------------------------------------------------------------------------\n// Returns a function, that, as long as it continues to be invoked, will not\n// be triggered. The function will be called after it stops being called for\n// N milliseconds. If `immediate` is passed, trigger the function on the\n// leading edge, instead of the trailing.\n\nfunction debounce(func, wait, immediate) {\n  var _this = this;\n  let timeout;\n  const debounced = function () {\n    for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n      args[_key7] = arguments[_key7];\n    }\n    const context = _this;\n    const later = () => {\n      timeout = null;\n      if (!immediate) {\n        func.apply(context, args);\n      }\n    };\n    const callNow = immediate && !timeout;\n    clearTimeout(timeout);\n    timeout = setTimeout(later, wait);\n    if (callNow) {\n      func.apply(context, args);\n    }\n  };\n  debounced.cancel = () => clearTimeout(timeout);\n  return debounced;\n}\n\n// ----------------------------------------------------------------------------\n// Creates a throttled function that only invokes `func` at most once per\n// every `wait` milliseconds.\n\nfunction throttle(callback, delay) {\n  let isThrottled = false;\n  let argsToUse = null;\n  function next() {\n    isThrottled = false;\n    if (argsToUse !== null) {\n      wrapper(...argsToUse); // eslint-disable-line\n      argsToUse = null;\n    }\n  }\n  function wrapper() {\n    for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n      args[_key8] = arguments[_key8];\n    }\n    if (isThrottled) {\n      argsToUse = args;\n      return;\n    }\n    isThrottled = true;\n    callback(...args);\n    setTimeout(next, delay);\n  }\n  return wrapper;\n}\n\n// ----------------------------------------------------------------------------\n// keystore(publicAPI, model, initialKeystore)\n//\n//    - initialKeystore: Initial keystore. This can be either a Map or an\n//      object.\n//\n// Generated API\n//  setKey(key, value) : mixed (returns value)\n//  getKey(key) : mixed\n//  getAllKeys() : [mixed]\n//  deleteKey(key) : Boolean\n// ----------------------------------------------------------------------------\n\nfunction keystore(publicAPI, model) {\n  let initialKeystore = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  model.keystore = Object.assign(model.keystore || {}, initialKeystore);\n  publicAPI.setKey = (key, value) => {\n    model.keystore[key] = value;\n  };\n  publicAPI.getKey = key => model.keystore[key];\n  publicAPI.getAllKeys = () => Object.keys(model.keystore);\n  publicAPI.deleteKey = key => delete model.keystore[key];\n  publicAPI.clearKeystore = () => publicAPI.getAllKeys().forEach(key => delete model.keystore[key]);\n}\n\n// ----------------------------------------------------------------------------\n// proxy(publicAPI, model, sectionName, propertyUI)\n//\n//    - sectionName: Name of the section for UI\n//    - propertyUI: List of props with their UI description\n//\n// Generated API\n//  getProxyId() : String\n//  listProxyProperties() : [string]\n//  updateProxyProperty(name, prop)\n//  getProxySection() => List of properties for UI generation\n// ----------------------------------------------------------------------------\nlet nextProxyId = 1;\nconst ROOT_GROUP_NAME = '__root__';\nfunction proxy(publicAPI, model) {\n  // Proxies are keystores\n  keystore(publicAPI, model);\n  const parentDelete = publicAPI.delete;\n\n  // getProxyId\n  model.proxyId = `${nextProxyId++}`;\n\n  // ui handling\n  model.ui = JSON.parse(JSON.stringify(model.ui || [])); // deep copy\n  get(publicAPI, model, ['proxyId', 'proxyGroup', 'proxyName']);\n  setGet(publicAPI, model, ['proxyManager']);\n\n  // group properties\n  const propertyMap = {};\n  const groupChildrenNames = {};\n  function registerProperties(descriptionList, currentGroupName) {\n    if (!groupChildrenNames[currentGroupName]) {\n      groupChildrenNames[currentGroupName] = [];\n    }\n    const childrenNames = groupChildrenNames[currentGroupName];\n    for (let i = 0; i < descriptionList.length; i++) {\n      childrenNames.push(descriptionList[i].name);\n      propertyMap[descriptionList[i].name] = descriptionList[i];\n      if (descriptionList[i].children && descriptionList[i].children.length) {\n        registerProperties(descriptionList[i].children, descriptionList[i].name);\n      }\n    }\n  }\n  registerProperties(model.ui, ROOT_GROUP_NAME);\n  publicAPI.updateUI = ui => {\n    model.ui = JSON.parse(JSON.stringify(ui || [])); // deep copy\n    Object.keys(propertyMap).forEach(k => delete propertyMap[k]);\n    Object.keys(groupChildrenNames).forEach(k => delete groupChildrenNames[k]);\n    registerProperties(model.ui, ROOT_GROUP_NAME);\n    publicAPI.modified();\n  };\n  function listProxyProperties() {\n    let gName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ROOT_GROUP_NAME;\n    return groupChildrenNames[gName];\n  }\n  publicAPI.updateProxyProperty = (propertyName, propUI) => {\n    const prop = propertyMap[propertyName];\n    if (prop) {\n      Object.assign(prop, propUI);\n    } else {\n      propertyMap[propertyName] = {\n        ...propUI\n      };\n    }\n  };\n  publicAPI.activate = () => {\n    if (model.proxyManager) {\n      const setActiveMethod = `setActive${_capitalize(publicAPI.getProxyGroup().slice(0, -1))}`;\n      if (model.proxyManager[setActiveMethod]) {\n        model.proxyManager[setActiveMethod](publicAPI);\n      }\n    }\n  };\n\n  // property link\n  model.propertyLinkSubscribers = {};\n  publicAPI.registerPropertyLinkForGC = (otherLink, type) => {\n    if (!(type in model.propertyLinkSubscribers)) {\n      model.propertyLinkSubscribers[type] = [];\n    }\n    model.propertyLinkSubscribers[type].push(otherLink);\n  };\n  publicAPI.gcPropertyLinks = type => {\n    const subscribers = model.propertyLinkSubscribers[type] || [];\n    while (subscribers.length) {\n      subscribers.pop().unbind(publicAPI);\n    }\n  };\n  model.propertyLinkMap = {};\n  publicAPI.getPropertyLink = function (id) {\n    let persistent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (model.propertyLinkMap[id]) {\n      return model.propertyLinkMap[id];\n    }\n    let value = null;\n    const links = [];\n    let count = 0;\n    let updateInProgress = false;\n    function update(source) {\n      let force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      if (updateInProgress) {\n        return null;\n      }\n      const needUpdate = [];\n      let sourceLink = null;\n      count = links.length;\n      while (count--) {\n        const link = links[count];\n        if (link.instance === source) {\n          sourceLink = link;\n        } else {\n          needUpdate.push(link);\n        }\n      }\n      if (!sourceLink) {\n        return null;\n      }\n      const newValue = sourceLink.instance[`get${_capitalize(sourceLink.propertyName)}`]();\n      if (!shallowEquals(newValue, value) || force) {\n        value = newValue;\n        updateInProgress = true;\n        while (needUpdate.length) {\n          const linkToUpdate = needUpdate.pop();\n          linkToUpdate.instance.set({\n            [linkToUpdate.propertyName]: value\n          });\n        }\n        updateInProgress = false;\n      }\n      if (model.propertyLinkMap[id].persistent) {\n        model.propertyLinkMap[id].value = newValue;\n      }\n      return newValue;\n    }\n    function unbind(instance, propertyName) {\n      const indexToDelete = [];\n      count = links.length;\n      while (count--) {\n        const link = links[count];\n        if (link.instance === instance && (link.propertyName === propertyName || propertyName === undefined)) {\n          link.subscription.unsubscribe();\n          indexToDelete.push(count);\n        }\n      }\n      while (indexToDelete.length) {\n        links.splice(indexToDelete.pop(), 1);\n      }\n    }\n    function bind(instance, propertyName) {\n      let updateMe = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      const subscription = instance.onModified(update);\n      const other = links[0];\n      links.push({\n        instance,\n        propertyName,\n        subscription\n      });\n      if (updateMe) {\n        if (model.propertyLinkMap[id].persistent && model.propertyLinkMap[id].value !== undefined) {\n          instance.set({\n            [propertyName]: model.propertyLinkMap[id].value\n          });\n        } else if (other) {\n          update(other.instance, true);\n        }\n      }\n      return {\n        unsubscribe: () => unbind(instance, propertyName)\n      };\n    }\n    function unsubscribe() {\n      while (links.length) {\n        links.pop().subscription.unsubscribe();\n      }\n    }\n    const linkHandler = {\n      bind,\n      unbind,\n      unsubscribe,\n      persistent\n    };\n    model.propertyLinkMap[id] = linkHandler;\n    return linkHandler;\n  };\n\n  // extract values\n  function getProperties() {\n    let groupName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ROOT_GROUP_NAME;\n    const values = [];\n    const id = model.proxyId;\n    const propertyNames = listProxyProperties(groupName) || [];\n    for (let i = 0; i < propertyNames.length; i++) {\n      const name = propertyNames[i];\n      const method = publicAPI[`get${_capitalize(name)}`];\n      const value = method ? method() : undefined;\n      const prop = {\n        id,\n        name,\n        value\n      };\n      const children = getProperties(name);\n      if (children.length) {\n        prop.children = children;\n      }\n      values.push(prop);\n    }\n    return values;\n  }\n  publicAPI.listPropertyNames = () => getProperties().map(p => p.name);\n  publicAPI.getPropertyByName = name => getProperties().find(p => p.name === name);\n  publicAPI.getPropertyDomainByName = name => (propertyMap[name] || {}).domain;\n\n  // ui section\n  publicAPI.getProxySection = () => ({\n    id: model.proxyId,\n    name: model.proxyGroup,\n    ui: model.ui,\n    properties: getProperties()\n  });\n\n  // free resources\n  publicAPI.delete = () => {\n    const list = Object.keys(model.propertyLinkMap);\n    let count = list.length;\n    while (count--) {\n      model.propertyLinkMap[list[count]].unsubscribe();\n    }\n    Object.keys(model.propertyLinkSubscribers).forEach(publicAPI.gcPropertyLinks);\n    parentDelete();\n  };\n\n  // @todo fix infinite recursion due to active source\n  publicAPI.getState = () => null;\n  function registerLinks() {\n    // Allow dynamic registration of links at the application level\n    if (model.links) {\n      for (let i = 0; i < model.links.length; i++) {\n        const {\n          link,\n          property,\n          persistent,\n          updateOnBind,\n          type\n        } = model.links[i];\n        if (type === 'application') {\n          const sLink = model.proxyManager.getPropertyLink(link, persistent);\n          publicAPI.registerPropertyLinkForGC(sLink, 'application');\n          sLink.bind(publicAPI, property, updateOnBind);\n        }\n      }\n    }\n  }\n  setImmediateVTK(registerLinks);\n}\n\n// ----------------------------------------------------------------------------\n// proxyPropertyMapping(publicAPI, model, map)\n//\n//   map = {\n//      opacity: { modelKey: 'property', property: 'opacity' },\n//   }\n//\n// Generated API:\n//  Elevate set/get methods from internal object stored in the model to current one\n// ----------------------------------------------------------------------------\n\nfunction proxyPropertyMapping(publicAPI, model, map) {\n  const parentDelete = publicAPI.delete;\n  const subscriptions = [];\n  const propertyNames = Object.keys(map);\n  let count = propertyNames.length;\n  while (count--) {\n    const propertyName = propertyNames[count];\n    const {\n      modelKey,\n      property,\n      modified = true\n    } = map[propertyName];\n    const methodSrc = _capitalize(property);\n    const methodDst = _capitalize(propertyName);\n    publicAPI[`get${methodDst}`] = model[modelKey][`get${methodSrc}`];\n    publicAPI[`set${methodDst}`] = model[modelKey][`set${methodSrc}`];\n    if (modified) {\n      subscriptions.push(model[modelKey].onModified(publicAPI.modified));\n    }\n  }\n  publicAPI.delete = () => {\n    while (subscriptions.length) {\n      subscriptions.pop().unsubscribe();\n    }\n    parentDelete();\n  };\n}\n\n// ----------------------------------------------------------------------------\n// proxyPropertyState(publicAPI, model, state, defaults)\n//\n//   state = {\n//     representation: {\n//       'Surface with edges': { property: { edgeVisibility: true, representation: 2 } },\n//       Surface: { property: { edgeVisibility: false, representation: 2 } },\n//       Wireframe: { property: { edgeVisibility: false, representation: 1 } },\n//       Points: { property: { edgeVisibility: false, representation: 0 } },\n//     },\n//   }\n//\n//   defaults = {\n//      representation: 'Surface',\n//   }\n//\n// Generated API\n//   get / set Representation ( string ) => push state to various internal objects\n// ----------------------------------------------------------------------------\n\nfunction proxyPropertyState(publicAPI, model) {\n  let state = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let defaults = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  model.this = publicAPI;\n  function applyState(map) {\n    const modelKeys = Object.keys(map);\n    let count = modelKeys.length;\n    while (count--) {\n      const modelKey = modelKeys[count];\n      model[modelKey].set(map[modelKey]);\n    }\n  }\n  const modelKeys = Object.keys(defaults);\n  let count = modelKeys.length;\n  while (count--) {\n    // Add default\n    const key = modelKeys[count];\n    model[key] = defaults[key];\n\n    // Add set method\n    const mapping = state[key];\n    publicAPI[`set${_capitalize(key)}`] = value => {\n      if (value !== model[key]) {\n        model[key] = value;\n        const propValues = mapping[value];\n        applyState(propValues);\n        publicAPI.modified();\n      }\n    };\n  }\n\n  // Add getter\n  if (modelKeys.length) {\n    get(publicAPI, model, modelKeys);\n  }\n}\n\n// ----------------------------------------------------------------------------\n// From : https://github.com/facebookarchive/fixed-data-table/blob/master/src/vendor_upstream/dom/normalizeWheel.js\n//\n//\n// Copyright (c) 2015, Facebook, Inc.\n// All rights reserved.\n//\n// This source code is licensed under the BSD-style license found in the\n// LICENSE file in the root directory of this source tree. An additional grant\n// of patent rights can be found in the PATENTS file in the same directory.\n//\n//\n// Mouse wheel (and 2-finger trackpad) support on the web sucks.  It is\n// complicated, thus this doc is long and (hopefully) detailed enough to answer\n// your questions.\n//\n// If you need to react to the mouse wheel in a predictable way, this code is\n// like your bestest friend.// hugs//\n//\n// As of today, there are 4 DOM event types you can listen to:\n//\n//   'wheel'                -- Chrome(31+), FF(17+), IE(9+)\n//   'mousewheel'           -- Chrome, IE(6+), Opera, Safari\n//   'MozMousePixelScroll'  -- FF(3.5 only!) (2010-2013) -- don't bother!\n//   'DOMMouseScroll'       -- FF(0.9.7+) since 2003\n//\n// So what to do?  The is the best:\n//\n//   normalizeWheel.getEventType();\n//\n// In your event callback, use this code to get sane interpretation of the\n// deltas.  This code will return an object with properties:\n//\n//   spinX   -- normalized spin speed (use for zoom) - x plane\n//   spinY   -- \" - y plane\n//   pixelX  -- normalized distance (to pixels) - x plane\n//   pixelY  -- \" - y plane\n//\n// Wheel values are provided by the browser assuming you are using the wheel to\n// scroll a web page by a number of lines or pixels (or pages).  Values can vary\n// significantly on different platforms and browsers, forgetting that you can\n// scroll at different speeds.  Some devices (like trackpads) emit more events\n// at smaller increments with fine granularity, and some emit massive jumps with\n// linear speed or acceleration.\n//\n// This code does its best to normalize the deltas for you:\n//\n//   - spin is trying to normalize how far the wheel was spun (or trackpad\n//     dragged).  This is super useful for zoom support where you want to\n//     throw away the chunky scroll steps on the PC and make those equal to\n//     the slow and smooth tiny steps on the Mac. Key data: This code tries to\n//     resolve a single slow step on a wheel to 1.\n//\n//   - pixel is normalizing the desired scroll delta in pixel units.  You'll\n//     get the crazy differences between browsers, but at least it'll be in\n//     pixels!\n//\n//   - positive value indicates scrolling DOWN/RIGHT, negative UP/LEFT.  This\n//     should translate to positive value zooming IN, negative zooming OUT.\n//     This matches the newer 'wheel' event.\n//\n// Why are there spinX, spinY (or pixels)?\n//\n//   - spinX is a 2-finger side drag on the trackpad, and a shift + wheel turn\n//     with a mouse.  It results in side-scrolling in the browser by default.\n//\n//   - spinY is what you expect -- it's the classic axis of a mouse wheel.\n//\n//   - I dropped spinZ/pixelZ.  It is supported by the DOM 3 'wheel' event and\n//     probably is by browsers in conjunction with fancy 3D controllers .. but\n//     you know.\n//\n// Implementation info:\n//\n// Examples of 'wheel' event if you scroll slowly (down) by one step with an\n// average mouse:\n//\n//   OS X + Chrome  (mouse)     -    4   pixel delta  (wheelDelta -120)\n//   OS X + Safari  (mouse)     -  N/A   pixel delta  (wheelDelta  -12)\n//   OS X + Firefox (mouse)     -    0.1 line  delta  (wheelDelta  N/A)\n//   Win8 + Chrome  (mouse)     -  100   pixel delta  (wheelDelta -120)\n//   Win8 + Firefox (mouse)     -    3   line  delta  (wheelDelta -120)\n//\n// On the trackpad:\n//\n//   OS X + Chrome  (trackpad)  -    2   pixel delta  (wheelDelta   -6)\n//   OS X + Firefox (trackpad)  -    1   pixel delta  (wheelDelta  N/A)\n//\n// On other/older browsers.. it's more complicated as there can be multiple and\n// also missing delta values.\n//\n// The 'wheel' event is more standard:\n//\n// http://www.w3.org/TR/DOM-Level-3-Events/#events-wheelevents\n//\n// The basics is that it includes a unit, deltaMode (pixels, lines, pages), and\n// deltaX, deltaY and deltaZ.  Some browsers provide other values to maintain\n// backward compatibility with older events.  Those other values help us\n// better normalize spin speed.  Example of what the browsers provide:\n//\n//                          | event.wheelDelta | event.detail\n//        ------------------+------------------+--------------\n//          Safari v5/OS X  |       -120       |       0\n//          Safari v5/Win7  |       -120       |       0\n//         Chrome v17/OS X  |       -120       |       0\n//         Chrome v17/Win7  |       -120       |       0\n//                IE9/Win7  |       -120       |   undefined\n//         Firefox v4/OS X  |     undefined    |       1\n//         Firefox v4/Win7  |     undefined    |       3\n//\n// ----------------------------------------------------------------------------\n\n// Reasonable defaults\nconst PIXEL_STEP = 10;\nconst LINE_HEIGHT = 40;\nconst PAGE_HEIGHT = 800;\nfunction normalizeWheel(wheelEvent) {\n  let sX = 0; // spinX\n  let sY = 0; // spinY\n  let pX = 0; // pixelX\n  let pY = 0; // pixelY\n\n  // Legacy\n  if ('detail' in wheelEvent) {\n    sY = wheelEvent.detail;\n  }\n  if ('wheelDelta' in wheelEvent) {\n    sY = -wheelEvent.wheelDelta / 120;\n  }\n  if ('wheelDeltaY' in wheelEvent) {\n    sY = -wheelEvent.wheelDeltaY / 120;\n  }\n  if ('wheelDeltaX' in wheelEvent) {\n    sX = -wheelEvent.wheelDeltaX / 120;\n  }\n\n  // side scrolling on FF with DOMMouseScroll\n  if ('axis' in wheelEvent && wheelEvent.axis === wheelEvent.HORIZONTAL_AXIS) {\n    sX = sY;\n    sY = 0;\n  }\n  pX = sX * PIXEL_STEP;\n  pY = sY * PIXEL_STEP;\n  if ('deltaY' in wheelEvent) {\n    pY = wheelEvent.deltaY;\n  }\n  if ('deltaX' in wheelEvent) {\n    pX = wheelEvent.deltaX;\n  }\n  if ((pX || pY) && wheelEvent.deltaMode) {\n    if (wheelEvent.deltaMode === 1) {\n      // delta in LINE units\n      pX *= LINE_HEIGHT;\n      pY *= LINE_HEIGHT;\n    } else {\n      // delta in PAGE units\n      pX *= PAGE_HEIGHT;\n      pY *= PAGE_HEIGHT;\n    }\n  }\n\n  // Fall-back if spin cannot be determined\n  if (pX && !sX) {\n    sX = pX < 1 ? -1 : 1;\n  }\n  if (pY && !sY) {\n    sY = pY < 1 ? -1 : 1;\n  }\n  return {\n    spinX: sX,\n    spinY: sY || sX,\n    pixelX: pX,\n    pixelY: pY || pX\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Default export\n// ----------------------------------------------------------------------------\n\nvar macro = {\n  algo,\n  capitalize,\n  chain,\n  debounce,\n  enumToString,\n  event,\n  EVENT_ABORT,\n  formatBytesToProperUnit,\n  formatNumbersWithThousandSeparator,\n  get,\n  getArray,\n  getCurrentGlobalMTime,\n  getStateArrayMapFunc,\n  isVtkObject,\n  keystore,\n  measurePromiseExecution,\n  moveToProtected,\n  newInstance,\n  newTypedArray,\n  newTypedArrayFrom,\n  normalizeWheel,\n  obj,\n  proxy,\n  proxyPropertyMapping,\n  proxyPropertyState,\n  safeArrays,\n  set,\n  setArray,\n  setGet,\n  setGetArray,\n  setImmediate: setImmediateVTK,\n  setLoggerFunction,\n  throttle,\n  traverseInstanceTree,\n  TYPED_ARRAYS,\n  // deprecated todo remove on breaking API revision\n  uncapitalize,\n  VOID,\n  vtkDebugMacro,\n  vtkErrorMacro,\n  vtkInfoMacro,\n  vtkLogMacro,\n  vtkOnceErrorMacro,\n  vtkWarningMacro\n};\n\nvar macro$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  VOID: VOID,\n  setLoggerFunction: setLoggerFunction,\n  vtkLogMacro: vtkLogMacro,\n  vtkInfoMacro: vtkInfoMacro,\n  vtkDebugMacro: vtkDebugMacro,\n  vtkErrorMacro: vtkErrorMacro,\n  vtkWarningMacro: vtkWarningMacro,\n  vtkOnceErrorMacro: vtkOnceErrorMacro,\n  TYPED_ARRAYS: TYPED_ARRAYS,\n  newTypedArray: newTypedArray,\n  newTypedArrayFrom: newTypedArrayFrom,\n  capitalize: capitalize,\n  _capitalize: _capitalize,\n  uncapitalize: uncapitalize,\n  formatBytesToProperUnit: formatBytesToProperUnit,\n  formatNumbersWithThousandSeparator: formatNumbersWithThousandSeparator,\n  setImmediateVTK: setImmediateVTK,\n  measurePromiseExecution: measurePromiseExecution,\n  obj: obj,\n  get: get,\n  set: set,\n  setGet: setGet,\n  getArray: getArray,\n  setArray: setArray,\n  setGetArray: setGetArray,\n  moveToProtected: moveToProtected,\n  algo: algo,\n  EVENT_ABORT: EVENT_ABORT,\n  event: event,\n  newInstance: newInstance,\n  chain: chain,\n  isVtkObject: isVtkObject,\n  traverseInstanceTree: traverseInstanceTree,\n  debounce: debounce,\n  throttle: throttle,\n  keystore: keystore,\n  proxy: proxy,\n  proxyPropertyMapping: proxyPropertyMapping,\n  proxyPropertyState: proxyPropertyState,\n  normalizeWheel: normalizeWheel,\n  'default': macro\n});\n\nexport { uncapitalize as A, formatBytesToProperUnit as B, formatNumbersWithThousandSeparator as C, setImmediateVTK as D, measurePromiseExecution as E, setArray as F, EVENT_ABORT as G, isVtkObject as H, debounce as I, throttle as J, keystore as K, proxyPropertyState as L, normalizeWheel as M, TYPED_ARRAYS as T, VOID as V, _capitalize as _, newTypedArray as a, newTypedArrayFrom as b, macro$1 as c, algo as d, setGet as e, event as f, get as g, chain as h, moveToProtected as i, proxyPropertyMapping as j, getArray as k, setGetArray as l, macro as m, newInstance as n, obj as o, proxy as p, capitalize as q, vtkErrorMacro as r, set as s, traverseInstanceTree as t, setLoggerFunction as u, vtkWarningMacro as v, vtkLogMacro as w, vtkInfoMacro as x, vtkDebugMacro as y, vtkOnceErrorMacro as z };\n","// A port of an algorithm by Johannes Baagøe <baagoe@baagoe.com>, 2010\n// http://baagoe.com/en/RandomMusings/javascript/\n// https://github.com/nquinlan/better-random-numbers-for-javascript-mirror\n// Original work is under MIT license -\n\n// Copyright (C) 2010 by Johannes Baagøe <baagoe@baagoe.org>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\n\n(function(global, module, define) {\n\nfunction Alea(seed) {\n  var me = this, mash = Mash();\n\n  me.next = function() {\n    var t = 2091639 * me.s0 + me.c * 2.3283064365386963e-10; // 2^-32\n    me.s0 = me.s1;\n    me.s1 = me.s2;\n    return me.s2 = t - (me.c = t | 0);\n  };\n\n  // Apply the seeding algorithm from Baagoe.\n  me.c = 1;\n  me.s0 = mash(' ');\n  me.s1 = mash(' ');\n  me.s2 = mash(' ');\n  me.s0 -= mash(seed);\n  if (me.s0 < 0) { me.s0 += 1; }\n  me.s1 -= mash(seed);\n  if (me.s1 < 0) { me.s1 += 1; }\n  me.s2 -= mash(seed);\n  if (me.s2 < 0) { me.s2 += 1; }\n  mash = null;\n}\n\nfunction copy(f, t) {\n  t.c = f.c;\n  t.s0 = f.s0;\n  t.s1 = f.s1;\n  t.s2 = f.s2;\n  return t;\n}\n\nfunction impl(seed, opts) {\n  var xg = new Alea(seed),\n      state = opts && opts.state,\n      prng = xg.next;\n  prng.int32 = function() { return (xg.next() * 0x100000000) | 0; }\n  prng.double = function() {\n    return prng() + (prng() * 0x200000 | 0) * 1.1102230246251565e-16; // 2^-53\n  };\n  prng.quick = prng;\n  if (state) {\n    if (typeof(state) == 'object') copy(state, xg);\n    prng.state = function() { return copy(xg, {}); }\n  }\n  return prng;\n}\n\nfunction Mash() {\n  var n = 0xefc8249d;\n\n  var mash = function(data) {\n    data = String(data);\n    for (var i = 0; i < data.length; i++) {\n      n += data.charCodeAt(i);\n      var h = 0.02519603282416938 * n;\n      n = h >>> 0;\n      h -= n;\n      h *= n;\n      n = h >>> 0;\n      h -= n;\n      n += h * 0x100000000; // 2^32\n    }\n    return (n >>> 0) * 2.3283064365386963e-10; // 2^-32\n  };\n\n  return mash;\n}\n\n\nif (module && module.exports) {\n  module.exports = impl;\n} else if (define && define.amd) {\n  define(function() { return impl; });\n} else {\n  this.alea = impl;\n}\n\n})(\n  this,\n  (typeof module) == 'object' && module,    // present in node.js\n  (typeof define) == 'function' && define   // present with an AMD loader\n);\n\n\n","// A Javascript implementaion of the \"xor128\" prng algorithm by\n// George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper\n\n(function(global, module, define) {\n\nfunction XorGen(seed) {\n  var me = this, strseed = '';\n\n  me.x = 0;\n  me.y = 0;\n  me.z = 0;\n  me.w = 0;\n\n  // Set up generator function.\n  me.next = function() {\n    var t = me.x ^ (me.x << 11);\n    me.x = me.y;\n    me.y = me.z;\n    me.z = me.w;\n    return me.w ^= (me.w >>> 19) ^ t ^ (t >>> 8);\n  };\n\n  if (seed === (seed | 0)) {\n    // Integer seed.\n    me.x = seed;\n  } else {\n    // String seed.\n    strseed += seed;\n  }\n\n  // Mix in string seed, then discard an initial batch of 64 values.\n  for (var k = 0; k < strseed.length + 64; k++) {\n    me.x ^= strseed.charCodeAt(k) | 0;\n    me.next();\n  }\n}\n\nfunction copy(f, t) {\n  t.x = f.x;\n  t.y = f.y;\n  t.z = f.z;\n  t.w = f.w;\n  return t;\n}\n\nfunction impl(seed, opts) {\n  var xg = new XorGen(seed),\n      state = opts && opts.state,\n      prng = function() { return (xg.next() >>> 0) / 0x100000000; };\n  prng.double = function() {\n    do {\n      var top = xg.next() >>> 11,\n          bot = (xg.next() >>> 0) / 0x100000000,\n          result = (top + bot) / (1 << 21);\n    } while (result === 0);\n    return result;\n  };\n  prng.int32 = xg.next;\n  prng.quick = prng;\n  if (state) {\n    if (typeof(state) == 'object') copy(state, xg);\n    prng.state = function() { return copy(xg, {}); }\n  }\n  return prng;\n}\n\nif (module && module.exports) {\n  module.exports = impl;\n} else if (define && define.amd) {\n  define(function() { return impl; });\n} else {\n  this.xor128 = impl;\n}\n\n})(\n  this,\n  (typeof module) == 'object' && module,    // present in node.js\n  (typeof define) == 'function' && define   // present with an AMD loader\n);\n\n\n","// A Javascript implementaion of the \"xorwow\" prng algorithm by\n// George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper\n\n(function(global, module, define) {\n\nfunction XorGen(seed) {\n  var me = this, strseed = '';\n\n  // Set up generator function.\n  me.next = function() {\n    var t = (me.x ^ (me.x >>> 2));\n    me.x = me.y; me.y = me.z; me.z = me.w; me.w = me.v;\n    return (me.d = (me.d + 362437 | 0)) +\n       (me.v = (me.v ^ (me.v << 4)) ^ (t ^ (t << 1))) | 0;\n  };\n\n  me.x = 0;\n  me.y = 0;\n  me.z = 0;\n  me.w = 0;\n  me.v = 0;\n\n  if (seed === (seed | 0)) {\n    // Integer seed.\n    me.x = seed;\n  } else {\n    // String seed.\n    strseed += seed;\n  }\n\n  // Mix in string seed, then discard an initial batch of 64 values.\n  for (var k = 0; k < strseed.length + 64; k++) {\n    me.x ^= strseed.charCodeAt(k) | 0;\n    if (k == strseed.length) {\n      me.d = me.x << 10 ^ me.x >>> 4;\n    }\n    me.next();\n  }\n}\n\nfunction copy(f, t) {\n  t.x = f.x;\n  t.y = f.y;\n  t.z = f.z;\n  t.w = f.w;\n  t.v = f.v;\n  t.d = f.d;\n  return t;\n}\n\nfunction impl(seed, opts) {\n  var xg = new XorGen(seed),\n      state = opts && opts.state,\n      prng = function() { return (xg.next() >>> 0) / 0x100000000; };\n  prng.double = function() {\n    do {\n      var top = xg.next() >>> 11,\n          bot = (xg.next() >>> 0) / 0x100000000,\n          result = (top + bot) / (1 << 21);\n    } while (result === 0);\n    return result;\n  };\n  prng.int32 = xg.next;\n  prng.quick = prng;\n  if (state) {\n    if (typeof(state) == 'object') copy(state, xg);\n    prng.state = function() { return copy(xg, {}); }\n  }\n  return prng;\n}\n\nif (module && module.exports) {\n  module.exports = impl;\n} else if (define && define.amd) {\n  define(function() { return impl; });\n} else {\n  this.xorwow = impl;\n}\n\n})(\n  this,\n  (typeof module) == 'object' && module,    // present in node.js\n  (typeof define) == 'function' && define   // present with an AMD loader\n);\n\n\n","// A Javascript implementaion of the \"xorshift7\" algorithm by\n// François Panneton and Pierre L'ecuyer:\n// \"On the Xorgshift Random Number Generators\"\n// http://saluc.engr.uconn.edu/refs/crypto/rng/panneton05onthexorshift.pdf\n\n(function(global, module, define) {\n\nfunction XorGen(seed) {\n  var me = this;\n\n  // Set up generator function.\n  me.next = function() {\n    // Update xor generator.\n    var X = me.x, i = me.i, t, v, w;\n    t = X[i]; t ^= (t >>> 7); v = t ^ (t << 24);\n    t = X[(i + 1) & 7]; v ^= t ^ (t >>> 10);\n    t = X[(i + 3) & 7]; v ^= t ^ (t >>> 3);\n    t = X[(i + 4) & 7]; v ^= t ^ (t << 7);\n    t = X[(i + 7) & 7]; t = t ^ (t << 13); v ^= t ^ (t << 9);\n    X[i] = v;\n    me.i = (i + 1) & 7;\n    return v;\n  };\n\n  function init(me, seed) {\n    var j, w, X = [];\n\n    if (seed === (seed | 0)) {\n      // Seed state array using a 32-bit integer.\n      w = X[0] = seed;\n    } else {\n      // Seed state using a string.\n      seed = '' + seed;\n      for (j = 0; j < seed.length; ++j) {\n        X[j & 7] = (X[j & 7] << 15) ^\n            (seed.charCodeAt(j) + X[(j + 1) & 7] << 13);\n      }\n    }\n    // Enforce an array length of 8, not all zeroes.\n    while (X.length < 8) X.push(0);\n    for (j = 0; j < 8 && X[j] === 0; ++j);\n    if (j == 8) w = X[7] = -1; else w = X[j];\n\n    me.x = X;\n    me.i = 0;\n\n    // Discard an initial 256 values.\n    for (j = 256; j > 0; --j) {\n      me.next();\n    }\n  }\n\n  init(me, seed);\n}\n\nfunction copy(f, t) {\n  t.x = f.x.slice();\n  t.i = f.i;\n  return t;\n}\n\nfunction impl(seed, opts) {\n  if (seed == null) seed = +(new Date);\n  var xg = new XorGen(seed),\n      state = opts && opts.state,\n      prng = function() { return (xg.next() >>> 0) / 0x100000000; };\n  prng.double = function() {\n    do {\n      var top = xg.next() >>> 11,\n          bot = (xg.next() >>> 0) / 0x100000000,\n          result = (top + bot) / (1 << 21);\n    } while (result === 0);\n    return result;\n  };\n  prng.int32 = xg.next;\n  prng.quick = prng;\n  if (state) {\n    if (state.x) copy(state, xg);\n    prng.state = function() { return copy(xg, {}); }\n  }\n  return prng;\n}\n\nif (module && module.exports) {\n  module.exports = impl;\n} else if (define && define.amd) {\n  define(function() { return impl; });\n} else {\n  this.xorshift7 = impl;\n}\n\n})(\n  this,\n  (typeof module) == 'object' && module,    // present in node.js\n  (typeof define) == 'function' && define   // present with an AMD loader\n);\n\n","// A Javascript implementaion of Richard Brent's Xorgens xor4096 algorithm.\n//\n// This fast non-cryptographic random number generator is designed for\n// use in Monte-Carlo algorithms. It combines a long-period xorshift\n// generator with a Weyl generator, and it passes all common batteries\n// of stasticial tests for randomness while consuming only a few nanoseconds\n// for each prng generated.  For background on the generator, see Brent's\n// paper: \"Some long-period random number generators using shifts and xors.\"\n// http://arxiv.org/pdf/1004.3115v1.pdf\n//\n// Usage:\n//\n// var xor4096 = require('xor4096');\n// random = xor4096(1);                        // Seed with int32 or string.\n// assert.equal(random(), 0.1520436450538547); // (0, 1) range, 53 bits.\n// assert.equal(random.int32(), 1806534897);   // signed int32, 32 bits.\n//\n// For nonzero numeric keys, this impelementation provides a sequence\n// identical to that by Brent's xorgens 3 implementaion in C.  This\n// implementation also provides for initalizing the generator with\n// string seeds, or for saving and restoring the state of the generator.\n//\n// On Chrome, this prng benchmarks about 2.1 times slower than\n// Javascript's built-in Math.random().\n\n(function(global, module, define) {\n\nfunction XorGen(seed) {\n  var me = this;\n\n  // Set up generator function.\n  me.next = function() {\n    var w = me.w,\n        X = me.X, i = me.i, t, v;\n    // Update Weyl generator.\n    me.w = w = (w + 0x61c88647) | 0;\n    // Update xor generator.\n    v = X[(i + 34) & 127];\n    t = X[i = ((i + 1) & 127)];\n    v ^= v << 13;\n    t ^= t << 17;\n    v ^= v >>> 15;\n    t ^= t >>> 12;\n    // Update Xor generator array state.\n    v = X[i] = v ^ t;\n    me.i = i;\n    // Result is the combination.\n    return (v + (w ^ (w >>> 16))) | 0;\n  };\n\n  function init(me, seed) {\n    var t, v, i, j, w, X = [], limit = 128;\n    if (seed === (seed | 0)) {\n      // Numeric seeds initialize v, which is used to generates X.\n      v = seed;\n      seed = null;\n    } else {\n      // String seeds are mixed into v and X one character at a time.\n      seed = seed + '\\0';\n      v = 0;\n      limit = Math.max(limit, seed.length);\n    }\n    // Initialize circular array and weyl value.\n    for (i = 0, j = -32; j < limit; ++j) {\n      // Put the unicode characters into the array, and shuffle them.\n      if (seed) v ^= seed.charCodeAt((j + 32) % seed.length);\n      // After 32 shuffles, take v as the starting w value.\n      if (j === 0) w = v;\n      v ^= v << 10;\n      v ^= v >>> 15;\n      v ^= v << 4;\n      v ^= v >>> 13;\n      if (j >= 0) {\n        w = (w + 0x61c88647) | 0;     // Weyl.\n        t = (X[j & 127] ^= (v + w));  // Combine xor and weyl to init array.\n        i = (0 == t) ? i + 1 : 0;     // Count zeroes.\n      }\n    }\n    // We have detected all zeroes; make the key nonzero.\n    if (i >= 128) {\n      X[(seed && seed.length || 0) & 127] = -1;\n    }\n    // Run the generator 512 times to further mix the state before using it.\n    // Factoring this as a function slows the main generator, so it is just\n    // unrolled here.  The weyl generator is not advanced while warming up.\n    i = 127;\n    for (j = 4 * 128; j > 0; --j) {\n      v = X[(i + 34) & 127];\n      t = X[i = ((i + 1) & 127)];\n      v ^= v << 13;\n      t ^= t << 17;\n      v ^= v >>> 15;\n      t ^= t >>> 12;\n      X[i] = v ^ t;\n    }\n    // Storing state as object members is faster than using closure variables.\n    me.w = w;\n    me.X = X;\n    me.i = i;\n  }\n\n  init(me, seed);\n}\n\nfunction copy(f, t) {\n  t.i = f.i;\n  t.w = f.w;\n  t.X = f.X.slice();\n  return t;\n};\n\nfunction impl(seed, opts) {\n  if (seed == null) seed = +(new Date);\n  var xg = new XorGen(seed),\n      state = opts && opts.state,\n      prng = function() { return (xg.next() >>> 0) / 0x100000000; };\n  prng.double = function() {\n    do {\n      var top = xg.next() >>> 11,\n          bot = (xg.next() >>> 0) / 0x100000000,\n          result = (top + bot) / (1 << 21);\n    } while (result === 0);\n    return result;\n  };\n  prng.int32 = xg.next;\n  prng.quick = prng;\n  if (state) {\n    if (state.X) copy(state, xg);\n    prng.state = function() { return copy(xg, {}); }\n  }\n  return prng;\n}\n\nif (module && module.exports) {\n  module.exports = impl;\n} else if (define && define.amd) {\n  define(function() { return impl; });\n} else {\n  this.xor4096 = impl;\n}\n\n})(\n  this,                                     // window object or global\n  (typeof module) == 'object' && module,    // present in node.js\n  (typeof define) == 'function' && define   // present with an AMD loader\n);\n","// A Javascript implementaion of the \"Tyche-i\" prng algorithm by\n// Samuel Neves and Filipe Araujo.\n// See https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf\n\n(function(global, module, define) {\n\nfunction XorGen(seed) {\n  var me = this, strseed = '';\n\n  // Set up generator function.\n  me.next = function() {\n    var b = me.b, c = me.c, d = me.d, a = me.a;\n    b = (b << 25) ^ (b >>> 7) ^ c;\n    c = (c - d) | 0;\n    d = (d << 24) ^ (d >>> 8) ^ a;\n    a = (a - b) | 0;\n    me.b = b = (b << 20) ^ (b >>> 12) ^ c;\n    me.c = c = (c - d) | 0;\n    me.d = (d << 16) ^ (c >>> 16) ^ a;\n    return me.a = (a - b) | 0;\n  };\n\n  /* The following is non-inverted tyche, which has better internal\n   * bit diffusion, but which is about 25% slower than tyche-i in JS.\n  me.next = function() {\n    var a = me.a, b = me.b, c = me.c, d = me.d;\n    a = (me.a + me.b | 0) >>> 0;\n    d = me.d ^ a; d = d << 16 ^ d >>> 16;\n    c = me.c + d | 0;\n    b = me.b ^ c; b = b << 12 ^ d >>> 20;\n    me.a = a = a + b | 0;\n    d = d ^ a; me.d = d = d << 8 ^ d >>> 24;\n    me.c = c = c + d | 0;\n    b = b ^ c;\n    return me.b = (b << 7 ^ b >>> 25);\n  }\n  */\n\n  me.a = 0;\n  me.b = 0;\n  me.c = 2654435769 | 0;\n  me.d = 1367130551;\n\n  if (seed === Math.floor(seed)) {\n    // Integer seed.\n    me.a = (seed / 0x100000000) | 0;\n    me.b = seed | 0;\n  } else {\n    // String seed.\n    strseed += seed;\n  }\n\n  // Mix in string seed, then discard an initial batch of 64 values.\n  for (var k = 0; k < strseed.length + 20; k++) {\n    me.b ^= strseed.charCodeAt(k) | 0;\n    me.next();\n  }\n}\n\nfunction copy(f, t) {\n  t.a = f.a;\n  t.b = f.b;\n  t.c = f.c;\n  t.d = f.d;\n  return t;\n};\n\nfunction impl(seed, opts) {\n  var xg = new XorGen(seed),\n      state = opts && opts.state,\n      prng = function() { return (xg.next() >>> 0) / 0x100000000; };\n  prng.double = function() {\n    do {\n      var top = xg.next() >>> 11,\n          bot = (xg.next() >>> 0) / 0x100000000,\n          result = (top + bot) / (1 << 21);\n    } while (result === 0);\n    return result;\n  };\n  prng.int32 = xg.next;\n  prng.quick = prng;\n  if (state) {\n    if (typeof(state) == 'object') copy(state, xg);\n    prng.state = function() { return copy(xg, {}); }\n  }\n  return prng;\n}\n\nif (module && module.exports) {\n  module.exports = impl;\n} else if (define && define.amd) {\n  define(function() { return impl; });\n} else {\n  this.tychei = impl;\n}\n\n})(\n  this,\n  (typeof module) == 'object' && module,    // present in node.js\n  (typeof define) == 'function' && define   // present with an AMD loader\n);\n\n\n","/*\nCopyright 2019 David Bau.\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n*/\n\n(function (global, pool, math) {\n//\n// The following constants are related to IEEE 754 limits.\n//\n\nvar width = 256,        // each RC4 output is 0 <= x < 256\n    chunks = 6,         // at least six RC4 outputs for each double\n    digits = 52,        // there are 52 significant digits in a double\n    rngname = 'random', // rngname: name for Math.random and Math.seedrandom\n    startdenom = math.pow(width, chunks),\n    significance = math.pow(2, digits),\n    overflow = significance * 2,\n    mask = width - 1,\n    nodecrypto;         // node.js crypto module, initialized at the bottom.\n\n//\n// seedrandom()\n// This is the seedrandom function described above.\n//\nfunction seedrandom(seed, options, callback) {\n  var key = [];\n  options = (options == true) ? { entropy: true } : (options || {});\n\n  // Flatten the seed string or build one from local entropy if needed.\n  var shortseed = mixkey(flatten(\n    options.entropy ? [seed, tostring(pool)] :\n    (seed == null) ? autoseed() : seed, 3), key);\n\n  // Use the seed to initialize an ARC4 generator.\n  var arc4 = new ARC4(key);\n\n  // This function returns a random double in [0, 1) that contains\n  // randomness in every bit of the mantissa of the IEEE 754 value.\n  var prng = function() {\n    var n = arc4.g(chunks),             // Start with a numerator n < 2 ^ 48\n        d = startdenom,                 //   and denominator d = 2 ^ 48.\n        x = 0;                          //   and no 'extra last byte'.\n    while (n < significance) {          // Fill up all significant digits by\n      n = (n + x) * width;              //   shifting numerator and\n      d *= width;                       //   denominator and generating a\n      x = arc4.g(1);                    //   new least-significant-byte.\n    }\n    while (n >= overflow) {             // To avoid rounding up, before adding\n      n /= 2;                           //   last byte, shift everything\n      d /= 2;                           //   right using integer math until\n      x >>>= 1;                         //   we have exactly the desired bits.\n    }\n    return (n + x) / d;                 // Form the number within [0, 1).\n  };\n\n  prng.int32 = function() { return arc4.g(4) | 0; }\n  prng.quick = function() { return arc4.g(4) / 0x100000000; }\n  prng.double = prng;\n\n  // Mix the randomness into accumulated entropy.\n  mixkey(tostring(arc4.S), pool);\n\n  // Calling convention: what to return as a function of prng, seed, is_math.\n  return (options.pass || callback ||\n      function(prng, seed, is_math_call, state) {\n        if (state) {\n          // Load the arc4 state from the given state if it has an S array.\n          if (state.S) { copy(state, arc4); }\n          // Only provide the .state method if requested via options.state.\n          prng.state = function() { return copy(arc4, {}); }\n        }\n\n        // If called as a method of Math (Math.seedrandom()), mutate\n        // Math.random because that is how seedrandom.js has worked since v1.0.\n        if (is_math_call) { math[rngname] = prng; return seed; }\n\n        // Otherwise, it is a newer calling convention, so return the\n        // prng directly.\n        else return prng;\n      })(\n  prng,\n  shortseed,\n  'global' in options ? options.global : (this == math),\n  options.state);\n}\n\n//\n// ARC4\n//\n// An ARC4 implementation.  The constructor takes a key in the form of\n// an array of at most (width) integers that should be 0 <= x < (width).\n//\n// The g(count) method returns a pseudorandom integer that concatenates\n// the next (count) outputs from ARC4.  Its return value is a number x\n// that is in the range 0 <= x < (width ^ count).\n//\nfunction ARC4(key) {\n  var t, keylen = key.length,\n      me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];\n\n  // The empty key [] is treated as [0].\n  if (!keylen) { key = [keylen++]; }\n\n  // Set up S using the standard key scheduling algorithm.\n  while (i < width) {\n    s[i] = i++;\n  }\n  for (i = 0; i < width; i++) {\n    s[i] = s[j = mask & (j + key[i % keylen] + (t = s[i]))];\n    s[j] = t;\n  }\n\n  // The \"g\" method returns the next (count) outputs as one number.\n  (me.g = function(count) {\n    // Using instance members instead of closure state nearly doubles speed.\n    var t, r = 0,\n        i = me.i, j = me.j, s = me.S;\n    while (count--) {\n      t = s[i = mask & (i + 1)];\n      r = r * width + s[mask & ((s[i] = s[j = mask & (j + t)]) + (s[j] = t))];\n    }\n    me.i = i; me.j = j;\n    return r;\n    // For robust unpredictability, the function call below automatically\n    // discards an initial batch of values.  This is called RC4-drop[256].\n    // See http://google.com/search?q=rsa+fluhrer+response&btnI\n  })(width);\n}\n\n//\n// copy()\n// Copies internal state of ARC4 to or from a plain object.\n//\nfunction copy(f, t) {\n  t.i = f.i;\n  t.j = f.j;\n  t.S = f.S.slice();\n  return t;\n};\n\n//\n// flatten()\n// Converts an object tree to nested arrays of strings.\n//\nfunction flatten(obj, depth) {\n  var result = [], typ = (typeof obj), prop;\n  if (depth && typ == 'object') {\n    for (prop in obj) {\n      try { result.push(flatten(obj[prop], depth - 1)); } catch (e) {}\n    }\n  }\n  return (result.length ? result : typ == 'string' ? obj : obj + '\\0');\n}\n\n//\n// mixkey()\n// Mixes a string seed into a key that is an array of integers, and\n// returns a shortened string seed that is equivalent to the result key.\n//\nfunction mixkey(seed, key) {\n  var stringseed = seed + '', smear, j = 0;\n  while (j < stringseed.length) {\n    key[mask & j] =\n      mask & ((smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++));\n  }\n  return tostring(key);\n}\n\n//\n// autoseed()\n// Returns an object for autoseeding, using window.crypto and Node crypto\n// module if available.\n//\nfunction autoseed() {\n  try {\n    var out;\n    if (nodecrypto && (out = nodecrypto.randomBytes)) {\n      // The use of 'out' to remember randomBytes makes tight minified code.\n      out = out(width);\n    } else {\n      out = new Uint8Array(width);\n      (global.crypto || global.msCrypto).getRandomValues(out);\n    }\n    return tostring(out);\n  } catch (e) {\n    var browser = global.navigator,\n        plugins = browser && browser.plugins;\n    return [+new Date, global, plugins, global.screen, tostring(pool)];\n  }\n}\n\n//\n// tostring()\n// Converts an array of charcodes to a string\n//\nfunction tostring(a) {\n  return String.fromCharCode.apply(0, a);\n}\n\n//\n// When seedrandom.js is loaded, we immediately mix a few bits\n// from the built-in RNG into the entropy pool.  Because we do\n// not want to interfere with deterministic PRNG state later,\n// seedrandom will not call math.random on its own again after\n// initialization.\n//\nmixkey(math.random(), pool);\n\n//\n// Nodejs and AMD support: export the implementation as a module using\n// either convention.\n//\nif ((typeof module) == 'object' && module.exports) {\n  module.exports = seedrandom;\n  // When in node.js, try using crypto package for autoseeding.\n  try {\n    nodecrypto = require('crypto');\n  } catch (ex) {}\n} else if ((typeof define) == 'function' && define.amd) {\n  define(function() { return seedrandom; });\n} else {\n  // When included as a plain script, set up Math.seedrandom global.\n  math['seed' + rngname] = seedrandom;\n}\n\n\n// End anonymous scope, and pass initial values.\n})(\n  // global: `self` in browsers (including strict mode and web workers),\n  // otherwise `this` in Node and other environments\n  (typeof self !== 'undefined') ? self : this,\n  [],     // pool: entropy pool starts empty\n  Math    // math: package containing random, pow, and seedrandom\n);\n","// A library of seedable RNGs implemented in Javascript.\n//\n// Usage:\n//\n// var seedrandom = require('seedrandom');\n// var random = seedrandom(1); // or any seed.\n// var x = random();       // 0 <= x < 1.  Every bit is random.\n// var x = random.quick(); // 0 <= x < 1.  32 bits of randomness.\n\n// alea, a 53-bit multiply-with-carry generator by Johannes Baagøe.\n// Period: ~2^116\n// Reported to pass all BigCrush tests.\nvar alea = require('./lib/alea');\n\n// xor128, a pure xor-shift generator by George Marsaglia.\n// Period: 2^128-1.\n// Reported to fail: MatrixRank and LinearComp.\nvar xor128 = require('./lib/xor128');\n\n// xorwow, George Marsaglia's 160-bit xor-shift combined plus weyl.\n// Period: 2^192-2^32\n// Reported to fail: CollisionOver, SimpPoker, and LinearComp.\nvar xorwow = require('./lib/xorwow');\n\n// xorshift7, by François Panneton and Pierre L'ecuyer, takes\n// a different approach: it adds robustness by allowing more shifts\n// than Marsaglia's original three.  It is a 7-shift generator\n// with 256 bits, that passes BigCrush with no systmatic failures.\n// Period 2^256-1.\n// No systematic BigCrush failures reported.\nvar xorshift7 = require('./lib/xorshift7');\n\n// xor4096, by Richard Brent, is a 4096-bit xor-shift with a\n// very long period that also adds a Weyl generator. It also passes\n// BigCrush with no systematic failures.  Its long period may\n// be useful if you have many generators and need to avoid\n// collisions.\n// Period: 2^4128-2^32.\n// No systematic BigCrush failures reported.\nvar xor4096 = require('./lib/xor4096');\n\n// Tyche-i, by Samuel Neves and Filipe Araujo, is a bit-shifting random\n// number generator derived from ChaCha, a modern stream cipher.\n// https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf\n// Period: ~2^127\n// No systematic BigCrush failures reported.\nvar tychei = require('./lib/tychei');\n\n// The original ARC4-based prng included in this library.\n// Period: ~2^1600\nvar sr = require('./seedrandom');\n\nsr.alea = alea;\nsr.xor128 = xor128;\nsr.xorwow = xorwow;\nsr.xorshift7 = xorshift7;\nsr.xor4096 = xor4096;\nsr.tychei = tychei;\n\nmodule.exports = sr;\n","const IDENTITY = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\nconst IDENTITY_3X3 = [1, 0, 0, 0, 1, 0, 0, 0, 1];\nconst EPSILON = 1e-6;\nconst VTK_SMALL_NUMBER = 1.0e-12;\nvar Constants = {\n  IDENTITY,\n  IDENTITY_3X3,\n  EPSILON,\n  VTK_SMALL_NUMBER\n};\n\nexport { EPSILON, IDENTITY, IDENTITY_3X3, VTK_SMALL_NUMBER, Constants as default };\n","import seedrandom from 'seedrandom';\nimport { m as macro } from '../../../macros2.js';\nimport { IDENTITY, IDENTITY_3X3, VTK_SMALL_NUMBER, EPSILON } from './Constants.js';\n\nconst {\n  vtkErrorMacro,\n  vtkWarningMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n/* eslint-disable camelcase                                                  */\n/* eslint-disable no-cond-assign                                             */\n/* eslint-disable no-bitwise                                                 */\n/* eslint-disable no-multi-assign                                            */\n// ----------------------------------------------------------------------------\nlet randomSeedValue = 0;\nconst VTK_MAX_ROTATIONS = 20;\nfunction notImplemented(method) {\n  return () => vtkErrorMacro(`vtkMath::${method} - NOT IMPLEMENTED`);\n}\n\n// Swap rows for n by n matrix\nfunction swapRowsMatrix_nxn(matrix, n, row1, row2) {\n  let tmp;\n  for (let i = 0; i < n; i++) {\n    tmp = matrix[row1 * n + i];\n    matrix[row1 * n + i] = matrix[row2 * n + i];\n    matrix[row2 * n + i] = tmp;\n  }\n}\n\n// Swap columns for n by n matrix\nfunction swapColumnsMatrix_nxn(matrix, n, column1, column2) {\n  let tmp;\n  for (let i = 0; i < n; i++) {\n    tmp = matrix[i * n + column1];\n    matrix[i * n + column1] = matrix[i * n + column2];\n    matrix[i * n + column2] = tmp;\n  }\n}\n\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n\nfunction createArray() {\n  let size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 3;\n  // faster than Array.from and/or while loop\n  const res = Array(size);\n  for (let i = 0; i < size; ++i) {\n    res[i] = 0;\n  }\n  return res;\n}\nconst Pi = () => Math.PI;\nfunction radiansFromDegrees(deg) {\n  return deg / 180 * Math.PI;\n}\nfunction degreesFromRadians(rad) {\n  return rad * 180 / Math.PI;\n}\nconst {\n  round,\n  floor,\n  ceil,\n  min,\n  max\n} = Math;\nfunction arrayMin(arr) {\n  let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let stride = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  let minValue = Infinity;\n  for (let i = offset, len = arr.length; i < len; i += stride) {\n    if (arr[i] < minValue) {\n      minValue = arr[i];\n    }\n  }\n  return minValue;\n}\nfunction arrayMax(arr) {\n  let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let stride = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  let maxValue = -Infinity;\n  for (let i = offset, len = arr.length; i < len; i += stride) {\n    if (maxValue < arr[i]) {\n      maxValue = arr[i];\n    }\n  }\n  return maxValue;\n}\nfunction arrayRange(arr) {\n  let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let stride = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  let minValue = Infinity;\n  let maxValue = -Infinity;\n  for (let i = offset, len = arr.length; i < len; i += stride) {\n    if (arr[i] < minValue) {\n      minValue = arr[i];\n    }\n    if (maxValue < arr[i]) {\n      maxValue = arr[i];\n    }\n  }\n  return [minValue, maxValue];\n}\nconst ceilLog2 = notImplemented('ceilLog2');\nconst factorial = notImplemented('factorial');\nfunction nearestPowerOfTwo(xi) {\n  let v = 1;\n  while (v < xi) {\n    v *= 2;\n  }\n  return v;\n}\nfunction isPowerOfTwo(x) {\n  return x === nearestPowerOfTwo(x);\n}\nfunction binomial(m, n) {\n  let r = 1;\n  for (let i = 1; i <= n; ++i) {\n    r *= (m - i + 1) / i;\n  }\n  return Math.floor(r);\n}\nfunction beginCombination(m, n) {\n  if (m < n) {\n    return 0;\n  }\n  const r = createArray(n);\n  for (let i = 0; i < n; ++i) {\n    r[i] = i;\n  }\n  return r;\n}\nfunction nextCombination(m, n, r) {\n  let status = 0;\n  for (let i = n - 1; i >= 0; --i) {\n    if (r[i] < m - n + i) {\n      let j = r[i] + 1;\n      while (i < n) {\n        r[i++] = j++;\n      }\n      status = 1;\n      break;\n    }\n  }\n  return status;\n}\nfunction randomSeed(seed) {\n  seedrandom(`${seed}`, {\n    global: true\n  });\n  randomSeedValue = seed;\n}\nfunction getSeed() {\n  return randomSeedValue;\n}\nfunction random() {\n  let minValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  let maxValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  const delta = maxValue - minValue;\n  return minValue + delta * Math.random();\n}\nconst gaussian = notImplemented('gaussian');\n\n// Vect3 operations\nfunction add(a, b, out) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  return out;\n}\nfunction subtract(a, b, out) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  return out;\n}\nfunction multiplyScalar(vec, scalar) {\n  vec[0] *= scalar;\n  vec[1] *= scalar;\n  vec[2] *= scalar;\n  return vec;\n}\nfunction multiplyScalar2D(vec, scalar) {\n  vec[0] *= scalar;\n  vec[1] *= scalar;\n  return vec;\n}\nfunction multiplyAccumulate(a, b, scalar, out) {\n  out[0] = a[0] + b[0] * scalar;\n  out[1] = a[1] + b[1] * scalar;\n  out[2] = a[2] + b[2] * scalar;\n  return out;\n}\nfunction multiplyAccumulate2D(a, b, scalar, out) {\n  out[0] = a[0] + b[0] * scalar;\n  out[1] = a[1] + b[1] * scalar;\n  return out;\n}\nfunction dot(x, y) {\n  return x[0] * y[0] + x[1] * y[1] + x[2] * y[2];\n}\nfunction outer(x, y, out_3x3) {\n  out_3x3[0] = x[0] * y[0];\n  out_3x3[1] = x[0] * y[1];\n  out_3x3[2] = x[0] * y[2];\n  out_3x3[3] = x[1] * y[0];\n  out_3x3[4] = x[1] * y[1];\n  out_3x3[5] = x[1] * y[2];\n  out_3x3[6] = x[2] * y[0];\n  out_3x3[7] = x[2] * y[1];\n  out_3x3[8] = x[2] * y[2];\n}\nfunction cross(x, y, out) {\n  const Zx = x[1] * y[2] - x[2] * y[1];\n  const Zy = x[2] * y[0] - x[0] * y[2];\n  const Zz = x[0] * y[1] - x[1] * y[0];\n  out[0] = Zx;\n  out[1] = Zy;\n  out[2] = Zz;\n  return out;\n}\nfunction norm(x) {\n  let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;\n  switch (n) {\n    case 1:\n      return Math.abs(x);\n    case 2:\n      return Math.sqrt(x[0] * x[0] + x[1] * x[1]);\n    case 3:\n      return Math.sqrt(x[0] * x[0] + x[1] * x[1] + x[2] * x[2]);\n    default:\n      {\n        let sum = 0;\n        for (let i = 0; i < n; i++) {\n          sum += x[i] * x[i];\n        }\n        return Math.sqrt(sum);\n      }\n  }\n}\nfunction normalize(x) {\n  const den = norm(x);\n  if (den !== 0.0) {\n    x[0] /= den;\n    x[1] /= den;\n    x[2] /= den;\n  }\n  return den;\n}\nfunction perpendiculars(x, y, z, theta) {\n  const x2 = x[0] * x[0];\n  const y2 = x[1] * x[1];\n  const z2 = x[2] * x[2];\n  const r = Math.sqrt(x2 + y2 + z2);\n  let dx;\n  let dy;\n  let dz;\n\n  // transpose the vector to avoid divide-by-zero error\n  if (x2 > y2 && x2 > z2) {\n    dx = 0;\n    dy = 1;\n    dz = 2;\n  } else if (y2 > z2) {\n    dx = 1;\n    dy = 2;\n    dz = 0;\n  } else {\n    dx = 2;\n    dy = 0;\n    dz = 1;\n  }\n  const a = x[dx] / r;\n  const b = x[dy] / r;\n  const c = x[dz] / r;\n  const tmp = Math.sqrt(a * a + c * c);\n  if (theta !== 0) {\n    const sintheta = Math.sin(theta);\n    const costheta = Math.cos(theta);\n    if (y) {\n      y[dx] = (c * costheta - a * b * sintheta) / tmp;\n      y[dy] = sintheta * tmp;\n      y[dz] = (-(a * costheta) - b * c * sintheta) / tmp;\n    }\n    if (z) {\n      z[dx] = (-(c * sintheta) - a * b * costheta) / tmp;\n      z[dy] = costheta * tmp;\n      z[dz] = (a * sintheta - b * c * costheta) / tmp;\n    }\n  } else {\n    if (y) {\n      y[dx] = c / tmp;\n      y[dy] = 0;\n      y[dz] = -a / tmp;\n    }\n    if (z) {\n      z[dx] = -a * b / tmp;\n      z[dy] = tmp;\n      z[dz] = -b * c / tmp;\n    }\n  }\n}\nfunction projectVector(a, b, projection) {\n  const bSquared = dot(b, b);\n  if (bSquared === 0) {\n    projection[0] = 0;\n    projection[1] = 0;\n    projection[2] = 0;\n    return false;\n  }\n  const scale = dot(a, b) / bSquared;\n  for (let i = 0; i < 3; i++) {\n    projection[i] = b[i];\n  }\n  multiplyScalar(projection, scale);\n  return true;\n}\nfunction dot2D(x, y) {\n  return x[0] * y[0] + x[1] * y[1];\n}\nfunction projectVector2D(a, b, projection) {\n  const bSquared = dot2D(b, b);\n  if (bSquared === 0) {\n    projection[0] = 0;\n    projection[1] = 0;\n    return false;\n  }\n  const scale = dot2D(a, b) / bSquared;\n  for (let i = 0; i < 2; i++) {\n    projection[i] = b[i];\n  }\n  multiplyScalar2D(projection, scale);\n  return true;\n}\nfunction distance2BetweenPoints(x, y) {\n  return (x[0] - y[0]) * (x[0] - y[0]) + (x[1] - y[1]) * (x[1] - y[1]) + (x[2] - y[2]) * (x[2] - y[2]);\n}\nfunction angleBetweenVectors(v1, v2) {\n  const crossVect = [0, 0, 0];\n  cross(v1, v2, crossVect);\n  return Math.atan2(norm(crossVect), dot(v1, v2));\n}\nfunction signedAngleBetweenVectors(v1, v2, vN) {\n  const crossVect = [0, 0, 0];\n  cross(v1, v2, crossVect);\n  const angle = Math.atan2(norm(crossVect), dot(v1, v2));\n  return dot(crossVect, vN) >= 0 ? angle : -angle;\n}\nfunction gaussianAmplitude(mean, variance, position) {\n  const distanceFromMean = Math.abs(mean - position);\n  return 1 / Math.sqrt(2 * Math.PI * variance) * Math.exp(-(distanceFromMean ** 2) / (2 * variance));\n}\nfunction gaussianWeight(mean, variance, position) {\n  const distanceFromMean = Math.abs(mean - position);\n  return Math.exp(-(distanceFromMean ** 2) / (2 * variance));\n}\nfunction outer2D(x, y, out_2x2) {\n  out_2x2[0] = x[0] * y[0];\n  out_2x2[1] = x[0] * y[1];\n  out_2x2[2] = x[1] * y[0];\n  out_2x2[3] = x[1] * y[1];\n}\nfunction norm2D(x2D) {\n  return Math.sqrt(x2D[0] * x2D[0] + x2D[1] * x2D[1]);\n}\nfunction normalize2D(x) {\n  const den = norm2D(x);\n  if (den !== 0.0) {\n    x[0] /= den;\n    x[1] /= den;\n  }\n  return den;\n}\nfunction rowsToMat4(row0, row1, row2, row3, mat) {\n  for (let i = 0; i < 4; i++) {\n    mat[i] = row0[i];\n    mat[4 + i] = row1[i];\n    mat[8 + i] = row2[i];\n    mat[12 + i] = row3[i];\n  }\n  return mat;\n}\nfunction columnsToMat4(column0, column1, column2, column3, mat) {\n  for (let i = 0; i < 4; i++) {\n    mat[4 * i] = column0[i];\n    mat[4 * i + 1] = column1[i];\n    mat[4 * i + 2] = column2[i];\n    mat[4 * i + 3] = column3[i];\n  }\n  return mat;\n}\nfunction rowsToMat3(row0, row1, row2, mat) {\n  for (let i = 0; i < 3; i++) {\n    mat[i] = row0[i];\n    mat[3 + i] = row1[i];\n    mat[6 + i] = row2[i];\n  }\n  return mat;\n}\nfunction columnsToMat3(column0, column1, column2, mat) {\n  for (let i = 0; i < 3; i++) {\n    mat[3 * i] = column0[i];\n    mat[3 * i + 1] = column1[i];\n    mat[3 * i + 2] = column2[i];\n  }\n  return mat;\n}\nfunction determinant2x2() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n  if (args.length === 2) {\n    return args[0][0] * args[1][1] - args[1][0] * args[0][1];\n  }\n  if (args.length === 4) {\n    return args[0] * args[3] - args[1] * args[2];\n  }\n  return Number.NaN;\n}\nfunction LUFactor3x3(mat_3x3, index_3) {\n  let maxI;\n  let tmp;\n  let largest;\n  const scale = [0, 0, 0];\n\n  // Loop over rows to get implicit scaling information\n  for (let i = 0; i < 3; i++) {\n    largest = Math.abs(mat_3x3[i * 3]);\n    if ((tmp = Math.abs(mat_3x3[i * 3 + 1])) > largest) {\n      largest = tmp;\n    }\n    if ((tmp = Math.abs(mat_3x3[i * 3 + 2])) > largest) {\n      largest = tmp;\n    }\n    scale[i] = 1 / largest;\n  }\n\n  // Loop over all columns using Crout's method\n\n  // first column\n  largest = scale[0] * Math.abs(mat_3x3[0]);\n  maxI = 0;\n  if ((tmp = scale[1] * Math.abs(mat_3x3[3])) >= largest) {\n    largest = tmp;\n    maxI = 1;\n  }\n  if ((tmp = scale[2] * Math.abs(mat_3x3[6])) >= largest) {\n    maxI = 2;\n  }\n  if (maxI !== 0) {\n    swapRowsMatrix_nxn(mat_3x3, 3, maxI, 0);\n    scale[maxI] = scale[0];\n  }\n  index_3[0] = maxI;\n  mat_3x3[3] /= mat_3x3[0];\n  mat_3x3[6] /= mat_3x3[0];\n\n  // second column\n  mat_3x3[4] -= mat_3x3[3] * mat_3x3[1];\n  mat_3x3[7] -= mat_3x3[6] * mat_3x3[1];\n  largest = scale[1] * Math.abs(mat_3x3[4]);\n  maxI = 1;\n  if ((tmp = scale[2] * Math.abs(mat_3x3[7])) >= largest) {\n    maxI = 2;\n    swapRowsMatrix_nxn(mat_3x3, 3, 1, 2);\n    scale[2] = scale[1];\n  }\n  index_3[1] = maxI;\n  mat_3x3[7] /= mat_3x3[4];\n\n  // third column\n  mat_3x3[5] -= mat_3x3[3] * mat_3x3[2];\n  mat_3x3[8] -= mat_3x3[6] * mat_3x3[2] + mat_3x3[7] * mat_3x3[5];\n  index_3[2] = 2;\n}\nfunction LUSolve3x3(mat_3x3, index_3, x_3) {\n  // forward substitution\n  let sum = x_3[index_3[0]];\n  x_3[index_3[0]] = x_3[0];\n  x_3[0] = sum;\n  sum = x_3[index_3[1]];\n  x_3[index_3[1]] = x_3[1];\n  x_3[1] = sum - mat_3x3[3] * x_3[0];\n  sum = x_3[index_3[2]];\n  x_3[index_3[2]] = x_3[2];\n  x_3[2] = sum - mat_3x3[6] * x_3[0] - mat_3x3[7] * x_3[1];\n\n  // back substitution\n  x_3[2] /= mat_3x3[8];\n  x_3[1] = (x_3[1] - mat_3x3[5] * x_3[2]) / mat_3x3[4];\n  x_3[0] = (x_3[0] - mat_3x3[1] * x_3[1] - mat_3x3[2] * x_3[2]) / mat_3x3[0];\n}\nfunction linearSolve3x3(mat_3x3, x_3, y_3) {\n  const a1 = mat_3x3[0];\n  const b1 = mat_3x3[1];\n  const c1 = mat_3x3[2];\n  const a2 = mat_3x3[3];\n  const b2 = mat_3x3[4];\n  const c2 = mat_3x3[5];\n  const a3 = mat_3x3[6];\n  const b3 = mat_3x3[7];\n  const c3 = mat_3x3[8];\n\n  // Compute the adjoint\n  const d1 = +determinant2x2(b2, b3, c2, c3);\n  const d2 = -determinant2x2(a2, a3, c2, c3);\n  const d3 = +determinant2x2(a2, a3, b2, b3);\n  const e1 = -determinant2x2(b1, b3, c1, c3);\n  const e2 = +determinant2x2(a1, a3, c1, c3);\n  const e3 = -determinant2x2(a1, a3, b1, b3);\n  const f1 = +determinant2x2(b1, b2, c1, c2);\n  const f2 = -determinant2x2(a1, a2, c1, c2);\n  const f3 = +determinant2x2(a1, a2, b1, b2);\n\n  // Compute the determinant\n  const det = a1 * d1 + b1 * d2 + c1 * d3;\n\n  // Multiply by the adjoint\n  const v1 = d1 * x_3[0] + e1 * x_3[1] + f1 * x_3[2];\n  const v2 = d2 * x_3[0] + e2 * x_3[1] + f2 * x_3[2];\n  const v3 = d3 * x_3[0] + e3 * x_3[1] + f3 * x_3[2];\n\n  // Divide by the determinant\n  y_3[0] = v1 / det;\n  y_3[1] = v2 / det;\n  y_3[2] = v3 / det;\n}\nfunction multiply3x3_vect3(mat_3x3, in_3, out_3) {\n  const x = mat_3x3[0] * in_3[0] + mat_3x3[1] * in_3[1] + mat_3x3[2] * in_3[2];\n  const y = mat_3x3[3] * in_3[0] + mat_3x3[4] * in_3[1] + mat_3x3[5] * in_3[2];\n  const z = mat_3x3[6] * in_3[0] + mat_3x3[7] * in_3[1] + mat_3x3[8] * in_3[2];\n  out_3[0] = x;\n  out_3[1] = y;\n  out_3[2] = z;\n}\nfunction multiply3x3_mat3(a_3x3, b_3x3, out_3x3) {\n  const copyA = [...a_3x3];\n  const copyB = [...b_3x3];\n  for (let i = 0; i < 3; i++) {\n    out_3x3[i] = copyA[0] * copyB[i] + copyA[1] * copyB[i + 3] + copyA[2] * copyB[i + 6];\n    out_3x3[i + 3] = copyA[3] * copyB[i] + copyA[4] * copyB[i + 3] + copyA[5] * copyB[i + 6];\n    out_3x3[i + 6] = copyA[6] * copyB[i] + copyA[7] * copyB[i + 3] + copyA[8] * copyB[i + 6];\n  }\n}\nfunction multiplyMatrix(a, b, rowA, colA, rowB, colB, out_rowXcol) {\n  // we need colA == rowB\n  if (colA !== rowB) {\n    vtkErrorMacro('Number of columns of A must match number of rows of B.');\n  }\n\n  // If a or b is used to store the result, copying them is required\n  const copyA = [...a];\n  const copyB = [...b];\n  // output matrix is rowA*colB\n  // output row\n  for (let i = 0; i < rowA; i++) {\n    // output col\n    for (let j = 0; j < colB; j++) {\n      out_rowXcol[i * colB + j] = 0;\n      // sum for this point\n      for (let k = 0; k < colA; k++) {\n        out_rowXcol[i * colB + j] += copyA[i * colA + k] * copyB[j + colB * k];\n      }\n    }\n  }\n}\nfunction transpose3x3(in_3x3, outT_3x3) {\n  let tmp;\n\n  // off-diagonal elements\n  tmp = in_3x3[3];\n  outT_3x3[3] = in_3x3[1];\n  outT_3x3[1] = tmp;\n  tmp = in_3x3[6];\n  outT_3x3[6] = in_3x3[2];\n  outT_3x3[2] = tmp;\n  tmp = in_3x3[7];\n  outT_3x3[7] = in_3x3[5];\n  outT_3x3[5] = tmp;\n\n  // on-diagonal elements\n  outT_3x3[0] = in_3x3[0];\n  outT_3x3[4] = in_3x3[4];\n  outT_3x3[8] = in_3x3[8];\n}\nfunction invert3x3(in_3x3, outI_3x3) {\n  const a1 = in_3x3[0];\n  const b1 = in_3x3[1];\n  const c1 = in_3x3[2];\n  const a2 = in_3x3[3];\n  const b2 = in_3x3[4];\n  const c2 = in_3x3[5];\n  const a3 = in_3x3[6];\n  const b3 = in_3x3[7];\n  const c3 = in_3x3[8];\n\n  // Compute the adjoint\n  const d1 = +determinant2x2(b2, b3, c2, c3);\n  const d2 = -determinant2x2(a2, a3, c2, c3);\n  const d3 = +determinant2x2(a2, a3, b2, b3);\n  const e1 = -determinant2x2(b1, b3, c1, c3);\n  const e2 = +determinant2x2(a1, a3, c1, c3);\n  const e3 = -determinant2x2(a1, a3, b1, b3);\n  const f1 = +determinant2x2(b1, b2, c1, c2);\n  const f2 = -determinant2x2(a1, a2, c1, c2);\n  const f3 = +determinant2x2(a1, a2, b1, b2);\n\n  // Divide by the determinant\n  const det = a1 * d1 + b1 * d2 + c1 * d3;\n  if (det === 0) {\n    vtkWarningMacro('Matrix has 0 determinant');\n  }\n  outI_3x3[0] = d1 / det;\n  outI_3x3[3] = d2 / det;\n  outI_3x3[6] = d3 / det;\n  outI_3x3[1] = e1 / det;\n  outI_3x3[4] = e2 / det;\n  outI_3x3[7] = e3 / det;\n  outI_3x3[2] = f1 / det;\n  outI_3x3[5] = f2 / det;\n  outI_3x3[8] = f3 / det;\n}\nfunction determinant3x3(mat_3x3) {\n  return mat_3x3[0] * mat_3x3[4] * mat_3x3[8] + mat_3x3[3] * mat_3x3[7] * mat_3x3[2] + mat_3x3[6] * mat_3x3[1] * mat_3x3[5] - mat_3x3[0] * mat_3x3[7] * mat_3x3[5] - mat_3x3[3] * mat_3x3[1] * mat_3x3[8] - mat_3x3[6] * mat_3x3[4] * mat_3x3[2];\n}\n\n/**\n * Returns true if elements of both arrays are equals.\n * @param {Array} a an array of numbers (vector, point, matrix...)\n * @param {Array} b an array of numbers (vector, point, matrix...)\n * @param {Number} eps tolerance\n */\nfunction areEquals(a, b) {\n  let eps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : EPSILON;\n  if (a.length !== b.length) {\n    return false;\n  }\n  function isEqual(element, index) {\n    return Math.abs(element - b[index]) <= eps;\n  }\n  return a.every(isEqual);\n}\nconst areMatricesEqual = areEquals;\nfunction identity3x3(mat_3x3) {\n  for (let i = 0; i < 3; i++) {\n    /* eslint-disable-next-line no-multi-assign */\n    mat_3x3[i * 3] = mat_3x3[i * 3 + 1] = mat_3x3[i * 3 + 2] = 0;\n    mat_3x3[i * 3 + i] = 1;\n  }\n}\nfunction identity(n, mat) {\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < n; j++) {\n      mat[i * n + j] = 0;\n    }\n    mat[i * n + i] = 1;\n  }\n  return mat;\n}\nfunction isIdentity(mat) {\n  let eps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EPSILON;\n  return areMatricesEqual(mat, IDENTITY, eps);\n}\nfunction isIdentity3x3(mat) {\n  let eps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EPSILON;\n  return areMatricesEqual(mat, IDENTITY_3X3, eps);\n}\nfunction quaternionToMatrix3x3(quat_4, mat_3x3) {\n  const ww = quat_4[0] * quat_4[0];\n  const wx = quat_4[0] * quat_4[1];\n  const wy = quat_4[0] * quat_4[2];\n  const wz = quat_4[0] * quat_4[3];\n  const xx = quat_4[1] * quat_4[1];\n  const yy = quat_4[2] * quat_4[2];\n  const zz = quat_4[3] * quat_4[3];\n  const xy = quat_4[1] * quat_4[2];\n  const xz = quat_4[1] * quat_4[3];\n  const yz = quat_4[2] * quat_4[3];\n  const rr = xx + yy + zz;\n  // normalization factor, just in case quaternion was not normalized\n  let f = 1 / (ww + rr);\n  const s = (ww - rr) * f;\n  f *= 2;\n  mat_3x3[0] = xx * f + s;\n  mat_3x3[3] = (xy + wz) * f;\n  mat_3x3[6] = (xz - wy) * f;\n  mat_3x3[1] = (xy - wz) * f;\n  mat_3x3[4] = yy * f + s;\n  mat_3x3[7] = (yz + wx) * f;\n  mat_3x3[2] = (xz + wy) * f;\n  mat_3x3[5] = (yz - wx) * f;\n  mat_3x3[8] = zz * f + s;\n}\nfunction roundNumber(num) {\n  let digits = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  if (!`${num}`.includes('e')) {\n    return +`${Math.round(`${num}e+${digits}`)}e-${digits}`;\n  }\n  const arr = `${num}`.split('e');\n  let sig = '';\n  if (+arr[1] + digits > 0) {\n    sig = '+';\n  }\n  return +`${Math.round(`${+arr[0]}e${sig}${+arr[1] + digits}`)}e-${digits}`;\n}\nfunction roundVector(vector) {\n  let out = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];\n  let digits = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  out[0] = roundNumber(vector[0], digits);\n  out[1] = roundNumber(vector[1], digits);\n  out[2] = roundNumber(vector[2], digits);\n  return out;\n}\nfunction jacobiN(a, n, w, v) {\n  let i;\n  let j;\n  let k;\n  let iq;\n  let ip;\n  let numPos;\n  let tresh;\n  let theta;\n  let t;\n  let tau;\n  let sm;\n  let s;\n  let h;\n  let g;\n  let c;\n  let tmp;\n  const b = createArray(n);\n  const z = createArray(n);\n  const vtkROTATE = (aa, ii, jj) => {\n    g = aa[ii];\n    h = aa[jj];\n    aa[ii] = g - s * (h + g * tau);\n    aa[jj] = h + s * (g - h * tau);\n  };\n\n  // initialize\n  identity(n, v);\n  for (ip = 0; ip < n; ip++) {\n    b[ip] = w[ip] = a[ip + ip * n];\n    z[ip] = 0.0;\n  }\n\n  // begin rotation sequence\n  for (i = 0; i < VTK_MAX_ROTATIONS; i++) {\n    sm = 0.0;\n    for (ip = 0; ip < n - 1; ip++) {\n      for (iq = ip + 1; iq < n; iq++) {\n        sm += Math.abs(a[ip * n + iq]);\n      }\n    }\n    if (sm === 0.0) {\n      break;\n    }\n\n    // first 3 sweeps\n    if (i < 3) {\n      tresh = 0.2 * sm / (n * n);\n    } else {\n      tresh = 0.0;\n    }\n    for (ip = 0; ip < n - 1; ip++) {\n      for (iq = ip + 1; iq < n; iq++) {\n        g = 100.0 * Math.abs(a[ip * n + iq]);\n\n        // after 4 sweeps\n        if (i > 3 && Math.abs(w[ip]) + g === Math.abs(w[ip]) && Math.abs(w[iq]) + g === Math.abs(w[iq])) {\n          a[ip * n + iq] = 0.0;\n        } else if (Math.abs(a[ip * n + iq]) > tresh) {\n          h = w[iq] - w[ip];\n          if (Math.abs(h) + g === Math.abs(h)) {\n            t = a[ip * n + iq] / h;\n          } else {\n            theta = 0.5 * h / a[ip * n + iq];\n            t = 1.0 / (Math.abs(theta) + Math.sqrt(1.0 + theta * theta));\n            if (theta < 0.0) {\n              t = -t;\n            }\n          }\n          c = 1.0 / Math.sqrt(1 + t * t);\n          s = t * c;\n          tau = s / (1.0 + c);\n          h = t * a[ip * n + iq];\n          z[ip] -= h;\n          z[iq] += h;\n          w[ip] -= h;\n          w[iq] += h;\n          a[ip * n + iq] = 0.0;\n\n          // ip already shifted left by 1 unit\n          for (j = 0; j <= ip - 1; j++) {\n            vtkROTATE(a, j * n + ip, j * n + iq);\n          }\n          // ip and iq already shifted left by 1 unit\n          for (j = ip + 1; j <= iq - 1; j++) {\n            vtkROTATE(a, ip * n + j, j * n + iq);\n          }\n          // iq already shifted left by 1 unit\n          for (j = iq + 1; j < n; j++) {\n            vtkROTATE(a, ip * n + j, iq * n + j);\n          }\n          for (j = 0; j < n; j++) {\n            vtkROTATE(v, j * n + ip, j * n + iq);\n          }\n        }\n      }\n    }\n    for (ip = 0; ip < n; ip++) {\n      b[ip] += z[ip];\n      w[ip] = b[ip];\n      z[ip] = 0.0;\n    }\n  }\n\n  // this is NEVER called\n  if (i >= VTK_MAX_ROTATIONS) {\n    vtkWarningMacro('vtkMath::Jacobi: Error extracting eigenfunctions');\n    return 0;\n  }\n\n  // sort eigenfunctions: these changes do not affect accuracy\n  for (j = 0; j < n - 1; j++) {\n    // boundary incorrect\n    k = j;\n    tmp = w[k];\n    for (i = j + 1; i < n; i++) {\n      // boundary incorrect, shifted already\n      if (w[i] >= tmp || Math.abs(w[i] - tmp) < VTK_SMALL_NUMBER) {\n        // why exchange if same?\n        k = i;\n        tmp = w[k];\n      }\n    }\n    if (k !== j) {\n      w[k] = w[j];\n      w[j] = tmp;\n      swapColumnsMatrix_nxn(v, n, j, k);\n    }\n  }\n  // ensure eigenvector consistency (i.e., Jacobi can compute vectors that\n  // are negative of one another (.707,.707,0) and (-.707,-.707,0). This can\n  // reek havoc in hyperstreamline/other stuff. We will select the most\n  // positive eigenvector.\n  const ceil_half_n = (n >> 1) + (n & 1);\n  for (numPos = 0, i = 0; i < n * n; i++) {\n    if (v[i] >= 0.0) {\n      numPos++;\n    }\n  }\n  //    if ( numPos < ceil(double(n)/double(2.0)) )\n  if (numPos < ceil_half_n) {\n    for (i = 0; i < n; i++) {\n      v[i * n + j] *= -1.0;\n    }\n  }\n  return 1;\n}\nfunction matrix3x3ToQuaternion(mat_3x3, quat_4) {\n  const tmp = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n\n  // on-diagonal elements\n  tmp[0] = mat_3x3[0] + mat_3x3[4] + mat_3x3[8];\n  tmp[5] = mat_3x3[0] - mat_3x3[4] - mat_3x3[8];\n  tmp[10] = -mat_3x3[0] + mat_3x3[4] - mat_3x3[8];\n  tmp[15] = -mat_3x3[0] - mat_3x3[4] + mat_3x3[8];\n\n  // off-diagonal elements\n  tmp[1] = tmp[4] = mat_3x3[7] - mat_3x3[5];\n  tmp[2] = tmp[8] = mat_3x3[2] - mat_3x3[6];\n  tmp[3] = tmp[12] = mat_3x3[3] - mat_3x3[1];\n  tmp[6] = tmp[9] = mat_3x3[3] + mat_3x3[1];\n  tmp[7] = tmp[13] = mat_3x3[2] + mat_3x3[6];\n  tmp[11] = tmp[14] = mat_3x3[7] + mat_3x3[5];\n  const eigenvectors = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n  const eigenvalues = [0, 0, 0, 0];\n\n  // convert into format that JacobiN can use,\n  // then use Jacobi to find eigenvalues and eigenvectors\n  // tmp is copied because jacobiN may modify it\n  const NTemp = [...tmp];\n  jacobiN(NTemp, 4, eigenvalues, eigenvectors);\n\n  // the first eigenvector is the one we want\n  quat_4[0] = eigenvectors[0];\n  quat_4[1] = eigenvectors[4];\n  quat_4[2] = eigenvectors[8];\n  quat_4[3] = eigenvectors[12];\n}\nfunction multiplyQuaternion(quat_1, quat_2, quat_out) {\n  const ww = quat_1[0] * quat_2[0];\n  const wx = quat_1[0] * quat_2[1];\n  const wy = quat_1[0] * quat_2[2];\n  const wz = quat_1[0] * quat_2[3];\n  const xw = quat_1[1] * quat_2[0];\n  const xx = quat_1[1] * quat_2[1];\n  const xy = quat_1[1] * quat_2[2];\n  const xz = quat_1[1] * quat_2[3];\n  const yw = quat_1[2] * quat_2[0];\n  const yx = quat_1[2] * quat_2[1];\n  const yy = quat_1[2] * quat_2[2];\n  const yz = quat_1[2] * quat_2[3];\n  const zw = quat_1[3] * quat_2[0];\n  const zx = quat_1[3] * quat_2[1];\n  const zy = quat_1[3] * quat_2[2];\n  const zz = quat_1[3] * quat_2[3];\n  quat_out[0] = ww - xx - yy - zz;\n  quat_out[1] = wx + xw + yz - zy;\n  quat_out[2] = wy - xz + yw + zx;\n  quat_out[3] = wz + xy - yx + zw;\n}\nfunction orthogonalize3x3(a_3x3, out_3x3) {\n  // copy the matrix\n  for (let i = 0; i < 9; i++) {\n    out_3x3[i] = a_3x3[i];\n  }\n\n  // Pivot the matrix to improve accuracy\n  const scale = createArray(3);\n  const index = createArray(3);\n  let largest;\n\n  // Loop over rows to get implicit scaling information\n  for (let i = 0; i < 3; i++) {\n    const x1 = Math.abs(out_3x3[i * 3]);\n    const x2 = Math.abs(out_3x3[i * 3 + 1]);\n    const x3 = Math.abs(out_3x3[i * 3 + 2]);\n    largest = x2 > x1 ? x2 : x1;\n    largest = x3 > largest ? x3 : largest;\n    scale[i] = 1;\n    if (largest !== 0) {\n      scale[i] /= largest;\n    }\n  }\n\n  // first column\n  const x1 = Math.abs(out_3x3[0]) * scale[0];\n  const x2 = Math.abs(out_3x3[3]) * scale[1];\n  const x3 = Math.abs(out_3x3[6]) * scale[2];\n  index[0] = 0;\n  largest = x1;\n  if (x2 >= largest) {\n    largest = x2;\n    index[0] = 1;\n  }\n  if (x3 >= largest) {\n    index[0] = 2;\n  }\n  if (index[0] !== 0) {\n    // swap vectors\n    swapColumnsMatrix_nxn(out_3x3, 3, index[0], 0);\n    scale[index[0]] = scale[0];\n  }\n\n  // second column\n  const y2 = Math.abs(out_3x3[4]) * scale[1];\n  const y3 = Math.abs(out_3x3[7]) * scale[2];\n  index[1] = 1;\n  largest = y2;\n  if (y3 >= largest) {\n    index[1] = 2;\n    // swap vectors\n    swapColumnsMatrix_nxn(out_3x3, 3, 1, 2);\n  }\n\n  // third column\n  index[2] = 2;\n\n  // A quaternion can only describe a pure rotation, not\n  // a rotation with a flip, therefore the flip must be\n  // removed before the matrix is converted to a quaternion.\n  let flip = 0;\n  if (determinant3x3(out_3x3) < 0) {\n    flip = 1;\n    for (let i = 0; i < 9; i++) {\n      out_3x3[i] = -out_3x3[i];\n    }\n  }\n\n  // Do orthogonalization using a quaternion intermediate\n  // (this, essentially, does the orthogonalization via\n  // diagonalization of an appropriately constructed symmetric\n  // 4x4 matrix rather than by doing SVD of the 3x3 matrix)\n  const quat = createArray(4);\n  matrix3x3ToQuaternion(out_3x3, quat);\n  quaternionToMatrix3x3(quat, out_3x3);\n\n  // Put the flip back into the orthogonalized matrix.\n  if (flip) {\n    for (let i = 0; i < 9; i++) {\n      out_3x3[i] = -out_3x3[i];\n    }\n  }\n\n  // Undo the pivoting\n  if (index[1] !== 1) {\n    swapColumnsMatrix_nxn(out_3x3, 3, index[1], 1);\n  }\n  if (index[0] !== 0) {\n    swapColumnsMatrix_nxn(out_3x3, 3, index[0], 0);\n  }\n}\nfunction diagonalize3x3(a_3x3, w_3, v_3x3) {\n  let i;\n  let j;\n  let k;\n  let maxI;\n  let tmp;\n  let maxVal;\n\n  // a is copied because jacobiN may modify it\n  const copyA = [...a_3x3];\n\n  // diagonalize using Jacobi\n  jacobiN(copyA, 3, w_3, v_3x3);\n\n  // if all the eigenvalues are the same, return identity matrix\n  if (w_3[0] === w_3[1] && w_3[0] === w_3[2]) {\n    identity3x3(v_3x3);\n    return;\n  }\n\n  // transpose temporarily, it makes it easier to sort the eigenvectors\n  transpose3x3(v_3x3, v_3x3);\n\n  // if two eigenvalues are the same, re-orthogonalize to optimally line\n  // up the eigenvectors with the x, y, and z axes\n  for (i = 0; i < 3; i++) {\n    // two eigenvalues are the same\n    if (w_3[(i + 1) % 3] === w_3[(i + 2) % 3]) {\n      // find maximum element of the independent eigenvector\n      maxVal = Math.abs(v_3x3[i * 3]);\n      maxI = 0;\n      for (j = 1; j < 3; j++) {\n        if (maxVal < (tmp = Math.abs(v_3x3[i * 3 + j]))) {\n          maxVal = tmp;\n          maxI = j;\n        }\n      }\n      // swap the eigenvector into its proper position\n      if (maxI !== i) {\n        tmp = w_3[maxI];\n        w_3[maxI] = w_3[i];\n        w_3[i] = tmp;\n        swapRowsMatrix_nxn(v_3x3, 3, i, maxI);\n      }\n      // maximum element of eigenvector should be positive\n      if (v_3x3[maxI * 3 + maxI] < 0) {\n        v_3x3[maxI * 3] = -v_3x3[maxI * 3];\n        v_3x3[maxI * 3 + 1] = -v_3x3[maxI * 3 + 1];\n        v_3x3[maxI * 3 + 2] = -v_3x3[maxI * 3 + 2];\n      }\n\n      // re-orthogonalize the other two eigenvectors\n      j = (maxI + 1) % 3;\n      k = (maxI + 2) % 3;\n      v_3x3[j * 3] = 0.0;\n      v_3x3[j * 3 + 1] = 0.0;\n      v_3x3[j * 3 + 2] = 0.0;\n      v_3x3[j * 3 + j] = 1.0;\n      const vectTmp1 = cross([v_3x3[maxI * 3], v_3x3[maxI * 3 + 1], v_3x3[maxI * 3 + 2]], [v_3x3[j * 3], v_3x3[j * 3 + 1], v_3x3[j * 3 + 2]], []);\n      normalize(vectTmp1);\n      const vectTmp2 = cross(vectTmp1, [v_3x3[maxI * 3], v_3x3[maxI * 3 + 1], v_3x3[maxI * 3 + 2]], []);\n      for (let t = 0; t < 3; t++) {\n        v_3x3[k * 3 + t] = vectTmp1[t];\n        v_3x3[j * 3 + t] = vectTmp2[t];\n      }\n\n      // transpose vectors back to columns\n      transpose3x3(v_3x3, v_3x3);\n      return;\n    }\n  }\n\n  // the three eigenvalues are different, just sort the eigenvectors\n  // to align them with the x, y, and z axes\n\n  // find the vector with the largest x element, make that vector\n  // the first vector\n  maxVal = Math.abs(v_3x3[0]);\n  maxI = 0;\n  for (i = 1; i < 3; i++) {\n    if (maxVal < (tmp = Math.abs(v_3x3[i * 3]))) {\n      maxVal = tmp;\n      maxI = i;\n    }\n  }\n  // swap eigenvalue and eigenvector\n  if (maxI !== 0) {\n    const eigenValTmp = w_3[maxI];\n    w_3[maxI] = w_3[0];\n    w_3[0] = eigenValTmp;\n    swapRowsMatrix_nxn(v_3x3, 3, maxI, 0);\n  }\n  // do the same for the y element\n  if (Math.abs(v_3x3[4]) < Math.abs(v_3x3[7])) {\n    const eigenValTmp = w_3[2];\n    w_3[2] = w_3[1];\n    w_3[1] = eigenValTmp;\n    swapRowsMatrix_nxn(v_3x3, 3, 1, 2);\n  }\n\n  // ensure that the sign of the eigenvectors is correct\n  for (i = 0; i < 2; i++) {\n    if (v_3x3[i * 3 + i] < 0) {\n      v_3x3[i * 3] = -v_3x3[i * 3];\n      v_3x3[i * 3 + 1] = -v_3x3[i * 3 + 1];\n      v_3x3[i * 3 + 2] = -v_3x3[i * 3 + 2];\n    }\n  }\n  // set sign of final eigenvector to ensure that determinant is positive\n  if (determinant3x3(v_3x3) < 0) {\n    v_3x3[6] = -v_3x3[6];\n    v_3x3[7] = -v_3x3[7];\n    v_3x3[8] = -v_3x3[8];\n  }\n\n  // transpose the eigenvectors back again\n  transpose3x3(v_3x3, v_3x3);\n}\nfunction singularValueDecomposition3x3(a_3x3, u_3x3, w_3, vT_3x3) {\n  let i;\n  // copy so that A can be used for U or VT without risk\n  const B = [...a_3x3];\n\n  // temporarily flip if determinant is negative\n  const d = determinant3x3(B);\n  if (d < 0) {\n    for (i = 0; i < 9; i++) {\n      B[i] = -B[i];\n    }\n  }\n\n  // orthogonalize, diagonalize, etc.\n  orthogonalize3x3(B, u_3x3);\n  transpose3x3(B, B);\n  multiply3x3_mat3(B, u_3x3, vT_3x3);\n  diagonalize3x3(vT_3x3, w_3, vT_3x3);\n  multiply3x3_mat3(u_3x3, vT_3x3, u_3x3);\n  transpose3x3(vT_3x3, vT_3x3);\n\n  // re-create the flip\n  if (d < 0) {\n    w_3[0] = -w_3[0];\n    w_3[1] = -w_3[1];\n    w_3[2] = -w_3[2];\n  }\n}\n\n/**\n * Factor linear equations Ax = b using LU decomposition A = LU. Output factorization LU is in matrix A.\n * @param {Matrix} A square matrix\n * @param {Number} index integer array of pivot indices index[0->n-1]\n * @param {Number} size matrix size\n */\nfunction luFactorLinearSystem(A, index, size) {\n  let i;\n  let j;\n  let k;\n  let largest;\n  let maxI = 0;\n  let sum;\n  let temp1;\n  let temp2;\n  const scale = createArray(size);\n\n  //\n  // Loop over rows to get implicit scaling information\n  //\n  for (i = 0; i < size; i++) {\n    for (largest = 0.0, j = 0; j < size; j++) {\n      if ((temp2 = Math.abs(A[i * size + j])) > largest) {\n        largest = temp2;\n      }\n    }\n    if (largest === 0.0) {\n      vtkWarningMacro('Unable to factor linear system');\n      return 0;\n    }\n    scale[i] = 1.0 / largest;\n  }\n  //\n  // Loop over all columns using Crout's method\n  //\n  for (j = 0; j < size; j++) {\n    for (i = 0; i < j; i++) {\n      sum = A[i * size + j];\n      for (k = 0; k < i; k++) {\n        sum -= A[i * size + k] * A[k * size + j];\n      }\n      A[i * size + j] = sum;\n    }\n    //\n    // Begin search for largest pivot element\n    //\n    for (largest = 0.0, i = j; i < size; i++) {\n      sum = A[i * size + j];\n      for (k = 0; k < j; k++) {\n        sum -= A[i * size + k] * A[k * size + j];\n      }\n      A[i * size + j] = sum;\n      if ((temp1 = scale[i] * Math.abs(sum)) >= largest) {\n        largest = temp1;\n        maxI = i;\n      }\n    }\n    //\n    // Check for row interchange\n    //\n    if (j !== maxI) {\n      for (k = 0; k < size; k++) {\n        temp1 = A[maxI * size + k];\n        A[maxI * size + k] = A[j * size + k];\n        A[j * size + k] = temp1;\n      }\n      scale[maxI] = scale[j];\n    }\n    //\n    // Divide by pivot element and perform elimination\n    //\n    index[j] = maxI;\n    if (Math.abs(A[j * size + j]) <= VTK_SMALL_NUMBER) {\n      vtkWarningMacro('Unable to factor linear system');\n      return 0;\n    }\n    if (j !== size - 1) {\n      temp1 = 1.0 / A[j * size + j];\n      for (i = j + 1; i < size; i++) {\n        A[i * size + j] *= temp1;\n      }\n    }\n  }\n  return 1;\n}\nfunction luSolveLinearSystem(A, index, x, size) {\n  let i;\n  let j;\n  let ii;\n  let idx;\n  let sum;\n  //\n  // Proceed with forward and backsubstitution for L and U\n  // matrices.  First, forward substitution.\n  //\n  for (ii = -1, i = 0; i < size; i++) {\n    idx = index[i];\n    sum = x[idx];\n    x[idx] = x[i];\n    if (ii >= 0) {\n      for (j = ii; j <= i - 1; j++) {\n        sum -= A[i * size + j] * x[j];\n      }\n    } else if (sum !== 0.0) {\n      ii = i;\n    }\n    x[i] = sum;\n  }\n  //\n  // Now, back substitution\n  //\n  for (i = size - 1; i >= 0; i--) {\n    sum = x[i];\n    for (j = i + 1; j < size; j++) {\n      sum -= A[i * size + j] * x[j];\n    }\n    x[i] = sum / A[i * size + i];\n  }\n}\nfunction solveLinearSystem(A, x, size) {\n  // if we solving something simple, just solve it\n  if (size === 2) {\n    const y = createArray(2);\n    const det = determinant2x2(A[0], A[1], A[2], A[3]);\n    if (det === 0.0) {\n      // Unable to solve linear system\n      return 0;\n    }\n    y[0] = (A[3] * x[0] - A[1] * x[1]) / det;\n    y[1] = (-(A[2] * x[0]) + A[0] * x[1]) / det;\n    x[0] = y[0];\n    x[1] = y[1];\n    return 1;\n  }\n  if (size === 1) {\n    if (A[0] === 0.0) {\n      // Unable to solve linear system\n      return 0;\n    }\n    x[0] /= A[0];\n    return 1;\n  }\n\n  //\n  // System of equations is not trivial, use Crout's method\n  //\n\n  // Check on allocation of working vectors\n  const index = createArray(size);\n\n  // Factor and solve matrix\n  if (luFactorLinearSystem(A, index, size) === 0) {\n    return 0;\n  }\n  luSolveLinearSystem(A, index, x, size);\n  return 1;\n}\n\n// Note that A is modified during the inversion !\nfunction invertMatrix(A, AI, size) {\n  let index = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  let column = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  const tmp1Size = index || createArray(size);\n  const tmp2Size = column || createArray(size);\n\n  // Factor matrix; then begin solving for inverse one column at a time.\n  // Note: tmp1Size returned value is used later, tmp2Size is just working\n  // memory whose values are not used in LUSolveLinearSystem\n  if (luFactorLinearSystem(A, tmp1Size, size) === 0) {\n    return null;\n  }\n  for (let j = 0; j < size; j++) {\n    for (let i = 0; i < size; i++) {\n      tmp2Size[i] = 0.0;\n    }\n    tmp2Size[j] = 1.0;\n    luSolveLinearSystem(A, tmp1Size, tmp2Size, size);\n    for (let i = 0; i < size; i++) {\n      AI[i * size + j] = tmp2Size[i];\n    }\n  }\n  return AI;\n}\nfunction estimateMatrixCondition(A, size) {\n  let minValue = +Number.MAX_VALUE;\n  let maxValue = -Number.MAX_VALUE;\n\n  // find the maximum value\n  for (let i = 0; i < size; i++) {\n    for (let j = i; j < size; j++) {\n      if (Math.abs(A[i * size + j]) > maxValue) {\n        maxValue = Math.abs(A[i * size + j]);\n      }\n    }\n  }\n\n  // find the minimum diagonal value\n  for (let i = 0; i < size; i++) {\n    if (Math.abs(A[i * size + i]) < minValue) {\n      minValue = Math.abs(A[i * size + i]);\n    }\n  }\n  if (minValue === 0.0) {\n    return Number.MAX_VALUE;\n  }\n  return maxValue / minValue;\n}\nfunction jacobi(a_3x3, w, v) {\n  return jacobiN(a_3x3, 3, w, v);\n}\nfunction solveHomogeneousLeastSquares(numberOfSamples, xt, xOrder, mt) {\n  // check dimensional consistency\n  if (numberOfSamples < xOrder) {\n    vtkWarningMacro('Insufficient number of samples. Underdetermined.');\n    return 0;\n  }\n  let i;\n  let j;\n  let k;\n\n  // set up intermediate variables\n  // Allocate matrix to hold X times transpose of X\n  const XXt = createArray(xOrder * xOrder); // size x by x\n  // Allocate the array of eigenvalues and eigenvectors\n  const eigenvals = createArray(xOrder);\n  const eigenvecs = createArray(xOrder * xOrder);\n\n  // Calculate XXt upper half only, due to symmetry\n  for (k = 0; k < numberOfSamples; k++) {\n    for (i = 0; i < xOrder; i++) {\n      for (j = i; j < xOrder; j++) {\n        XXt[i * xOrder + j] += xt[k * xOrder + i] * xt[k * xOrder + j];\n      }\n    }\n  }\n\n  // now fill in the lower half of the XXt matrix\n  for (i = 0; i < xOrder; i++) {\n    for (j = 0; j < i; j++) {\n      XXt[i * xOrder + j] = XXt[j * xOrder + i];\n    }\n  }\n\n  // Compute the eigenvectors and eigenvalues\n  jacobiN(XXt, xOrder, eigenvals, eigenvecs);\n\n  // Smallest eigenval is at the end of the list (xOrder-1), and solution is\n  // corresponding eigenvec.\n  for (i = 0; i < xOrder; i++) {\n    mt[i] = eigenvecs[i * xOrder + xOrder - 1];\n  }\n  return 1;\n}\nfunction solveLeastSquares(numberOfSamples, xt, xOrder, yt, yOrder, mt) {\n  let checkHomogeneous = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : true;\n  // check dimensional consistency\n  if (numberOfSamples < xOrder || numberOfSamples < yOrder) {\n    vtkWarningMacro('Insufficient number of samples. Underdetermined.');\n    return 0;\n  }\n  const homogenFlags = createArray(yOrder);\n  let allHomogeneous = 1;\n  let hmt;\n  let homogRC = 0;\n  let i;\n  let j;\n  let k;\n  let someHomogeneous = 0;\n\n  // Ok, first init some flags check and see if all the systems are homogeneous\n  if (checkHomogeneous) {\n    // If Y' is zero, it's a homogeneous system and can't be solved via\n    // the pseudoinverse method. Detect this case, warn the user, and\n    // invoke SolveHomogeneousLeastSquares instead. Note that it doesn't\n    // really make much sense for yOrder to be greater than one in this case,\n    // since that's just yOrder occurrences of a 0 vector on the RHS, but\n    // we allow it anyway. N\n\n    // Initialize homogeneous flags on a per-right-hand-side basis\n    for (j = 0; j < yOrder; j++) {\n      homogenFlags[j] = 1;\n    }\n    for (i = 0; i < numberOfSamples; i++) {\n      for (j = 0; j < yOrder; j++) {\n        if (Math.abs(yt[i * yOrder + j]) > VTK_SMALL_NUMBER) {\n          allHomogeneous = 0;\n          homogenFlags[j] = 0;\n        }\n      }\n    }\n\n    // If we've got one system, and it's homogeneous, do it and bail out quickly.\n    if (allHomogeneous && yOrder === 1) {\n      vtkWarningMacro('Detected homogeneous system (Y=0), calling SolveHomogeneousLeastSquares()');\n      return solveHomogeneousLeastSquares(numberOfSamples, xt, xOrder, mt);\n    }\n\n    // Ok, we've got more than one system of equations.\n    // Figure out if we need to calculate the homogeneous equation solution for\n    // any of them.\n    if (allHomogeneous) {\n      someHomogeneous = 1;\n    } else {\n      for (j = 0; j < yOrder; j++) {\n        if (homogenFlags[j]) {\n          someHomogeneous = 1;\n        }\n      }\n    }\n  }\n\n  // If necessary, solve the homogeneous problem\n  if (someHomogeneous) {\n    // hmt is the homogeneous equation version of mt, the general solution.\n    // hmt should be xOrder x yOrder, but since we are solving only the homogeneous part, here it is xOrder x 1\n    hmt = createArray(xOrder);\n\n    // Ok, solve the homogeneous problem\n    homogRC = solveHomogeneousLeastSquares(numberOfSamples, xt, xOrder, hmt);\n  }\n\n  // set up intermediate variables\n  const XXt = createArray(xOrder * xOrder); // size x by x\n  const XXtI = createArray(xOrder * xOrder); // size x by x\n  const XYt = createArray(xOrder * yOrder); // size x by y\n\n  // first find the pseudoinverse matrix\n  for (k = 0; k < numberOfSamples; k++) {\n    for (i = 0; i < xOrder; i++) {\n      // first calculate the XXt matrix, only do the upper half (symmetrical)\n      for (j = i; j < xOrder; j++) {\n        XXt[i * xOrder + j] += xt[k * xOrder + i] * xt[k * xOrder + j];\n      }\n\n      // now calculate the XYt matrix\n      for (j = 0; j < yOrder; j++) {\n        XYt[i * yOrder + j] += xt[k * xOrder + i] * yt[k * yOrder + j];\n      }\n    }\n  }\n\n  // now fill in the lower half of the XXt matrix\n  for (i = 0; i < xOrder; i++) {\n    for (j = 0; j < i; j++) {\n      XXt[i * xOrder + j] = XXt[j * xOrder + i];\n    }\n  }\n  const successFlag = invertMatrix(XXt, XXtI, xOrder);\n\n  // next get the inverse of XXt\n  if (successFlag) {\n    for (i = 0; i < xOrder; i++) {\n      for (j = 0; j < yOrder; j++) {\n        mt[i * yOrder + j] = 0.0;\n        for (k = 0; k < xOrder; k++) {\n          mt[i * yOrder + j] += XXtI[i * xOrder + k] * XYt[k * yOrder + j];\n        }\n      }\n    }\n  }\n\n  // Fix up any of the solutions that correspond to the homogeneous equation\n  // problem.\n  if (someHomogeneous) {\n    for (j = 0; j < yOrder; j++) {\n      if (homogenFlags[j]) {\n        // Fix this one\n        for (i = 0; i < xOrder; i++) {\n          mt[i * yOrder + j] = hmt[i * yOrder];\n        }\n      }\n    }\n  }\n  if (someHomogeneous) {\n    return homogRC && successFlag;\n  }\n  return successFlag;\n}\nfunction hex2float(hexStr) {\n  let outFloatArray = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0.5, 1];\n  switch (hexStr.length) {\n    case 3:\n      // abc => #aabbcc\n      outFloatArray[0] = parseInt(hexStr[0], 16) * 17 / 255;\n      outFloatArray[1] = parseInt(hexStr[1], 16) * 17 / 255;\n      outFloatArray[2] = parseInt(hexStr[2], 16) * 17 / 255;\n      return outFloatArray;\n    case 4:\n      // #abc => #aabbcc\n      outFloatArray[0] = parseInt(hexStr[1], 16) * 17 / 255;\n      outFloatArray[1] = parseInt(hexStr[2], 16) * 17 / 255;\n      outFloatArray[2] = parseInt(hexStr[3], 16) * 17 / 255;\n      return outFloatArray;\n    case 6:\n      // ab01df => #ab01df\n      outFloatArray[0] = parseInt(hexStr.substr(0, 2), 16) / 255;\n      outFloatArray[1] = parseInt(hexStr.substr(2, 2), 16) / 255;\n      outFloatArray[2] = parseInt(hexStr.substr(4, 2), 16) / 255;\n      return outFloatArray;\n    case 7:\n      // #ab01df\n      outFloatArray[0] = parseInt(hexStr.substr(1, 2), 16) / 255;\n      outFloatArray[1] = parseInt(hexStr.substr(3, 2), 16) / 255;\n      outFloatArray[2] = parseInt(hexStr.substr(5, 2), 16) / 255;\n      return outFloatArray;\n    case 9:\n      // #ab01df00\n      outFloatArray[0] = parseInt(hexStr.substr(1, 2), 16) / 255;\n      outFloatArray[1] = parseInt(hexStr.substr(3, 2), 16) / 255;\n      outFloatArray[2] = parseInt(hexStr.substr(5, 2), 16) / 255;\n      outFloatArray[3] = parseInt(hexStr.substr(7, 2), 16) / 255;\n      return outFloatArray;\n    default:\n      return outFloatArray;\n  }\n}\nfunction rgb2hsv(rgb, hsv) {\n  let h;\n  let s;\n  const [r, g, b] = rgb;\n  const onethird = 1.0 / 3.0;\n  const onesixth = 1.0 / 6.0;\n  const twothird = 2.0 / 3.0;\n  let cmax = r;\n  let cmin = r;\n  if (g > cmax) {\n    cmax = g;\n  } else if (g < cmin) {\n    cmin = g;\n  }\n  if (b > cmax) {\n    cmax = b;\n  } else if (b < cmin) {\n    cmin = b;\n  }\n  const v = cmax;\n  if (v > 0.0) {\n    s = (cmax - cmin) / cmax;\n  } else {\n    s = 0.0;\n  }\n  if (s > 0) {\n    if (r === cmax) {\n      h = onesixth * (g - b) / (cmax - cmin);\n    } else if (g === cmax) {\n      h = onethird + onesixth * (b - r) / (cmax - cmin);\n    } else {\n      h = twothird + onesixth * (r - g) / (cmax - cmin);\n    }\n    if (h < 0.0) {\n      h += 1.0;\n    }\n  } else {\n    h = 0.0;\n  }\n\n  // Set the values back to the array\n  hsv[0] = h;\n  hsv[1] = s;\n  hsv[2] = v;\n}\nfunction hsv2rgb(hsv, rgb) {\n  const [h, s, v] = hsv;\n  const onethird = 1.0 / 3.0;\n  const onesixth = 1.0 / 6.0;\n  const twothird = 2.0 / 3.0;\n  const fivesixth = 5.0 / 6.0;\n  let r;\n  let g;\n  let b;\n\n  // compute RGB from HSV\n  if (h > onesixth && h <= onethird) {\n    // green/red\n    g = 1.0;\n    r = (onethird - h) / onesixth;\n    b = 0.0;\n  } else if (h > onethird && h <= 0.5) {\n    // green/blue\n    g = 1.0;\n    b = (h - onethird) / onesixth;\n    r = 0.0;\n  } else if (h > 0.5 && h <= twothird) {\n    // blue/green\n    b = 1.0;\n    g = (twothird - h) / onesixth;\n    r = 0.0;\n  } else if (h > twothird && h <= fivesixth) {\n    // blue/red\n    b = 1.0;\n    r = (h - twothird) / onesixth;\n    g = 0.0;\n  } else if (h > fivesixth && h <= 1.0) {\n    // red/blue\n    r = 1.0;\n    b = (1.0 - h) / onesixth;\n    g = 0.0;\n  } else {\n    // red/green\n    r = 1.0;\n    g = h / onesixth;\n    b = 0.0;\n  }\n\n  // add Saturation to the equation.\n  r = s * r + (1.0 - s);\n  g = s * g + (1.0 - s);\n  b = s * b + (1.0 - s);\n  r *= v;\n  g *= v;\n  b *= v;\n\n  // Assign back to the array\n  rgb[0] = r;\n  rgb[1] = g;\n  rgb[2] = b;\n}\nfunction lab2xyz(lab, xyz) {\n  // LAB to XYZ\n  const [L, a, b] = lab;\n  let var_Y = (L + 16) / 116;\n  let var_X = a / 500 + var_Y;\n  let var_Z = var_Y - b / 200;\n  if (var_Y ** 3 > 0.008856) {\n    var_Y **= 3;\n  } else {\n    var_Y = (var_Y - 16.0 / 116.0) / 7.787;\n  }\n  if (var_X ** 3 > 0.008856) {\n    var_X **= 3;\n  } else {\n    var_X = (var_X - 16.0 / 116.0) / 7.787;\n  }\n  if (var_Z ** 3 > 0.008856) {\n    var_Z **= 3;\n  } else {\n    var_Z = (var_Z - 16.0 / 116.0) / 7.787;\n  }\n  const ref_X = 0.9505;\n  const ref_Y = 1.0;\n  const ref_Z = 1.089;\n  xyz[0] = ref_X * var_X; // ref_X = 0.9505  Observer= 2 deg Illuminant= D65\n  xyz[1] = ref_Y * var_Y; // ref_Y = 1.000\n  xyz[2] = ref_Z * var_Z; // ref_Z = 1.089\n}\n\nfunction xyz2lab(xyz, lab) {\n  const [x, y, z] = xyz;\n  const ref_X = 0.9505;\n  const ref_Y = 1.0;\n  const ref_Z = 1.089;\n  let var_X = x / ref_X; // ref_X = 0.9505  Observer= 2 deg, Illuminant= D65\n  let var_Y = y / ref_Y; // ref_Y = 1.000\n  let var_Z = z / ref_Z; // ref_Z = 1.089\n\n  if (var_X > 0.008856) var_X **= 1.0 / 3.0;else var_X = 7.787 * var_X + 16.0 / 116.0;\n  if (var_Y > 0.008856) var_Y **= 1.0 / 3.0;else var_Y = 7.787 * var_Y + 16.0 / 116.0;\n  if (var_Z > 0.008856) var_Z **= 1.0 / 3.0;else var_Z = 7.787 * var_Z + 16.0 / 116.0;\n  lab[0] = 116 * var_Y - 16;\n  lab[1] = 500 * (var_X - var_Y);\n  lab[2] = 200 * (var_Y - var_Z);\n}\nfunction xyz2rgb(xyz, rgb) {\n  const [x, y, z] = xyz;\n  let r = x * 3.2406 + y * -1.5372 + z * -0.4986;\n  let g = x * -0.9689 + y * 1.8758 + z * 0.0415;\n  let b = x * 0.0557 + y * -0.204 + z * 1.057;\n\n  // The following performs a \"gamma correction\" specified by the sRGB color\n  // space.  sRGB is defined by a canonical definition of a display monitor and\n  // has been standardized by the International Electrotechnical Commission (IEC\n  // 61966-2-1).  The nonlinearity of the correction is designed to make the\n  // colors more perceptually uniform.  This color space has been adopted by\n  // several applications including Adobe Photoshop and Microsoft Windows color\n  // management.  OpenGL is agnostic on its RGB color space, but it is reasonable\n  // to assume it is close to this one.\n  if (r > 0.0031308) r = 1.055 * r ** (1 / 2.4) - 0.055;else r *= 12.92;\n  if (g > 0.0031308) g = 1.055 * g ** (1 / 2.4) - 0.055;else g *= 12.92;\n  if (b > 0.0031308) b = 1.055 * b ** (1 / 2.4) - 0.055;else b *= 12.92;\n\n  // Clip colors. ideally we would do something that is perceptually closest\n  // (since we can see colors outside of the display gamut), but this seems to\n  // work well enough.\n  let maxVal = r;\n  if (maxVal < g) maxVal = g;\n  if (maxVal < b) maxVal = b;\n  if (maxVal > 1.0) {\n    r /= maxVal;\n    g /= maxVal;\n    b /= maxVal;\n  }\n  if (r < 0) r = 0;\n  if (g < 0) g = 0;\n  if (b < 0) b = 0;\n\n  // Push values back to array\n  rgb[0] = r;\n  rgb[1] = g;\n  rgb[2] = b;\n}\nfunction rgb2xyz(rgb, xyz) {\n  let [r, g, b] = rgb;\n  // The following performs a \"gamma correction\" specified by the sRGB color\n  // space.  sRGB is defined by a canonical definition of a display monitor and\n  // has been standardized by the International Electrotechnical Commission (IEC\n  // 61966-2-1).  The nonlinearity of the correction is designed to make the\n  // colors more perceptually uniform.  This color space has been adopted by\n  // several applications including Adobe Photoshop and Microsoft Windows color\n  // management.  OpenGL is agnostic on its RGB color space, but it is reasonable\n  // to assume it is close to this one.\n  if (r > 0.04045) r = ((r + 0.055) / 1.055) ** 2.4;else r /= 12.92;\n  if (g > 0.04045) g = ((g + 0.055) / 1.055) ** 2.4;else g /= 12.92;\n  if (b > 0.04045) b = ((b + 0.055) / 1.055) ** 2.4;else b /= 12.92;\n\n  // Observer. = 2 deg, Illuminant = D65\n  xyz[0] = r * 0.4124 + g * 0.3576 + b * 0.1805;\n  xyz[1] = r * 0.2126 + g * 0.7152 + b * 0.0722;\n  xyz[2] = r * 0.0193 + g * 0.1192 + b * 0.9505;\n}\nfunction rgb2lab(rgb, lab) {\n  const xyz = [0, 0, 0];\n  rgb2xyz(rgb, xyz);\n  xyz2lab(xyz, lab);\n}\nfunction lab2rgb(lab, rgb) {\n  const xyz = [0, 0, 0];\n  lab2xyz(lab, xyz);\n  xyz2rgb(xyz, rgb);\n}\nfunction uninitializeBounds(bounds) {\n  bounds[0] = 1.0;\n  bounds[1] = -1.0;\n  bounds[2] = 1.0;\n  bounds[3] = -1.0;\n  bounds[4] = 1.0;\n  bounds[5] = -1.0;\n  return bounds;\n}\nfunction areBoundsInitialized(bounds) {\n  return !(bounds[1] - bounds[0] < 0.0);\n}\n\n/**\n * @deprecated please use vtkBoundingBox.addPoints(vtkBoundingBox.reset([]), points)\n */\nfunction computeBoundsFromPoints(point1, point2, bounds) {\n  bounds[0] = Math.min(point1[0], point2[0]);\n  bounds[1] = Math.max(point1[0], point2[0]);\n  bounds[2] = Math.min(point1[1], point2[1]);\n  bounds[3] = Math.max(point1[1], point2[1]);\n  bounds[4] = Math.min(point1[2], point2[2]);\n  bounds[5] = Math.max(point1[2], point2[2]);\n  return bounds;\n}\nfunction clampValue(value, minValue, maxValue) {\n  if (value < minValue) {\n    return minValue;\n  }\n  if (value > maxValue) {\n    return maxValue;\n  }\n  return value;\n}\nfunction clampVector(vector, minVector, maxVector) {\n  let out = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [0, 0, 0];\n  out[0] = clampValue(vector[0], minVector[0], maxVector[0]);\n  out[1] = clampValue(vector[1], minVector[1], maxVector[1]);\n  out[2] = clampValue(vector[2], minVector[2], maxVector[2]);\n  return out;\n}\nfunction clampAndNormalizeValue(value, range) {\n  let result = 0;\n  if (range[0] !== range[1]) {\n    // clamp\n    if (value < range[0]) {\n      result = range[0];\n    } else if (value > range[1]) {\n      result = range[1];\n    } else {\n      result = value;\n    }\n    // normalize\n    result = (result - range[0]) / (range[1] - range[0]);\n  }\n  return result;\n}\nconst getScalarTypeFittingRange = notImplemented('GetScalarTypeFittingRange');\nconst getAdjustedScalarRange = notImplemented('GetAdjustedScalarRange');\nfunction extentIsWithinOtherExtent(extent1, extent2) {\n  if (!extent1 || !extent2) {\n    return 0;\n  }\n  for (let i = 0; i < 6; i += 2) {\n    if (extent1[i] < extent2[i] || extent1[i] > extent2[i + 1] || extent1[i + 1] < extent2[i] || extent1[i + 1] > extent2[i + 1]) {\n      return 0;\n    }\n  }\n  return 1;\n}\nfunction boundsIsWithinOtherBounds(bounds1_6, bounds2_6, delta_3) {\n  if (!bounds1_6 || !bounds2_6) {\n    return 0;\n  }\n  for (let i = 0; i < 6; i += 2) {\n    if (bounds1_6[i] + delta_3[i / 2] < bounds2_6[i] || bounds1_6[i] - delta_3[i / 2] > bounds2_6[i + 1] || bounds1_6[i + 1] + delta_3[i / 2] < bounds2_6[i] || bounds1_6[i + 1] - delta_3[i / 2] > bounds2_6[i + 1]) {\n      return 0;\n    }\n  }\n  return 1;\n}\nfunction pointIsWithinBounds(point_3, bounds_6, delta_3) {\n  if (!point_3 || !bounds_6 || !delta_3) {\n    return 0;\n  }\n  for (let i = 0; i < 3; i++) {\n    if (point_3[i] + delta_3[i] < bounds_6[2 * i] || point_3[i] - delta_3[i] > bounds_6[2 * i + 1]) {\n      return 0;\n    }\n  }\n  return 1;\n}\nfunction solve3PointCircle(p1, p2, p3, center) {\n  const v21 = createArray(3);\n  const v32 = createArray(3);\n  const v13 = createArray(3);\n  const v12 = createArray(3);\n  const v23 = createArray(3);\n  const v31 = createArray(3);\n  for (let i = 0; i < 3; ++i) {\n    v21[i] = p1[i] - p2[i];\n    v32[i] = p2[i] - p3[i];\n    v13[i] = p3[i] - p1[i];\n    v12[i] = -v21[i];\n    v23[i] = -v32[i];\n    v31[i] = -v13[i];\n  }\n  const norm12 = norm(v12);\n  const norm23 = norm(v23);\n  const norm13 = norm(v13);\n  const crossv21v32 = createArray(3);\n  cross(v21, v32, crossv21v32);\n  const normCross = norm(crossv21v32);\n  const radius = norm12 * norm23 * norm13 / (2 * normCross);\n  const normCross22 = 2 * normCross * normCross;\n  const alpha = norm23 * norm23 * dot(v21, v31) / normCross22;\n  const beta = norm13 * norm13 * dot(v12, v32) / normCross22;\n  const gamma = norm12 * norm12 * dot(v13, v23) / normCross22;\n  for (let i = 0; i < 3; ++i) {\n    center[i] = alpha * p1[i] + beta * p2[i] + gamma * p3[i];\n  }\n  return radius;\n}\nconst inf = Infinity;\nconst negInf = -Infinity;\nconst isInf = value => !Number.isFinite(value);\nconst {\n  isFinite,\n  isNaN\n} = Number;\nconst isNan = isNaN;\n\n// JavaScript - add-on ----------------------\n\nfunction createUninitializedBounds() {\n  return [].concat([Number.MAX_VALUE, -Number.MAX_VALUE,\n  // X\n  Number.MAX_VALUE, -Number.MAX_VALUE,\n  // Y\n  Number.MAX_VALUE, -Number.MAX_VALUE // Z\n  ]);\n}\n\nfunction getMajorAxisIndex(vector) {\n  let maxValue = -1;\n  let axisIndex = -1;\n  for (let i = 0; i < vector.length; i++) {\n    const value = Math.abs(vector[i]);\n    if (value > maxValue) {\n      axisIndex = i;\n      maxValue = value;\n    }\n  }\n  return axisIndex;\n}\n\n// Return the closest orthogonal matrix of 1, -1 and 0\n// It works for both column major and row major matrices\n// This function iteratively associate a column with a row by choosing\n// the greatest absolute value from the remaining row and columns\n// For each association, a -1 or a 1 is set in the output, depending on\n// the sign of the value in the original matrix\nfunction getSparseOrthogonalMatrix(matrix) {\n  let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;\n  // Initialize rows and columns to available indices\n  const rows = new Array(n);\n  const cols = new Array(n);\n  for (let i = 0; i < n; ++i) {\n    rows[i] = i;\n    cols[i] = i;\n  }\n  // No need for the last iteration: i = 0\n  for (let i = n - 1; i > 0; i--) {\n    // Loop invariant:\n    // rows[0:i] and cols[0:i] contain the remaining rows and columns\n    // rows]i:n[ and cols]i:n[ contain the associations found (rows[k] is associated with cols[k])\n    let bestValue = -Infinity;\n    let bestRowI = 0;\n    let bestColI = 0;\n    for (let rowI = 0; rowI <= i; ++rowI) {\n      const row = rows[rowI];\n      for (let colI = 0; colI <= i; ++colI) {\n        const col = cols[colI];\n        const absVal = Math.abs(matrix[row + n * col]);\n        if (absVal > bestValue) {\n          bestValue = absVal;\n          bestRowI = rowI;\n          bestColI = colI;\n        }\n      }\n    }\n    // Found an association between rows[bestRowI] and cols[bestColI]\n    // Put both at the end of their array by swapping with i\n    [rows[i], rows[bestRowI]] = [rows[bestRowI], rows[i]];\n    [cols[i], cols[bestColI]] = [cols[bestColI], cols[i]];\n  }\n\n  // Convert row/column association to a matrix\n  const output = new Array(n * n).fill(0);\n  for (let i = 0; i < n; ++i) {\n    const matIdx = rows[i] + n * cols[i];\n    output[matIdx] = matrix[matIdx] < 0 ? -1 : 1;\n  }\n  return output;\n}\nfunction floatToHex2(value) {\n  const integer = Math.floor(value * 255);\n  if (integer > 15) {\n    return integer.toString(16);\n  }\n  return `0${integer.toString(16)}`;\n}\nfunction floatRGB2HexCode(rgbArray) {\n  let prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '#';\n  return `${prefix}${rgbArray.map(floatToHex2).join('')}`;\n}\nfunction floatToChar(f) {\n  return Math.round(f * 255);\n}\nfunction float2CssRGBA(rgbArray) {\n  if (rgbArray.length === 3) {\n    return `rgb(${rgbArray.map(floatToChar).join(', ')})`;\n  }\n  return `rgba(${floatToChar(rgbArray[0] || 0)}, ${floatToChar(rgbArray[1] || 0)}, ${floatToChar(rgbArray[2] || 0)}, ${rgbArray[3] || 0})`;\n}\n\n// ----------------------------------------------------------------------------\n// Only Static API\n// ----------------------------------------------------------------------------\n\nvar vtkMath = {\n  Pi,\n  radiansFromDegrees,\n  degreesFromRadians,\n  round,\n  floor,\n  ceil,\n  ceilLog2,\n  min,\n  max,\n  arrayMin,\n  arrayMax,\n  arrayRange,\n  isPowerOfTwo,\n  nearestPowerOfTwo,\n  factorial,\n  binomial,\n  beginCombination,\n  nextCombination,\n  randomSeed,\n  getSeed,\n  random,\n  gaussian,\n  add,\n  subtract,\n  multiplyScalar,\n  multiplyScalar2D,\n  multiplyAccumulate,\n  multiplyAccumulate2D,\n  dot,\n  outer,\n  cross,\n  norm,\n  normalize,\n  perpendiculars,\n  projectVector,\n  projectVector2D,\n  distance2BetweenPoints,\n  angleBetweenVectors,\n  gaussianAmplitude,\n  gaussianWeight,\n  dot2D,\n  outer2D,\n  norm2D,\n  normalize2D,\n  determinant2x2,\n  LUFactor3x3,\n  LUSolve3x3,\n  linearSolve3x3,\n  multiply3x3_vect3,\n  multiply3x3_mat3,\n  multiplyMatrix,\n  transpose3x3,\n  invert3x3,\n  identity3x3,\n  identity,\n  isIdentity,\n  isIdentity3x3,\n  determinant3x3,\n  quaternionToMatrix3x3,\n  areEquals,\n  areMatricesEqual,\n  roundNumber,\n  roundVector,\n  matrix3x3ToQuaternion,\n  multiplyQuaternion,\n  orthogonalize3x3,\n  diagonalize3x3,\n  singularValueDecomposition3x3,\n  solveLinearSystem,\n  invertMatrix,\n  luFactorLinearSystem,\n  luSolveLinearSystem,\n  estimateMatrixCondition,\n  jacobi,\n  jacobiN,\n  solveHomogeneousLeastSquares,\n  solveLeastSquares,\n  hex2float,\n  rgb2hsv,\n  hsv2rgb,\n  lab2xyz,\n  xyz2lab,\n  xyz2rgb,\n  rgb2xyz,\n  rgb2lab,\n  lab2rgb,\n  uninitializeBounds,\n  areBoundsInitialized,\n  computeBoundsFromPoints,\n  clampValue,\n  clampVector,\n  clampAndNormalizeValue,\n  getScalarTypeFittingRange,\n  getAdjustedScalarRange,\n  extentIsWithinOtherExtent,\n  boundsIsWithinOtherBounds,\n  pointIsWithinBounds,\n  solve3PointCircle,\n  inf,\n  negInf,\n  isInf,\n  isNan: isNaN,\n  isNaN,\n  isFinite,\n  // JS add-on\n  createUninitializedBounds,\n  getMajorAxisIndex,\n  getSparseOrthogonalMatrix,\n  floatToHex2,\n  floatRGB2HexCode,\n  float2CssRGBA\n};\n\nvar vtkMath$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  createArray: createArray,\n  Pi: Pi,\n  radiansFromDegrees: radiansFromDegrees,\n  degreesFromRadians: degreesFromRadians,\n  round: round,\n  floor: floor,\n  ceil: ceil,\n  min: min,\n  max: max,\n  arrayMin: arrayMin,\n  arrayMax: arrayMax,\n  arrayRange: arrayRange,\n  ceilLog2: ceilLog2,\n  factorial: factorial,\n  nearestPowerOfTwo: nearestPowerOfTwo,\n  isPowerOfTwo: isPowerOfTwo,\n  binomial: binomial,\n  beginCombination: beginCombination,\n  nextCombination: nextCombination,\n  randomSeed: randomSeed,\n  getSeed: getSeed,\n  random: random,\n  gaussian: gaussian,\n  add: add,\n  subtract: subtract,\n  multiplyScalar: multiplyScalar,\n  multiplyScalar2D: multiplyScalar2D,\n  multiplyAccumulate: multiplyAccumulate,\n  multiplyAccumulate2D: multiplyAccumulate2D,\n  dot: dot,\n  outer: outer,\n  cross: cross,\n  norm: norm,\n  normalize: normalize,\n  perpendiculars: perpendiculars,\n  projectVector: projectVector,\n  dot2D: dot2D,\n  projectVector2D: projectVector2D,\n  distance2BetweenPoints: distance2BetweenPoints,\n  angleBetweenVectors: angleBetweenVectors,\n  signedAngleBetweenVectors: signedAngleBetweenVectors,\n  gaussianAmplitude: gaussianAmplitude,\n  gaussianWeight: gaussianWeight,\n  outer2D: outer2D,\n  norm2D: norm2D,\n  normalize2D: normalize2D,\n  rowsToMat4: rowsToMat4,\n  columnsToMat4: columnsToMat4,\n  rowsToMat3: rowsToMat3,\n  columnsToMat3: columnsToMat3,\n  determinant2x2: determinant2x2,\n  LUFactor3x3: LUFactor3x3,\n  LUSolve3x3: LUSolve3x3,\n  linearSolve3x3: linearSolve3x3,\n  multiply3x3_vect3: multiply3x3_vect3,\n  multiply3x3_mat3: multiply3x3_mat3,\n  multiplyMatrix: multiplyMatrix,\n  transpose3x3: transpose3x3,\n  invert3x3: invert3x3,\n  determinant3x3: determinant3x3,\n  areEquals: areEquals,\n  areMatricesEqual: areMatricesEqual,\n  identity3x3: identity3x3,\n  identity: identity,\n  isIdentity: isIdentity,\n  isIdentity3x3: isIdentity3x3,\n  quaternionToMatrix3x3: quaternionToMatrix3x3,\n  roundNumber: roundNumber,\n  roundVector: roundVector,\n  jacobiN: jacobiN,\n  matrix3x3ToQuaternion: matrix3x3ToQuaternion,\n  multiplyQuaternion: multiplyQuaternion,\n  orthogonalize3x3: orthogonalize3x3,\n  diagonalize3x3: diagonalize3x3,\n  singularValueDecomposition3x3: singularValueDecomposition3x3,\n  luFactorLinearSystem: luFactorLinearSystem,\n  luSolveLinearSystem: luSolveLinearSystem,\n  solveLinearSystem: solveLinearSystem,\n  invertMatrix: invertMatrix,\n  estimateMatrixCondition: estimateMatrixCondition,\n  jacobi: jacobi,\n  solveHomogeneousLeastSquares: solveHomogeneousLeastSquares,\n  solveLeastSquares: solveLeastSquares,\n  hex2float: hex2float,\n  rgb2hsv: rgb2hsv,\n  hsv2rgb: hsv2rgb,\n  lab2xyz: lab2xyz,\n  xyz2lab: xyz2lab,\n  xyz2rgb: xyz2rgb,\n  rgb2xyz: rgb2xyz,\n  rgb2lab: rgb2lab,\n  lab2rgb: lab2rgb,\n  uninitializeBounds: uninitializeBounds,\n  areBoundsInitialized: areBoundsInitialized,\n  computeBoundsFromPoints: computeBoundsFromPoints,\n  clampValue: clampValue,\n  clampVector: clampVector,\n  clampAndNormalizeValue: clampAndNormalizeValue,\n  getScalarTypeFittingRange: getScalarTypeFittingRange,\n  getAdjustedScalarRange: getAdjustedScalarRange,\n  extentIsWithinOtherExtent: extentIsWithinOtherExtent,\n  boundsIsWithinOtherBounds: boundsIsWithinOtherBounds,\n  pointIsWithinBounds: pointIsWithinBounds,\n  solve3PointCircle: solve3PointCircle,\n  inf: inf,\n  negInf: negInf,\n  isInf: isInf,\n  isFinite: isFinite,\n  isNaN: isNaN,\n  isNan: isNan,\n  createUninitializedBounds: createUninitializedBounds,\n  getMajorAxisIndex: getMajorAxisIndex,\n  getSparseOrthogonalMatrix: getSparseOrthogonalMatrix,\n  floatToHex2: floatToHex2,\n  floatRGB2HexCode: floatRGB2HexCode,\n  float2CssRGBA: float2CssRGBA,\n  'default': vtkMath\n});\n\nexport { arrayMax as $, degreesFromRadians as A, areEquals as B, clampValue as C, arrayRange as D, getMajorAxisIndex as E, createUninitializedBounds as F, isIdentity3x3 as G, floor as H, isInf as I, rgb2hsv as J, rgb2lab as K, lab2rgb as L, round as M, normalize2D as N, nearestPowerOfTwo as O, multiply3x3_vect3 as P, getSparseOrthogonalMatrix as Q, areBoundsInitialized as R, isPowerOfTwo as S, angleBetweenVectors as T, signedAngleBetweenVectors as U, createArray as V, Pi as W, ceil as X, min as Y, max as Z, arrayMin as _, areMatricesEqual as a, float2CssRGBA as a$, ceilLog2 as a0, factorial as a1, binomial as a2, beginCombination as a3, nextCombination as a4, randomSeed as a5, getSeed as a6, gaussian as a7, multiplyScalar2D as a8, multiplyAccumulate2D as a9, diagonalize3x3 as aA, singularValueDecomposition3x3 as aB, luFactorLinearSystem as aC, luSolveLinearSystem as aD, invertMatrix as aE, estimateMatrixCondition as aF, solveHomogeneousLeastSquares as aG, solveLeastSquares as aH, hex2float as aI, lab2xyz as aJ, xyz2lab as aK, xyz2rgb as aL, rgb2xyz as aM, computeBoundsFromPoints as aN, clampAndNormalizeValue as aO, getScalarTypeFittingRange as aP, getAdjustedScalarRange as aQ, extentIsWithinOtherExtent as aR, boundsIsWithinOtherBounds as aS, pointIsWithinBounds as aT, solve3PointCircle as aU, inf as aV, negInf as aW, isFinite as aX, isNaN as aY, floatToHex2 as aZ, floatRGB2HexCode as a_, outer as aa, projectVector as ab, dot2D as ac, projectVector2D as ad, gaussianAmplitude as ae, gaussianWeight as af, outer2D as ag, norm2D as ah, rowsToMat4 as ai, columnsToMat4 as aj, columnsToMat3 as ak, LUFactor3x3 as al, LUSolve3x3 as am, linearSolve3x3 as an, multiply3x3_mat3 as ao, multiplyMatrix as ap, transpose3x3 as aq, invert3x3 as ar, identity3x3 as as, identity as at, isIdentity as au, quaternionToMatrix3x3 as av, roundNumber as aw, matrix3x3ToQuaternion as ax, multiplyQuaternion as ay, orthogonalize3x3 as az, roundVector as b, clampVector as c, dot as d, distance2BetweenPoints as e, vtkMath as f, solveLinearSystem as g, hsv2rgb as h, isNan as i, cross as j, add as k, normalize as l, multiplyAccumulate as m, norm as n, determinant2x2 as o, jacobiN as p, perpendiculars as q, radiansFromDegrees as r, subtract as s, jacobi as t, uninitializeBounds as u, vtkMath$1 as v, multiplyScalar as w, random as x, determinant3x3 as y, rowsToMat3 as z };\n","const DataTypeByteSize = {\n  Int8Array: 1,\n  Uint8Array: 1,\n  Uint8ClampedArray: 1,\n  Int16Array: 2,\n  Uint16Array: 2,\n  Int32Array: 4,\n  Uint32Array: 4,\n  Float32Array: 4,\n  Float64Array: 8\n};\nconst VtkDataTypes = {\n  VOID: '',\n  // not sure to know what that should be\n  CHAR: 'Int8Array',\n  SIGNED_CHAR: 'Int8Array',\n  UNSIGNED_CHAR: 'Uint8Array',\n  SHORT: 'Int16Array',\n  UNSIGNED_SHORT: 'Uint16Array',\n  INT: 'Int32Array',\n  UNSIGNED_INT: 'Uint32Array',\n  FLOAT: 'Float32Array',\n  DOUBLE: 'Float64Array'\n};\nconst DefaultDataType = VtkDataTypes.FLOAT;\nvar Constants = {\n  DefaultDataType,\n  DataTypeByteSize,\n  VtkDataTypes\n};\n\nexport { DataTypeByteSize, DefaultDataType, VtkDataTypes, Constants as default };\n","import Constants from './DataArray/Constants.js';\nimport { n as newInstance$1, a as newTypedArray, b as newTypedArrayFrom, o as obj, s as set, c as macro } from '../../macros2.js';\nimport { n as norm } from './Math/index.js';\n\nconst {\n  vtkErrorMacro\n} = macro;\nconst {\n  DefaultDataType\n} = Constants;\n\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\nconst EPSILON = 1e-6;\n\n// Original source from https://www.npmjs.com/package/compute-range\n// Modified to accept type arrays\nfunction fastComputeRange(arr, offset, numberOfComponents) {\n  const len = arr.length;\n  let min = Number.MAX_VALUE;\n  let max = -Number.MAX_VALUE;\n  let x;\n  let i;\n\n  // find first non-NaN value\n  for (i = offset; i < len; i += numberOfComponents) {\n    if (!Number.isNaN(arr[i])) {\n      min = arr[i];\n      max = min;\n      break;\n    }\n  }\n  for (; i < len; i += numberOfComponents) {\n    x = arr[i];\n    if (x < min) {\n      min = x;\n    } else if (x > max) {\n      max = x;\n    }\n  }\n  return {\n    min,\n    max\n  };\n}\n\n/**\n * @deprecated please use fastComputeRange instead\n */\nfunction createRangeHelper() {\n  let min = Number.MAX_VALUE;\n  let max = -Number.MAX_VALUE;\n  let count = 0;\n  let sum = 0;\n  return {\n    add(value) {\n      if (min > value) {\n        min = value;\n      }\n      if (max < value) {\n        max = value;\n      }\n      count++;\n      sum += value;\n    },\n    get() {\n      return {\n        min,\n        max,\n        count,\n        sum,\n        mean: sum / count\n      };\n    },\n    getRange() {\n      return {\n        min,\n        max\n      };\n    }\n  };\n}\nfunction computeRange(values) {\n  let component = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let numberOfComponents = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  if (component < 0 && numberOfComponents > 1) {\n    // Compute magnitude\n    const size = values.length;\n    const numberOfValues = size / numberOfComponents;\n    const data = new Float64Array(numberOfValues);\n    for (let i = 0, j = 0; i < numberOfValues; ++i) {\n      for (let nextJ = j + numberOfComponents; j < nextJ; ++j) {\n        data[i] += values[j] * values[j];\n      }\n      data[i] **= 0.5;\n    }\n    return fastComputeRange(data, 0, 1);\n  }\n  return fastComputeRange(values, component < 0 ? 0 : component, numberOfComponents);\n}\nfunction ensureRangeSize(rangeArray) {\n  let size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  const ranges = rangeArray || [];\n  // Pad ranges with null value to get the\n  while (ranges.length <= size) {\n    ranges.push(null);\n  }\n  return ranges;\n}\nfunction getDataType(typedArray) {\n  // Expects toString() to return \"[object ...Array]\"\n  return Object.prototype.toString.call(typedArray).slice(8, -1);\n}\nfunction getMaxNorm(normArray) {\n  const numComps = normArray.getNumberOfComponents();\n  let maxNorm = 0.0;\n  const tuple = new Array(numComps);\n  for (let i = 0; i < normArray.getNumberOfTuples(); ++i) {\n    normArray.getTuple(i, tuple);\n    const norm$1 = norm(tuple, numComps);\n    if (norm$1 > maxNorm) {\n      maxNorm = norm$1;\n    }\n  }\n  return maxNorm;\n}\n\n// ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\n\nconst STATIC = {\n  computeRange,\n  createRangeHelper,\n  fastComputeRange,\n  getDataType,\n  getMaxNorm\n};\n\n// ----------------------------------------------------------------------------\n// vtkDataArray methods\n// ----------------------------------------------------------------------------\n\nfunction vtkDataArray(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkDataArray');\n\n  /**\n   * Resize model.values and copy the old values to the new array.\n   * @param {Number} requestedNumTuples Final expected number of tuples; must be >= 0\n   * @returns {Boolean} True if a resize occured, false otherwise\n   */\n  function resize(requestedNumTuples) {\n    if (requestedNumTuples < 0) {\n      return false;\n    }\n    const numComps = publicAPI.getNumberOfComponents();\n    const curNumTuples = model.values.length / (numComps > 0 ? numComps : 1);\n    if (requestedNumTuples === curNumTuples) {\n      return true;\n    }\n    if (requestedNumTuples > curNumTuples) {\n      // Requested size is bigger than current size.  Allocate enough\n      // memory to fit the requested size and be more than double the\n      // currently allocated memory.\n      const oldValues = model.values;\n      model.values = newTypedArray(model.dataType, (requestedNumTuples + curNumTuples) * numComps);\n      model.values.set(oldValues);\n      return true;\n    }\n\n    // Requested size is smaller than currently allocated size\n    if (model.size > requestedNumTuples * numComps) {\n      model.size = requestedNumTuples * numComps;\n      publicAPI.dataChange();\n    }\n    return true;\n  }\n  publicAPI.dataChange = () => {\n    model.ranges = null;\n    publicAPI.modified();\n  };\n  publicAPI.resize = requestedNumTuples => {\n    resize(requestedNumTuples);\n    const newSize = requestedNumTuples * publicAPI.getNumberOfComponents();\n    if (model.size !== newSize) {\n      model.size = newSize;\n      publicAPI.dataChange();\n      return true;\n    }\n    return false;\n  };\n\n  // FIXME, to rename into \"clear()\" or \"reset()\"\n  publicAPI.initialize = () => {\n    publicAPI.resize(0);\n  };\n  publicAPI.getElementComponentSize = () => model.values.BYTES_PER_ELEMENT;\n\n  // Description:\n  // Return the data component at the location specified by tupleIdx and\n  // compIdx.\n  publicAPI.getComponent = function (tupleIdx) {\n    let compIdx = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    return model.values[tupleIdx * model.numberOfComponents + compIdx];\n  };\n\n  // Description:\n  // Set the data component at the location specified by tupleIdx and compIdx\n  // to value.\n  // Note that i is less than NumberOfTuples and j is less than\n  //  NumberOfComponents. Make sure enough memory has been allocated\n  // (use SetNumberOfTuples() and SetNumberOfComponents()).\n  publicAPI.setComponent = (tupleIdx, compIdx, value) => {\n    if (value !== model.values[tupleIdx * model.numberOfComponents + compIdx]) {\n      model.values[tupleIdx * model.numberOfComponents + compIdx] = value;\n      publicAPI.dataChange();\n    }\n  };\n  publicAPI.getValue = valueIdx => {\n    const idx = valueIdx / model.numberOfComponents;\n    const comp = valueIdx % model.numberOfComponents;\n    return publicAPI.getComponent(idx, comp);\n  };\n  publicAPI.setValue = (valueIdx, value) => {\n    const idx = valueIdx / model.numberOfComponents;\n    const comp = valueIdx % model.numberOfComponents;\n    publicAPI.setComponent(idx, comp, value);\n  };\n  publicAPI.getData = () => model.size === model.values.length ? model.values : model.values.subarray(0, model.size);\n  publicAPI.getRange = function () {\n    let componentIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;\n    let rangeIdx = componentIndex;\n    if (rangeIdx < 0) {\n      // If scalar data, then store in slot 0 (same as componentIndex = 0).\n      // If vector data, then store in last slot.\n      rangeIdx = model.numberOfComponents === 1 ? 0 : model.numberOfComponents;\n    }\n    let range = null;\n    if (!model.ranges) {\n      model.ranges = ensureRangeSize(model.ranges, model.numberOfComponents);\n    }\n    range = model.ranges[rangeIdx];\n    if (range) {\n      model.rangeTuple[0] = range.min;\n      model.rangeTuple[1] = range.max;\n      return model.rangeTuple;\n    }\n\n    // Need to compute ranges...\n    range = computeRange(publicAPI.getData(), componentIndex, model.numberOfComponents);\n    model.ranges[rangeIdx] = range;\n    model.rangeTuple[0] = range.min;\n    model.rangeTuple[1] = range.max;\n    return model.rangeTuple;\n  };\n  publicAPI.setRange = (rangeValue, componentIndex) => {\n    if (!model.ranges) {\n      model.ranges = ensureRangeSize(model.ranges, model.numberOfComponents);\n    }\n    const range = {\n      min: rangeValue.min,\n      max: rangeValue.max\n    };\n    model.ranges[componentIndex] = range;\n    model.rangeTuple[0] = range.min;\n    model.rangeTuple[1] = range.max;\n    return model.rangeTuple;\n  };\n  publicAPI.setTuple = (idx, tuple) => {\n    const offset = idx * model.numberOfComponents;\n    for (let i = 0; i < model.numberOfComponents; i++) {\n      model.values[offset + i] = tuple[i];\n    }\n  };\n  publicAPI.setTuples = (idx, tuples) => {\n    let i = idx * model.numberOfComponents;\n    const last = Math.min(tuples.length, model.size - i);\n    for (let j = 0; j < last;) {\n      model.values[i++] = tuples[j++];\n    }\n  };\n  publicAPI.insertTuple = (idx, tuple) => {\n    if (model.size <= idx * model.numberOfComponents) {\n      model.size = (idx + 1) * model.numberOfComponents;\n      resize(idx + 1);\n    }\n    publicAPI.setTuple(idx, tuple);\n    return idx;\n  };\n  publicAPI.insertTuples = (idx, tuples) => {\n    const end = idx + tuples.length / model.numberOfComponents;\n    if (model.size < end * model.numberOfComponents) {\n      model.size = end * model.numberOfComponents;\n      resize(end);\n    }\n    publicAPI.setTuples(idx, tuples);\n    return end;\n  };\n  publicAPI.insertNextTuple = tuple => {\n    const idx = model.size / model.numberOfComponents;\n    return publicAPI.insertTuple(idx, tuple);\n  };\n  publicAPI.insertNextTuples = tuples => {\n    const idx = model.size / model.numberOfComponents;\n    return publicAPI.insertTuples(idx, tuples);\n  };\n  publicAPI.findTuple = function (tuple) {\n    let precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EPSILON;\n    for (let i = 0; i < model.size; i += model.numberOfComponents) {\n      if (Math.abs(tuple[0] - model.values[i]) <= precision) {\n        let match = true;\n        for (let j = 1; j < model.numberOfComponents; ++j) {\n          if (Math.abs(tuple[j] - model.values[i + j]) > precision) {\n            match = false;\n            break;\n          }\n        }\n        if (match) {\n          return i / model.numberOfComponents;\n        }\n      }\n    }\n    return -1;\n  };\n  publicAPI.getTuple = function (idx) {\n    let tupleToFill = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    const numberOfComponents = model.numberOfComponents || 1;\n    const offset = idx * numberOfComponents;\n    // Check most common component sizes first\n    // to avoid doing a for loop if possible\n    switch (numberOfComponents) {\n      case 4:\n        tupleToFill[3] = model.values[offset + 3];\n      // eslint-disable-next-line no-fallthrough\n      case 3:\n        tupleToFill[2] = model.values[offset + 2];\n      // eslint-disable-next-line no-fallthrough\n      case 2:\n        tupleToFill[1] = model.values[offset + 1];\n      // eslint-disable-next-line no-fallthrough\n      case 1:\n        tupleToFill[0] = model.values[offset];\n        break;\n      default:\n        for (let i = numberOfComponents - 1; i >= 0; --i) {\n          tupleToFill[i] = model.values[offset + i];\n        }\n    }\n    return tupleToFill;\n  };\n  publicAPI.getTuples = (fromId, toId) => {\n    const from = (fromId ?? 0) * model.numberOfComponents;\n    const to = (toId ?? publicAPI.getNumberOfTuples()) * model.numberOfComponents;\n    const arr = publicAPI.getData().subarray(from, to);\n    return arr.length > 0 ? arr : null;\n  };\n  publicAPI.getTupleLocation = function () {\n    let idx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    return idx * model.numberOfComponents;\n  };\n  publicAPI.getNumberOfComponents = () => model.numberOfComponents;\n  publicAPI.getNumberOfValues = () => model.size;\n  publicAPI.getNumberOfTuples = () => model.size / model.numberOfComponents;\n  publicAPI.getDataType = () => model.dataType;\n  /* eslint-disable no-use-before-define */\n  publicAPI.newClone = () => newInstance({\n    empty: true,\n    name: model.name,\n    dataType: model.dataType,\n    numberOfComponents: model.numberOfComponents\n  });\n  /* eslint-enable no-use-before-define */\n\n  publicAPI.getName = () => {\n    if (!model.name) {\n      publicAPI.modified();\n      model.name = `vtkDataArray${publicAPI.getMTime()}`;\n    }\n    return model.name;\n  };\n  publicAPI.setData = (typedArray, numberOfComponents) => {\n    model.values = typedArray;\n    model.size = typedArray.length;\n    model.dataType = getDataType(typedArray);\n    if (numberOfComponents) {\n      model.numberOfComponents = numberOfComponents;\n    }\n    if (model.size % model.numberOfComponents !== 0) {\n      model.numberOfComponents = 1;\n    }\n    publicAPI.dataChange();\n  };\n\n  // Override serialization support\n  publicAPI.getState = () => {\n    if (model.deleted) {\n      return null;\n    }\n    const jsonArchive = {\n      ...model,\n      vtkClass: publicAPI.getClassName()\n    };\n\n    // Convert typed array to regular array\n    jsonArchive.values = Array.from(jsonArchive.values);\n    delete jsonArchive.buffer;\n\n    // Clean any empty data\n    Object.keys(jsonArchive).forEach(keyName => {\n      if (!jsonArchive[keyName]) {\n        delete jsonArchive[keyName];\n      }\n    });\n\n    // Sort resulting object by key name\n    const sortedObj = {};\n    Object.keys(jsonArchive).sort().forEach(name => {\n      sortedObj[name] = jsonArchive[name];\n    });\n\n    // Remove mtime\n    if (sortedObj.mtime) {\n      delete sortedObj.mtime;\n    }\n    return sortedObj;\n  };\n  publicAPI.deepCopy = other => {\n    // Retain current dataType and array reference before shallowCopy call.\n    const currentType = publicAPI.getDataType();\n    const currentArray = model.values;\n    publicAPI.shallowCopy(other);\n\n    // Avoid array reallocation if size already sufficient\n    // and dataTypes match.\n    if (currentArray?.length >= other.getNumberOfValues() && currentType === other.getDataType()) {\n      currentArray.set(other.getData());\n      model.values = currentArray;\n      publicAPI.dataChange();\n    } else {\n      publicAPI.setData(other.getData().slice());\n    }\n  };\n  publicAPI.interpolateTuple = (idx, source1, source1Idx, source2, source2Idx, t) => {\n    const numberOfComponents = model.numberOfComponents || 1;\n    if (numberOfComponents !== source1.getNumberOfComponents() || numberOfComponents !== source2.getNumberOfComponents()) {\n      vtkErrorMacro('numberOfComponents must match');\n    }\n    const tuple1 = source1.getTuple(source1Idx);\n    const tuple2 = source2.getTuple(source2Idx);\n    const out = [];\n    out.length = numberOfComponents;\n\n    // Check most common component sizes first\n    // to avoid doing a for loop if possible\n    switch (numberOfComponents) {\n      case 4:\n        out[3] = tuple1[3] + (tuple2[3] - tuple1[3]) * t;\n      // eslint-disable-next-line no-fallthrough\n      case 3:\n        out[2] = tuple1[2] + (tuple2[2] - tuple1[2]) * t;\n      // eslint-disable-next-line no-fallthrough\n      case 2:\n        out[1] = tuple1[1] + (tuple2[1] - tuple1[1]) * t;\n      // eslint-disable-next-line no-fallthrough\n      case 1:\n        out[0] = tuple1[0] + (tuple2[0] - tuple1[0]) * t;\n        break;\n      default:\n        for (let i = 0; i < numberOfComponents; i++) {\n          out[i] = tuple1[i] + (tuple2[i] - tuple1[i]) * t;\n        }\n    }\n    return publicAPI.insertTuple(idx, out);\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n// size: The current size of the dataArray.\n// NOTE: The underlying typed array may be larger than 'size'.\nconst DEFAULT_VALUES = {\n  name: '',\n  numberOfComponents: 1,\n  dataType: DefaultDataType,\n  rangeTuple: [0, 0]\n  // size: undefined,\n  // values: null,\n  // ranges: null,\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n  if (!model.empty && !model.values && !model.size) {\n    throw new TypeError('Cannot create vtkDataArray object without: size > 0, values');\n  }\n  if (!model.values) {\n    model.values = newTypedArray(model.dataType, model.size);\n  } else if (Array.isArray(model.values)) {\n    model.values = newTypedArrayFrom(model.dataType, model.values);\n  }\n  if (model.values) {\n    // Takes the size if provided (can be lower than `model.values`) otherwise the actual length of `values`.\n    model.size = model.size ?? model.values.length;\n    model.dataType = getDataType(model.values);\n  }\n\n  // Object methods\n  obj(publicAPI, model);\n  set(publicAPI, model, ['name', 'numberOfComponents']);\n  if (model.size % model.numberOfComponents !== 0) {\n    throw new RangeError('model.size is not a multiple of model.numberOfComponents');\n  }\n\n  // Object specific methods\n  vtkDataArray(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = newInstance$1(extend, 'vtkDataArray');\n\n// ----------------------------------------------------------------------------\n\nvar vtkDataArray$1 = {\n  newInstance,\n  extend,\n  ...STATIC,\n  ...Constants\n};\n\nexport { STATIC, vtkDataArray$1 as default, extend, newInstance };\n","import eventTarget from '../eventTarget';\nexport default function triggerEvent(el = eventTarget, type, detail = null) {\n    if (!type) {\n        throw new Error('Event type was not defined');\n    }\n    const event = new CustomEvent(type, {\n        detail,\n        cancelable: true,\n    });\n    return el.dispatchEvent(event);\n}\n//# sourceMappingURL=triggerEvent.js.map","export default function imageIdToURI(imageId) {\n    const colonIndex = imageId.indexOf(':');\n    return imageId.substring(colonIndex + 1);\n}\n//# sourceMappingURL=imageIdToURI.js.map","import { getGPUTier } from 'detect-gpu';\nimport { SharedArrayBufferModes } from './enums';\nimport { getRenderingEngines } from './RenderingEngine/getRenderingEngine';\nlet csRenderInitialized = false;\nlet useSharedArrayBuffer = true;\nlet sharedArrayBufferMode = SharedArrayBufferModes.TRUE;\nimport { deepMerge } from './utilities';\nimport CentralizedWebWorkerManager from './webWorkerManager/webWorkerManager';\nconst defaultConfig = {\n    gpuTier: undefined,\n    detectGPUConfig: {},\n    rendering: {\n        useCPURendering: false,\n        preferSizeOverAccuracy: false,\n        useNorm16Texture: false,\n        strictZSpacingForVolumeViewport: true,\n    },\n    enableCacheOptimization: true,\n};\nlet config = {\n    gpuTier: undefined,\n    detectGPUConfig: {},\n    rendering: {\n        useCPURendering: false,\n        preferSizeOverAccuracy: false,\n        useNorm16Texture: false,\n        strictZSpacingForVolumeViewport: true,\n    },\n    enableCacheOptimization: true,\n};\nlet webWorkerManager = null;\nfunction _getGLContext() {\n    const canvas = document.createElement('canvas');\n    const gl = canvas.getContext('webgl2') ||\n        canvas.getContext('webgl') ||\n        canvas.getContext('experimental-webgl');\n    return gl;\n}\nfunction _hasActiveWebGLContext() {\n    const gl = _getGLContext();\n    return (gl instanceof WebGLRenderingContext || gl instanceof WebGL2RenderingContext);\n}\nfunction hasSharedArrayBuffer() {\n    try {\n        if (new SharedArrayBuffer(0)) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    catch {\n        return false;\n    }\n}\nasync function init(configuration = config) {\n    if (csRenderInitialized) {\n        return csRenderInitialized;\n    }\n    config = deepMerge(defaultConfig, configuration);\n    const hasWebGLContext = _hasActiveWebGLContext();\n    if (!hasWebGLContext) {\n        console.log('CornerstoneRender: GPU not detected, using CPU rendering');\n        config.rendering.useCPURendering = true;\n    }\n    else {\n        config.gpuTier =\n            config.gpuTier || (await getGPUTier(config.detectGPUConfig));\n        console.log('CornerstoneRender: Using detect-gpu to get the GPU benchmark:', config.gpuTier);\n        if (config.gpuTier?.tier < 1) {\n            console.log('CornerstoneRender: GPU is not powerful enough, using CPU rendering');\n            config.rendering.useCPURendering = true;\n        }\n        else {\n            console.log('CornerstoneRender: using GPU rendering');\n        }\n    }\n    setUseSharedArrayBuffer(sharedArrayBufferMode);\n    csRenderInitialized = true;\n    if (!webWorkerManager) {\n        webWorkerManager = new CentralizedWebWorkerManager();\n    }\n    return csRenderInitialized;\n}\nfunction setUseCPURendering(status) {\n    config.rendering.useCPURendering = status;\n    csRenderInitialized = true;\n    _updateRenderingPipelinesForAllViewports();\n}\nfunction setPreferSizeOverAccuracy(status) {\n    config.rendering.preferSizeOverAccuracy = status;\n    csRenderInitialized = true;\n    _updateRenderingPipelinesForAllViewports();\n}\nfunction resetUseCPURendering() {\n    config.rendering.useCPURendering = !_hasActiveWebGLContext();\n    _updateRenderingPipelinesForAllViewports();\n}\nfunction getShouldUseCPURendering() {\n    return config.rendering.useCPURendering;\n}\nfunction setUseSharedArrayBuffer(mode) {\n    if (mode == SharedArrayBufferModes.AUTO) {\n        sharedArrayBufferMode = SharedArrayBufferModes.AUTO;\n        const hasSharedBuffer = hasSharedArrayBuffer();\n        if (!hasSharedBuffer) {\n            useSharedArrayBuffer = false;\n            console.warn(`CornerstoneRender: SharedArray Buffer not allowed, performance may be slower.\n        Try ensuring page is cross-origin isolated to enable SharedArrayBuffer.`);\n        }\n        else {\n            useSharedArrayBuffer = true;\n            console.log('CornerstoneRender: using SharedArrayBuffer');\n        }\n        return;\n    }\n    if (mode == SharedArrayBufferModes.TRUE || mode == true) {\n        sharedArrayBufferMode = SharedArrayBufferModes.TRUE;\n        useSharedArrayBuffer = true;\n        return;\n    }\n    if (mode == SharedArrayBufferModes.FALSE || mode == false) {\n        sharedArrayBufferMode = SharedArrayBufferModes.FALSE;\n        useSharedArrayBuffer = false;\n        return;\n    }\n}\nfunction resetUseSharedArrayBuffer() {\n    setUseSharedArrayBuffer(sharedArrayBufferMode);\n}\nfunction getShouldUseSharedArrayBuffer() {\n    return useSharedArrayBuffer;\n}\nfunction isCornerstoneInitialized() {\n    return csRenderInitialized;\n}\nfunction getConfiguration() {\n    return config;\n}\nfunction setConfiguration(c) {\n    config = c;\n    _updateRenderingPipelinesForAllViewports();\n}\nfunction _updateRenderingPipelinesForAllViewports() {\n    getRenderingEngines().forEach((engine) => engine\n        .getViewports()\n        .forEach((viewport) => viewport.updateRenderingPipeline?.()));\n}\nfunction getWebWorkerManager() {\n    if (!webWorkerManager) {\n        webWorkerManager = new CentralizedWebWorkerManager();\n    }\n    return webWorkerManager;\n}\nexport { init, getShouldUseCPURendering, getShouldUseSharedArrayBuffer, isCornerstoneInitialized, setUseCPURendering, setUseSharedArrayBuffer, setPreferSizeOverAccuracy, resetUseCPURendering, resetUseSharedArrayBuffer, getConfiguration, setConfiguration, getWebWorkerManager, };\n//# sourceMappingURL=init.js.map","import { s as subtract, d as dot, j as cross, k as add } from '../Core/Math/index.js';\nimport { m as macro } from '../../macros2.js';\n\nconst PLANE_TOLERANCE = 1.0e-6;\nconst COINCIDE = 'coincide';\nconst DISJOINT = 'disjoint';\n\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n\nfunction evaluate(normal, origin, x) {\n  return normal[0] * (x[0] - origin[0]) + normal[1] * (x[1] - origin[1]) + normal[2] * (x[2] - origin[2]);\n}\nfunction distanceToPlane(x, origin, normal) {\n  const distance = normal[0] * (x[0] - origin[0]) + normal[1] * (x[1] - origin[1]) + normal[2] * (x[2] - origin[2]);\n  return Math.abs(distance);\n}\nfunction projectPoint(x, origin, normal, xproj) {\n  const xo = [];\n  subtract(x, origin, xo);\n  const t = dot(normal, xo);\n  xproj[0] = x[0] - t * normal[0];\n  xproj[1] = x[1] - t * normal[1];\n  xproj[2] = x[2] - t * normal[2];\n}\nfunction projectVector(v, normal, vproj) {\n  const t = dot(v, normal);\n  let n2 = dot(normal, normal);\n  if (n2 === 0) {\n    n2 = 1.0;\n  }\n  vproj[0] = v[0] - t * normal[0] / n2;\n  vproj[1] = v[1] - t * normal[1] / n2;\n  vproj[2] = v[2] - t * normal[2] / n2;\n  return vproj;\n}\nfunction generalizedProjectPoint(x, origin, normal, xproj) {\n  const xo = [];\n  subtract(x, origin, xo);\n  const t = dot(normal, xo);\n  const n2 = dot(normal, normal);\n  if (n2 !== 0) {\n    xproj[0] = x[0] - t * normal[0] / n2;\n    xproj[1] = x[1] - t * normal[1] / n2;\n    xproj[2] = x[2] - t * normal[2] / n2;\n  } else {\n    xproj[0] = x[0];\n    xproj[1] = x[1];\n    xproj[2] = x[2];\n  }\n}\nfunction intersectWithLine(p1, p2, origin, normal) {\n  const outObj = {\n    intersection: false,\n    betweenPoints: false,\n    t: Number.MAX_VALUE,\n    x: []\n  };\n  const p21 = [];\n  const p1Origin = [];\n  // Compute line vector\n  subtract(p2, p1, p21);\n  subtract(origin, p1, p1Origin);\n\n  // Compute denominator.  If ~0, line and plane are parallel.\n  // const num = vtkMath.dot(normal, origin) - vtkMath.dot(normal, p1);\n  const num = dot(normal, p1Origin);\n  const den = dot(normal, p21);\n\n  // If denominator with respect to numerator is \"zero\", then the line and\n  // plane are considered parallel.\n  let fabsden;\n  let fabstolerance;\n\n  // Trying to avoid an expensive call to fabs()\n  if (den < 0.0) {\n    fabsden = -den;\n  } else {\n    fabsden = den;\n  }\n  if (num < 0.0) {\n    fabstolerance = -num * PLANE_TOLERANCE;\n  } else {\n    fabstolerance = num * PLANE_TOLERANCE;\n  }\n  if (fabsden <= fabstolerance) {\n    return outObj;\n  }\n\n  // Where on the line between p1 and p2 is the intersection\n  // If between 0 and 1, it is between the two points. If < 0 it's before p1, if > 1 it's after p2\n  outObj.t = num / den;\n  outObj.x[0] = p1[0] + outObj.t * p21[0];\n  outObj.x[1] = p1[1] + outObj.t * p21[1];\n  outObj.x[2] = p1[2] + outObj.t * p21[2];\n  outObj.intersection = true;\n  outObj.betweenPoints = outObj.t >= 0.0 && outObj.t <= 1.0;\n  return outObj;\n}\nfunction intersectWithPlane(plane1Origin, plane1Normal, plane2Origin, plane2Normal) {\n  const outObj = {\n    intersection: false,\n    l0: [],\n    l1: [],\n    error: null\n  };\n  const cross$1 = [];\n  cross(plane1Normal, plane2Normal, cross$1);\n  const absCross = cross$1.map(n => Math.abs(n));\n\n  // test if the two planes are parallel\n  if (absCross[0] + absCross[1] + absCross[2] < PLANE_TOLERANCE) {\n    // test if disjoint or coincide\n    const v = [];\n    subtract(plane1Origin, plane2Origin, v);\n    if (dot(plane1Normal, v) === 0) {\n      outObj.error = COINCIDE;\n    } else {\n      outObj.error = DISJOINT;\n    }\n    return outObj;\n  }\n\n  // Plane1 and Plane2 intersect in a line\n  // first determine max abs coordinate of the cross product\n  let maxc;\n  if (absCross[0] > absCross[1] && absCross[0] > absCross[2]) {\n    maxc = 'x';\n  } else if (absCross[1] > absCross[2]) {\n    maxc = 'y';\n  } else {\n    maxc = 'z';\n  }\n\n  // To get a point on the intersect line, zero the max coord, and solve for the other two\n  const iP = []; // intersectionPoint\n  // the constants in the 2 plane equations\n  const d1 = -dot(plane1Normal, plane1Origin);\n  const d2 = -dot(plane2Normal, plane2Origin);\n\n  // eslint-disable-next-line default-case\n  switch (maxc) {\n    case 'x':\n      // intersect with x=0\n      iP[0] = 0;\n      iP[1] = (d2 * plane1Normal[2] - d1 * plane2Normal[2]) / cross$1[0];\n      iP[2] = (d1 * plane2Normal[1] - d2 * plane1Normal[1]) / cross$1[0];\n      break;\n    case 'y':\n      // intersect with y=0\n      iP[0] = (d1 * plane2Normal[2] - d2 * plane1Normal[2]) / cross$1[1];\n      iP[1] = 0;\n      iP[2] = (d2 * plane1Normal[0] - d1 * plane2Normal[0]) / cross$1[1];\n      break;\n    case 'z':\n      // intersect with z=0\n      iP[0] = (d2 * plane1Normal[1] - d1 * plane2Normal[1]) / cross$1[2];\n      iP[1] = (d1 * plane2Normal[0] - d2 * plane1Normal[0]) / cross$1[2];\n      iP[2] = 0;\n      break;\n  }\n  outObj.l0 = iP;\n  add(iP, cross$1, outObj.l1);\n  outObj.intersection = true;\n  return outObj;\n}\n\n// ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\n\nconst STATIC = {\n  evaluate,\n  distanceToPlane,\n  projectPoint,\n  projectVector,\n  generalizedProjectPoint,\n  intersectWithLine,\n  intersectWithPlane,\n  DISJOINT,\n  COINCIDE\n};\n\n// ----------------------------------------------------------------------------\n// vtkPlane methods\n// ----------------------------------------------------------------------------\n\nfunction vtkPlane(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkPlane');\n  publicAPI.distanceToPlane = x => distanceToPlane(x, model.origin, model.normal);\n  publicAPI.projectPoint = (x, xproj) => {\n    projectPoint(x, model.origin, model.normal, xproj);\n  };\n  publicAPI.projectVector = (v, vproj) => projectVector(v, model.normal, vproj);\n  publicAPI.push = distance => {\n    if (distance === 0.0) {\n      return;\n    }\n    for (let i = 0; i < 3; i++) {\n      model.origin[i] += distance * model.normal[i];\n    }\n  };\n  publicAPI.generalizedProjectPoint = (x, xproj) => {\n    generalizedProjectPoint(x, model.origin, model.normal, xproj);\n  };\n  publicAPI.evaluateFunction = (x, y, z) => {\n    if (!Array.isArray(x)) {\n      return model.normal[0] * (x - model.origin[0]) + model.normal[1] * (y - model.origin[1]) + model.normal[2] * (z - model.origin[2]);\n    }\n    return model.normal[0] * (x[0] - model.origin[0]) + model.normal[1] * (x[1] - model.origin[1]) + model.normal[2] * (x[2] - model.origin[2]);\n  };\n  publicAPI.evaluateGradient = xyz => {\n    const retVal = [model.normal[0], model.normal[1], model.normal[2]];\n    return retVal;\n  };\n  publicAPI.intersectWithLine = (p1, p2) => intersectWithLine(p1, p2, model.origin, model.normal);\n  publicAPI.intersectWithPlane = (planeOrigin, planeNormal) => intersectWithPlane(planeOrigin, planeNormal, model.origin, model.normal);\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  normal: [0.0, 0.0, 1.0],\n  origin: [0.0, 0.0, 0.0]\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Object methods\n  macro.obj(publicAPI, model);\n  macro.setGetArray(publicAPI, model, ['normal', 'origin'], 3);\n  vtkPlane(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkPlane');\n\n// ----------------------------------------------------------------------------\n\nvar vtkPlane$1 = {\n  newInstance,\n  extend,\n  ...STATIC\n};\n\nexport { STATIC, vtkPlane$1 as default, extend, newInstance, vtkPlane };\n","import { d as dot } from '../Core/Math/index.js';\nimport { vec3 } from 'gl-matrix';\nimport vtkPlane from './Plane.js';\n\nconst INIT_BOUNDS = [Number.MAX_VALUE, -Number.MAX_VALUE,\n// X\nNumber.MAX_VALUE, -Number.MAX_VALUE,\n// Y\nNumber.MAX_VALUE, -Number.MAX_VALUE // Z\n];\n\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n\nfunction equals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5];\n}\nfunction isValid(bounds) {\n  return bounds?.length >= 6 && bounds[0] <= bounds[1] && bounds[2] <= bounds[3] && bounds[4] <= bounds[5];\n}\nfunction setBounds(bounds, otherBounds) {\n  bounds[0] = otherBounds[0];\n  bounds[1] = otherBounds[1];\n  bounds[2] = otherBounds[2];\n  bounds[3] = otherBounds[3];\n  bounds[4] = otherBounds[4];\n  bounds[5] = otherBounds[5];\n  return bounds;\n}\nfunction reset(bounds) {\n  return setBounds(bounds, INIT_BOUNDS);\n}\nfunction addPoint(bounds, x, y, z) {\n  const [xMin, xMax, yMin, yMax, zMin, zMax] = bounds;\n  bounds[0] = xMin < x ? xMin : x;\n  bounds[1] = xMax > x ? xMax : x;\n  bounds[2] = yMin < y ? yMin : y;\n  bounds[3] = yMax > y ? yMax : y;\n  bounds[4] = zMin < z ? zMin : z;\n  bounds[5] = zMax > z ? zMax : z;\n  return bounds;\n}\nfunction addPoints(bounds, points) {\n  if (points.length === 0) {\n    return bounds;\n  }\n  if (Array.isArray(points[0])) {\n    for (let i = 0; i < points.length; ++i) {\n      addPoint(bounds, ...points[i]);\n    }\n  } else {\n    for (let i = 0; i < points.length; i += 3) {\n      addPoint(bounds, ...points.slice(i, i + 3));\n    }\n  }\n  return bounds;\n}\nfunction addBounds(bounds, xMin, xMax, yMin, yMax, zMin, zMax) {\n  const [_xMin, _xMax, _yMin, _yMax, _zMin, _zMax] = bounds;\n  if (zMax === undefined) {\n    bounds[0] = Math.min(xMin[0], _xMin);\n    bounds[1] = Math.max(xMin[1], _xMax);\n    bounds[2] = Math.min(xMin[2], _yMin);\n    bounds[3] = Math.max(xMin[3], _yMax);\n    bounds[4] = Math.min(xMin[4], _zMin);\n    bounds[5] = Math.max(xMin[5], _zMax);\n  } else {\n    bounds[0] = Math.min(xMin, _xMin);\n    bounds[1] = Math.max(xMax, _xMax);\n    bounds[2] = Math.min(yMin, _yMin);\n    bounds[3] = Math.max(yMax, _yMax);\n    bounds[4] = Math.min(zMin, _zMin);\n    bounds[5] = Math.max(zMax, _zMax);\n  }\n  return bounds;\n}\nfunction setMinPoint(bounds, x, y, z) {\n  const [xMin, xMax, yMin, yMax, zMin, zMax] = bounds;\n  bounds[0] = x;\n  bounds[1] = x > xMax ? x : xMax;\n  bounds[2] = y;\n  bounds[3] = y > yMax ? y : yMax;\n  bounds[4] = z;\n  bounds[5] = z > zMax ? z : zMax;\n  return xMin !== x || yMin !== y || zMin !== z;\n}\nfunction setMaxPoint(bounds, x, y, z) {\n  const [xMin, xMax, yMin, yMax, zMin, zMax] = bounds;\n  bounds[0] = x < xMin ? x : xMin;\n  bounds[1] = x;\n  bounds[2] = y < yMin ? y : yMin;\n  bounds[3] = y;\n  bounds[4] = z < zMin ? z : zMin;\n  bounds[5] = z;\n  return xMax !== x || yMax !== y || zMax !== z;\n}\nfunction inflate(bounds, delta) {\n  bounds[0] -= delta;\n  bounds[1] += delta;\n  bounds[2] -= delta;\n  bounds[3] += delta;\n  bounds[4] -= delta;\n  bounds[5] += delta;\n  return bounds;\n}\nfunction scale(bounds, sx, sy, sz) {\n  if (!isValid(bounds)) {\n    return false;\n  }\n  if (sx >= 0.0) {\n    bounds[0] *= sx;\n    bounds[1] *= sx;\n  } else {\n    bounds[0] = sx * bounds[1];\n    bounds[1] = sx * bounds[0];\n  }\n  if (sy >= 0.0) {\n    bounds[2] *= sy;\n    bounds[3] *= sy;\n  } else {\n    bounds[2] = sy * bounds[3];\n    bounds[3] = sy * bounds[2];\n  }\n  if (sz >= 0.0) {\n    bounds[4] *= sz;\n    bounds[5] *= sz;\n  } else {\n    bounds[4] = sz * bounds[5];\n    bounds[5] = sz * bounds[4];\n  }\n  return true;\n}\nfunction getCenter(bounds) {\n  return [0.5 * (bounds[0] + bounds[1]), 0.5 * (bounds[2] + bounds[3]), 0.5 * (bounds[4] + bounds[5])];\n}\nfunction scaleAboutCenter(bounds, sx, sy, sz) {\n  if (!isValid(bounds)) {\n    return false;\n  }\n  const center = getCenter(bounds);\n  bounds[0] -= center[0];\n  bounds[1] -= center[0];\n  bounds[2] -= center[1];\n  bounds[3] -= center[1];\n  bounds[4] -= center[2];\n  bounds[5] -= center[2];\n  scale(bounds, sx, sy, sz);\n  bounds[0] += center[0];\n  bounds[1] += center[0];\n  bounds[2] += center[1];\n  bounds[3] += center[1];\n  bounds[4] += center[2];\n  bounds[5] += center[2];\n  return true;\n}\nfunction getLength(bounds, index) {\n  return bounds[index * 2 + 1] - bounds[index * 2];\n}\nfunction getLengths(bounds) {\n  return [getLength(bounds, 0), getLength(bounds, 1), getLength(bounds, 2)];\n}\nfunction getXRange(bounds) {\n  return bounds.slice(0, 2);\n}\nfunction getYRange(bounds) {\n  return bounds.slice(2, 4);\n}\nfunction getZRange(bounds) {\n  return bounds.slice(4, 6);\n}\nfunction getMaxLength(bounds) {\n  const l = getLengths(bounds);\n  if (l[0] > l[1]) {\n    if (l[0] > l[2]) {\n      return l[0];\n    }\n    return l[2];\n  }\n  if (l[1] > l[2]) {\n    return l[1];\n  }\n  return l[2];\n}\nfunction getDiagonalLength(bounds) {\n  if (isValid(bounds)) {\n    const l = getLengths(bounds);\n    return Math.sqrt(l[0] * l[0] + l[1] * l[1] + l[2] * l[2]);\n  }\n  return null;\n}\nfunction getMinPoint(bounds) {\n  return [bounds[0], bounds[2], bounds[4]];\n}\nfunction getMaxPoint(bounds) {\n  return [bounds[1], bounds[3], bounds[5]];\n}\nfunction oppositeSign(a, b) {\n  return a <= 0 && b >= 0 || a >= 0 && b <= 0;\n}\nfunction getCorners(bounds, corners) {\n  let count = 0;\n  for (let ix = 0; ix < 2; ix++) {\n    for (let iy = 2; iy < 4; iy++) {\n      for (let iz = 4; iz < 6; iz++) {\n        corners[count++] = [bounds[ix], bounds[iy], bounds[iz]];\n      }\n    }\n  }\n  return corners;\n}\n\n// Computes the two corners with minimal and maximal coordinates\nfunction computeCornerPoints(bounds, point1, point2) {\n  point1[0] = bounds[0];\n  point1[1] = bounds[2];\n  point1[2] = bounds[4];\n  point2[0] = bounds[1];\n  point2[1] = bounds[3];\n  point2[2] = bounds[5];\n  return point1;\n}\nfunction transformBounds(bounds, transform) {\n  let out = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  const corners = getCorners(bounds, []);\n  for (let i = 0; i < corners.length; ++i) {\n    vec3.transformMat4(corners[i], corners[i], transform);\n  }\n  reset(out);\n  return addPoints(out, corners);\n}\nfunction computeScale3(bounds) {\n  let scale3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  scale3[0] = 0.5 * (bounds[1] - bounds[0]);\n  scale3[1] = 0.5 * (bounds[3] - bounds[2]);\n  scale3[2] = 0.5 * (bounds[5] - bounds[4]);\n  return scale3;\n}\n\n/**\n * Compute local bounds.\n * Not as fast as vtkPoints.getBounds() if u, v, w form a natural basis.\n * @param {vtkPoints} points\n * @param {array} u first vector\n * @param {array} v second vector\n * @param {array} w third vector\n */\nfunction computeLocalBounds(points, u, v, w) {\n  const bounds = [].concat(INIT_BOUNDS);\n  const pointsData = points.getData();\n  for (let i = 0; i < pointsData.length; i += 3) {\n    const point = [pointsData[i], pointsData[i + 1], pointsData[i + 2]];\n    const du = dot(point, u);\n    bounds[0] = Math.min(du, bounds[0]);\n    bounds[1] = Math.max(du, bounds[1]);\n    const dv = dot(point, v);\n    bounds[2] = Math.min(dv, bounds[2]);\n    bounds[3] = Math.max(dv, bounds[3]);\n    const dw = dot(point, w);\n    bounds[4] = Math.min(dw, bounds[4]);\n    bounds[5] = Math.max(dw, bounds[5]);\n  }\n  return bounds;\n}\n\n// The method returns a non-zero value if the bounding box is hit.\n// Origin[3] starts the ray, dir[3] is the vector components of the ray in the x-y-z\n// directions, coord[3] is the location of hit, and t is the parametric\n// coordinate along line. (Notes: the intersection ray dir[3] is NOT\n// normalized.  Valid intersections will only occur between 0<=t<=1.)\nfunction intersectBox(bounds, origin, dir, coord, tolerance) {\n  let inside = true;\n  const quadrant = [];\n  let whichPlane = 0;\n  const maxT = [];\n  const candidatePlane = [0.0, 0.0, 0.0];\n  const RIGHT = 0;\n  const LEFT = 1;\n  const MIDDLE = 2;\n\n  // First find closest planes\n  for (let i = 0; i < 3; i++) {\n    if (origin[i] < bounds[2 * i]) {\n      quadrant[i] = LEFT;\n      candidatePlane[i] = bounds[2 * i];\n      inside = false;\n    } else if (origin[i] > bounds[2 * i + 1]) {\n      quadrant[i] = RIGHT;\n      candidatePlane[i] = bounds[2 * i + 1];\n      inside = false;\n    } else {\n      quadrant[i] = MIDDLE;\n    }\n  }\n\n  // Check whether origin of ray is inside bbox\n  if (inside) {\n    coord[0] = origin[0];\n    coord[1] = origin[1];\n    coord[2] = origin[2];\n    tolerance[0] = 0;\n    return 1;\n  }\n\n  // Calculate parametric distance to plane\n  for (let i = 0; i < 3; i++) {\n    if (quadrant[i] !== MIDDLE && dir[i] !== 0.0) {\n      maxT[i] = (candidatePlane[i] - origin[i]) / dir[i];\n    } else {\n      maxT[i] = -1.0;\n    }\n  }\n\n  // Find the largest parametric value of intersection\n  for (let i = 0; i < 3; i++) {\n    if (maxT[whichPlane] < maxT[i]) {\n      whichPlane = i;\n    }\n  }\n\n  // Check for value intersection along line\n  if (maxT[whichPlane] > 1.0 || maxT[whichPlane] < 0.0) {\n    return 0;\n  }\n  tolerance[0] = maxT[whichPlane];\n\n  // Intersection point along line is okay. Check bbox.\n  for (let i = 0; i < 3; i++) {\n    if (whichPlane !== i) {\n      coord[i] = origin[i] + maxT[whichPlane] * dir[i];\n      if (coord[i] < bounds[2 * i] || coord[i] > bounds[2 * i + 1]) {\n        return 0;\n      }\n    } else {\n      coord[i] = candidatePlane[i];\n    }\n  }\n  return 1;\n}\n\n// Plane intersection with box\n// The plane is infinite in extent and defined by an origin and normal.The function indicates\n// whether the plane intersects, not the particulars of intersection points and such\n// The function returns non-zero if the plane and box intersect; zero otherwise.\nfunction intersectPlane(bounds, origin, normal) {\n  const p = [];\n  let d = 0;\n  let sign = 1;\n  let firstOne = 1;\n\n  // Evaluate the eight points. If there is a sign change, there is an intersection\n  for (let z = 4; z <= 5; ++z) {\n    p[2] = bounds[z];\n    for (let y = 2; y <= 3; ++y) {\n      p[1] = bounds[y];\n      for (let x = 0; x <= 1; ++x) {\n        p[0] = bounds[x];\n        d = vtkPlane.evaluate(normal, origin, p);\n        if (firstOne) {\n          sign = d >= 0 ? 1 : -1;\n          firstOne = 0;\n        }\n        if (d === 0.0 || sign > 0 && d < 0.0 || sign < 0 && d > 0.0) {\n          return 1;\n        }\n      }\n    }\n  }\n  return 0; // no intersection\n}\n\nfunction intersect(bounds, bBounds) {\n  if (!(isValid(bounds) && isValid(bBounds))) {\n    return false;\n  }\n  const newBounds = [0, 0, 0, 0, 0, 0];\n  let intersection;\n  for (let i = 0; i < 3; i++) {\n    intersection = false;\n    if (bBounds[i * 2] >= bounds[i * 2] && bBounds[i * 2] <= bounds[i * 2 + 1]) {\n      intersection = true;\n      newBounds[i * 2] = bBounds[i * 2];\n    } else if (bounds[i * 2] >= bBounds[i * 2] && bounds[i * 2] <= bBounds[i * 2 + 1]) {\n      intersection = true;\n      newBounds[i * 2] = bounds[i * 2];\n    }\n    if (bBounds[i * 2 + 1] >= bounds[i * 2] && bBounds[i * 2 + 1] <= bounds[i * 2 + 1]) {\n      intersection = true;\n      newBounds[i * 2 + 1] = bBounds[2 * i + 1];\n    } else if (bounds[i * 2 + 1] >= bBounds[i * 2] && bounds[i * 2 + 1] <= bBounds[i * 2 + 1]) {\n      intersection = true;\n      newBounds[i * 2 + 1] = bounds[i * 2 + 1];\n    }\n    if (!intersection) {\n      return false;\n    }\n  }\n\n  // OK they did intersect - set the box to be the result\n  bounds[0] = newBounds[0];\n  bounds[1] = newBounds[1];\n  bounds[2] = newBounds[2];\n  bounds[3] = newBounds[3];\n  bounds[4] = newBounds[4];\n  bounds[5] = newBounds[5];\n  return true;\n}\nfunction intersects(bounds, bBounds) {\n  if (!(isValid(bounds) && isValid(bBounds))) {\n    return false;\n  }\n  /* eslint-disable no-continue */\n  for (let i = 0; i < 3; i++) {\n    if (bBounds[i * 2] >= bounds[i * 2] && bBounds[i * 2] <= bounds[i * 2 + 1]) {\n      continue;\n    } else if (bounds[i * 2] >= bBounds[i * 2] && bounds[i * 2] <= bBounds[i * 2 + 1]) {\n      continue;\n    }\n    if (bBounds[i * 2 + 1] >= bounds[i * 2] && bBounds[i * 2 + 1] <= bounds[i * 2 + 1]) {\n      continue;\n    } else if (bounds[i * 2 + 1] >= bBounds[i * 2] && bounds[i * 2 + 1] <= bBounds[i * 2 + 1]) {\n      continue;\n    }\n    return false;\n  }\n  /* eslint-enable no-continue */\n\n  return true;\n}\nfunction containsPoint(bounds, x, y, z) {\n  if (x < bounds[0] || x > bounds[1]) {\n    return false;\n  }\n  if (y < bounds[2] || y > bounds[3]) {\n    return false;\n  }\n  if (z < bounds[4] || z > bounds[5]) {\n    return false;\n  }\n  return true;\n}\nfunction contains(bounds, otherBounds) {\n  // if either box is not valid or they don't intersect\n  if (!intersects(bounds, otherBounds)) {\n    return false;\n  }\n  if (!containsPoint(bounds, ...getMinPoint(otherBounds))) {\n    return false;\n  }\n  if (!containsPoint(bounds, ...getMaxPoint(otherBounds))) {\n    return false;\n  }\n  return true;\n}\n\n/**\n * Returns true if plane intersects bounding box.\n * If so, the box is cut by the plane\n * @param {array} origin\n * @param {array} normal\n */\nfunction cutWithPlane(bounds, origin, normal) {\n  // Index[0..2] represents the order of traversing the corners of a cube\n  // in (x,y,z), (y,x,z) and (z,x,y) ordering, respectively\n  const index = [[0, 1, 2, 3, 4, 5, 6, 7], [0, 1, 4, 5, 2, 3, 6, 7], [0, 2, 4, 6, 1, 3, 5, 7]];\n\n  // stores the signed distance to a plane\n  const d = [0, 0, 0, 0, 0, 0, 0, 0];\n  let idx = 0;\n  for (let ix = 0; ix < 2; ix++) {\n    for (let iy = 2; iy < 4; iy++) {\n      for (let iz = 4; iz < 6; iz++) {\n        const x = [bounds[ix], bounds[iy], bounds[iz]];\n        d[idx++] = vtkPlane.evaluate(normal, origin, x);\n      }\n    }\n  }\n  let dir = 2;\n  while (dir--) {\n    // in each direction, we test if the vertices of two orthogonal faces\n    // are on either side of the plane\n    if (oppositeSign(d[index[dir][0]], d[index[dir][4]]) && oppositeSign(d[index[dir][1]], d[index[dir][5]]) && oppositeSign(d[index[dir][2]], d[index[dir][6]]) && oppositeSign(d[index[dir][3]], d[index[dir][7]])) {\n      break;\n    }\n  }\n  if (dir < 0) {\n    return false;\n  }\n  const sign = Math.sign(normal[dir]);\n  const size = Math.abs((bounds[dir * 2 + 1] - bounds[dir * 2]) * normal[dir]);\n  let t = sign > 0 ? 1 : 0;\n  /* eslint-disable no-continue */\n  for (let i = 0; i < 4; i++) {\n    if (size === 0) {\n      continue; // shouldn't happen\n    }\n\n    const ti = Math.abs(d[index[dir][i]]) / size;\n    if (sign > 0 && ti < t) {\n      t = ti;\n    }\n    if (sign < 0 && ti > t) {\n      t = ti;\n    }\n  }\n  /* eslint-enable no-continue */\n  const bound = (1.0 - t) * bounds[dir * 2] + t * bounds[dir * 2 + 1];\n  if (sign > 0) {\n    bounds[dir * 2] = bound;\n  } else {\n    bounds[dir * 2 + 1] = bound;\n  }\n  return true;\n}\n\n// ----------------------------------------------------------------------------\n// Light Weight class\n// ----------------------------------------------------------------------------\n\nclass BoundingBox {\n  constructor(refBounds) {\n    this.bounds = refBounds;\n    if (!this.bounds) {\n      this.bounds = new Float64Array(INIT_BOUNDS);\n    }\n  }\n  getBounds() {\n    return this.bounds;\n  }\n  equals(otherBounds) {\n    return equals(this.bounds, otherBounds);\n  }\n  isValid() {\n    return isValid(this.bounds);\n  }\n  setBounds(otherBounds) {\n    return setBounds(this.bounds, otherBounds);\n  }\n  reset() {\n    return reset(this.bounds);\n  }\n  addPoint() {\n    for (var _len = arguments.length, xyz = new Array(_len), _key = 0; _key < _len; _key++) {\n      xyz[_key] = arguments[_key];\n    }\n    return addPoint(this.bounds, ...xyz);\n  }\n  addPoints(points) {\n    return addPoints(this.bounds, points);\n  }\n  addBounds(xMin, xMax, yMin, yMax, zMin, zMax) {\n    return addBounds(this.bounds, xMin, xMax, yMin, yMax, zMin, zMax);\n  }\n  setMinPoint(x, y, z) {\n    return setMinPoint(this.bounds, x, y, z);\n  }\n  setMaxPoint(x, y, z) {\n    return setMaxPoint(this.bounds, x, y, z);\n  }\n  inflate(delta) {\n    return inflate(this.bounds, delta);\n  }\n  scale(sx, sy, sz) {\n    return scale(this.bounds, sx, sy, sz);\n  }\n  getCenter() {\n    return getCenter(this.bounds);\n  }\n  getLength(index) {\n    return getLength(this.bounds, index);\n  }\n  getLengths() {\n    return getLengths(this.bounds);\n  }\n  getMaxLength() {\n    return getMaxLength(this.bounds);\n  }\n  getDiagonalLength() {\n    return getDiagonalLength(this.bounds);\n  }\n  getMinPoint() {\n    return getMinPoint(this.bounds);\n  }\n  getMaxPoint() {\n    return getMaxPoint(this.bounds);\n  }\n  getXRange() {\n    return getXRange(this.bounds);\n  }\n  getYRange() {\n    return getYRange(this.bounds);\n  }\n  getZRange() {\n    return getZRange(this.bounds);\n  }\n  getCorners(corners) {\n    return getCorners(this.bounds, corners);\n  }\n  computeCornerPoints(point1, point2) {\n    return computeCornerPoints(this.bounds, point1, point2);\n  }\n  computeLocalBounds(u, v, w) {\n    return computeLocalBounds(this.bounds, u, v, w);\n  }\n  transformBounds(transform) {\n    let out = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    return transformBounds(this.bounds, transform, out);\n  }\n  computeScale3(scale3) {\n    return computeScale3(this.bounds, scale3);\n  }\n  cutWithPlane(origin, normal) {\n    return cutWithPlane(this.bounds, origin, normal);\n  }\n  intersectBox(origin, dir, coord, tolerance) {\n    return intersectBox(this.bounds, origin, dir, coord, tolerance);\n  }\n  intersectPlane(origin, normal) {\n    return intersectPlane(this.bounds, origin, normal);\n  }\n  intersect(otherBounds) {\n    return intersect(this.bounds, otherBounds);\n  }\n  intersects(otherBounds) {\n    return intersects(this.bounds, otherBounds);\n  }\n  containsPoint(x, y, z) {\n    return containsPoint(this.bounds, x, y, z);\n  }\n  contains(otherBounds) {\n    return intersects(this.bounds, otherBounds);\n  }\n}\nfunction newInstance(initialValues) {\n  const bounds = initialValues && initialValues.bounds;\n  return new BoundingBox(bounds);\n}\n\n// ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\n\nconst STATIC = {\n  equals,\n  isValid,\n  setBounds,\n  reset,\n  addPoint,\n  addPoints,\n  addBounds,\n  setMinPoint,\n  setMaxPoint,\n  inflate,\n  scale,\n  scaleAboutCenter,\n  getCenter,\n  getLength,\n  getLengths,\n  getMaxLength,\n  getDiagonalLength,\n  getMinPoint,\n  getMaxPoint,\n  getXRange,\n  getYRange,\n  getZRange,\n  getCorners,\n  computeCornerPoints,\n  computeLocalBounds,\n  transformBounds,\n  computeScale3,\n  cutWithPlane,\n  intersectBox,\n  intersectPlane,\n  intersect,\n  intersects,\n  containsPoint,\n  contains,\n  INIT_BOUNDS\n};\nvar vtkBoundingBox = {\n  newInstance,\n  ...STATIC\n};\n\nexport { STATIC, addBounds, addPoint, addPoints, computeCornerPoints, computeLocalBounds, computeScale3, contains, containsPoint, cutWithPlane, vtkBoundingBox as default, equals, getCenter, getCorners, getDiagonalLength, getLength, getLengths, getMaxLength, getMaxPoint, getMinPoint, getXRange, getYRange, getZRange, inflate, intersect, intersectBox, intersectPlane, intersects, isValid, reset, scale, scaleAboutCenter, setBounds, setMaxPoint, setMinPoint, transformBounds };\n","import vtk from '../../../vtk.js';\nimport { m as macro } from '../../../macros2.js';\nimport vtkDataArray from '../../Core/DataArray.js';\n\nconst {\n  vtkErrorMacro,\n  vtkWarningMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// vtkFieldData methods\n// ----------------------------------------------------------------------------\n\nfunction vtkFieldData(publicAPI, model) {\n  model.classHierarchy.push('vtkFieldData');\n  const superGetState = publicAPI.getState;\n\n  // Decode serialized data if any\n  if (model.arrays) {\n    model.arrays = model.arrays.map(item => ({\n      data: vtk(item.data)\n    }));\n  }\n  publicAPI.initialize = () => {\n    publicAPI.initializeFields();\n    publicAPI.copyAllOn();\n    publicAPI.clearFieldFlags();\n  };\n  publicAPI.initializeFields = () => {\n    model.arrays = [];\n    model.copyFieldFlags = {};\n    publicAPI.modified();\n  };\n  publicAPI.copyStructure = other => {\n    publicAPI.initializeFields();\n    model.copyFieldFlags = other.getCopyFieldFlags().map(x => x); // Deep-copy\n    model.arrays = other.arrays().map(x => ({\n      array: x\n    })); // Deep-copy\n    // TODO: Copy array information objects (once we support information objects)\n  };\n\n  publicAPI.getNumberOfArrays = () => model.arrays.length;\n  publicAPI.getNumberOfActiveArrays = () => model.arrays.length;\n  publicAPI.addArray = arr => {\n    const name = arr.getName();\n    const {\n      array,\n      index\n    } = publicAPI.getArrayWithIndex(name);\n    if (array != null) {\n      model.arrays[index] = {\n        data: arr\n      };\n      return index;\n    }\n    model.arrays = [].concat(model.arrays, {\n      data: arr\n    });\n    return model.arrays.length - 1;\n  };\n  publicAPI.removeAllArrays = () => {\n    model.arrays = [];\n  };\n  publicAPI.removeArray = arrayName => {\n    const index = model.arrays.findIndex(array => array.data.getName() === arrayName);\n    return publicAPI.removeArrayByIndex(index);\n  };\n  publicAPI.removeArrayByIndex = arrayIdx => {\n    if (arrayIdx !== -1 && arrayIdx < model.arrays.length) {\n      model.arrays.splice(arrayIdx, 1);\n      // TBD modified() ?\n      return true;\n    }\n    return false;\n  };\n  publicAPI.getArrays = () => model.arrays.map(entry => entry.data);\n  publicAPI.getArray = arraySpec => typeof arraySpec === 'number' ? publicAPI.getArrayByIndex(arraySpec) : publicAPI.getArrayByName(arraySpec);\n  publicAPI.getArrayByName = arrayName => model.arrays.reduce((a, b, i) => b.data.getName() === arrayName ? b.data : a, null);\n  publicAPI.getArrayWithIndex = arrayName => {\n    const index = model.arrays.findIndex(array => array.data.getName() === arrayName);\n    return {\n      array: index !== -1 ? model.arrays[index].data : null,\n      index\n    };\n  };\n  publicAPI.getArrayByIndex = idx => idx >= 0 && idx < model.arrays.length ? model.arrays[idx].data : null;\n  publicAPI.hasArray = arrayName => publicAPI.getArrayWithIndex(arrayName).index >= 0;\n  publicAPI.getArrayName = idx => {\n    const arr = model.arrays[idx];\n    return arr ? arr.data.getName() : '';\n  };\n  publicAPI.getCopyFieldFlags = () => model.copyFieldFlags;\n  publicAPI.getFlag = arrayName => model.copyFieldFlags[arrayName];\n  publicAPI.passData = function (other) {\n    let fromId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n    let toId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;\n    other.getArrays().forEach(arr => {\n      const copyFlag = publicAPI.getFlag(arr.getName());\n      if (copyFlag !== false && !(model.doCopyAllOff && copyFlag !== true) && arr) {\n        let destArr = publicAPI.getArrayByName(arr.getName());\n        if (!destArr) {\n          if (fromId < 0 || fromId > arr.getNumberOfTuples()) {\n            // TBD: should this be a deep or a shallow copy?\n            publicAPI.addArray(arr);\n            other.getAttributes(arr).forEach(attrType => {\n              publicAPI.setAttribute(arr, attrType);\n            });\n          } else {\n            const ncomps = arr.getNumberOfComponents();\n            let newSize = arr.getNumberOfValues();\n            const tId = toId > -1 ? toId : fromId;\n            if (newSize <= tId * ncomps) {\n              newSize = (tId + 1) * ncomps;\n            }\n            destArr = vtkDataArray.newInstance({\n              name: arr.getName(),\n              dataType: arr.getDataType(),\n              numberOfComponents: ncomps,\n              values: macro.newTypedArray(arr.getDataType(), newSize),\n              size: 0\n            });\n            destArr.insertTuple(tId, arr.getTuple(fromId));\n            publicAPI.addArray(destArr);\n            other.getAttributes(arr).forEach(attrType => {\n              publicAPI.setAttribute(destArr, attrType);\n            });\n          }\n        } else if (arr.getNumberOfComponents() === destArr.getNumberOfComponents()) {\n          if (fromId > -1 && fromId < arr.getNumberOfTuples()) {\n            const tId = toId > -1 ? toId : fromId;\n            destArr.insertTuple(tId, arr.getTuple(fromId));\n          } else {\n            // if `fromId` is not provided, just copy all (or as much possible)\n            // from `arr` to `destArr`.\n            destArr.insertTuples(0, arr.getTuples());\n          }\n        } else {\n          vtkErrorMacro('Unhandled case in passData');\n        }\n      }\n    });\n  };\n  publicAPI.interpolateData = function (other) {\n    let fromId1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n    let fromId2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;\n    let toId = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : -1;\n    let t = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.5;\n    other.getArrays().forEach(arr => {\n      const copyFlag = publicAPI.getFlag(arr.getName());\n      if (copyFlag !== false && !(model.doCopyAllOff && copyFlag !== true) && arr) {\n        let destArr = publicAPI.getArrayByName(arr.getName());\n        if (!destArr) {\n          if (fromId1 < 0 || fromId2 < 0 || fromId1 > arr.getNumberOfTuples()) {\n            // TBD: should this be a deep or a shallow copy?\n            publicAPI.addArray(arr);\n            other.getAttributes(arr).forEach(attrType => {\n              publicAPI.setAttribute(arr, attrType);\n            });\n          } else {\n            const ncomps = arr.getNumberOfComponents();\n            let newSize = arr.getNumberOfValues();\n            // TODO: Is this supposed to happen?\n            const tId = toId > -1 ? toId : fromId1;\n            if (newSize <= tId * ncomps) {\n              newSize = (tId + 1) * ncomps;\n            }\n            destArr = vtkDataArray.newInstance({\n              name: arr.getName(),\n              dataType: arr.getDataType(),\n              numberOfComponents: ncomps,\n              values: macro.newTypedArray(arr.getDataType(), newSize),\n              size: 0\n            });\n            destArr.interpolateTuple(tId, arr, fromId1, arr, fromId2, t);\n            publicAPI.addArray(destArr);\n            other.getAttributes(arr).forEach(attrType => {\n              publicAPI.setAttribute(destArr, attrType);\n            });\n          }\n        } else if (arr.getNumberOfComponents() === destArr.getNumberOfComponents()) {\n          if (fromId1 > -1 && fromId1 < arr.getNumberOfTuples()) {\n            const tId = toId > -1 ? toId : fromId1;\n            destArr.interpolateTuple(tId, arr, fromId1, arr, fromId2, t);\n            vtkWarningMacro('Unexpected case in interpolateData');\n          } else {\n            // if `fromId` is not provided, just copy all (or as much possible)\n            // from `arr` to `destArr`.\n            destArr.insertTuples(arr.getTuples());\n          }\n        } else {\n          vtkErrorMacro('Unhandled case in interpolateData');\n        }\n      }\n    });\n  };\n  publicAPI.copyFieldOn = arrayName => {\n    model.copyFieldFlags[arrayName] = true;\n  };\n  publicAPI.copyFieldOff = arrayName => {\n    model.copyFieldFlags[arrayName] = false;\n  };\n  publicAPI.copyAllOn = () => {\n    if (!model.doCopyAllOn || model.doCopyAllOff) {\n      model.doCopyAllOn = true;\n      model.doCopyAllOff = false;\n      publicAPI.modified();\n    }\n  };\n  publicAPI.copyAllOff = () => {\n    if (model.doCopyAllOn || !model.doCopyAllOff) {\n      model.doCopyAllOn = false;\n      model.doCopyAllOff = true;\n      publicAPI.modified();\n    }\n  };\n  publicAPI.clearFieldFlags = () => {\n    model.copyFieldFlags = {};\n  };\n  publicAPI.deepCopy = other => {\n    model.arrays = other.getArrays().map(arr => {\n      const arrNew = arr.newClone();\n      arrNew.deepCopy(arr);\n      return {\n        data: arrNew\n      };\n    });\n  };\n  publicAPI.copyFlags = other => other.getCopyFieldFlags().map(x => x);\n  // TODO: publicAPI.squeeze = () => model.arrays.forEach(entry => entry.data.squeeze());\n  publicAPI.reset = () => model.arrays.forEach(entry => entry.data.reset());\n  // TODO: getActualMemorySize\n  publicAPI.getMTime = () => model.arrays.reduce((a, b) => b.data.getMTime() > a ? b.data.getMTime() : a, model.mtime);\n  // TODO: publicAPI.getField = (ids, other) => { copy ids from other into this model's arrays }\n  // TODO: publicAPI.getArrayContainingComponent = (component) => ...\n  publicAPI.getNumberOfComponents = () => model.arrays.reduce((a, b) => a + b.data.getNumberOfComponents(), 0);\n  publicAPI.getNumberOfTuples = () => model.arrays.length > 0 ? model.arrays[0].getNumberOfTuples() : 0;\n  publicAPI.getState = () => {\n    const result = superGetState();\n    if (result) {\n      result.arrays = model.arrays.map(item => ({\n        data: item.data.getState()\n      }));\n    }\n    return result;\n  };\n}\nconst DEFAULT_VALUES = {\n  arrays: [],\n  copyFieldFlags: [],\n  // fields not to copy\n  doCopyAllOn: true,\n  doCopyAllOff: false\n};\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n  macro.obj(publicAPI, model);\n  vtkFieldData(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkFieldData');\n\n// ----------------------------------------------------------------------------\n\nvar vtkFieldData$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkFieldData$1 as default, extend, newInstance };\n","const AttributeTypes = {\n  SCALARS: 0,\n  VECTORS: 1,\n  NORMALS: 2,\n  TCOORDS: 3,\n  TENSORS: 4,\n  GLOBALIDS: 5,\n  PEDIGREEIDS: 6,\n  EDGEFLAG: 7,\n  NUM_ATTRIBUTES: 8\n};\nconst AttributeLimitTypes = {\n  MAX: 0,\n  EXACT: 1,\n  NOLIMIT: 2\n};\nconst CellGhostTypes = {\n  DUPLICATECELL: 1,\n  // the cell is present on multiple processors\n  HIGHCONNECTIVITYCELL: 2,\n  // the cell has more neighbors than in a regular mesh\n  LOWCONNECTIVITYCELL: 4,\n  // the cell has less neighbors than in a regular mesh\n  REFINEDCELL: 8,\n  // other cells are present that refines it.\n  EXTERIORCELL: 16,\n  // the cell is on the exterior of the data set\n  HIDDENCELL: 32 // the cell is needed to maintain connectivity, but the data values should be ignored.\n};\n\nconst PointGhostTypes = {\n  DUPLICATEPOINT: 1,\n  // the cell is present on multiple processors\n  HIDDENPOINT: 2 // the point is needed to maintain connectivity, but the data values should be ignored.\n};\n\nconst AttributeCopyOperations = {\n  COPYTUPLE: 0,\n  INTERPOLATE: 1,\n  PASSDATA: 2,\n  ALLCOPY: 3 // all of the above\n};\n\nconst ghostArrayName = 'vtkGhostType';\nconst DesiredOutputPrecision = {\n  DEFAULT: 0,\n  // use the point type that does not truncate any data\n  SINGLE: 1,\n  // use Float32Array\n  DOUBLE: 2 // use Float64Array\n};\n\nvar Constants = {\n  AttributeCopyOperations,\n  AttributeLimitTypes,\n  AttributeTypes,\n  CellGhostTypes,\n  DesiredOutputPrecision,\n  PointGhostTypes,\n  ghostArrayName\n};\n\nexport { AttributeCopyOperations, AttributeLimitTypes, AttributeTypes, CellGhostTypes, DesiredOutputPrecision, PointGhostTypes, Constants as default, ghostArrayName };\n","import { m as macro } from '../../macros2.js';\nimport vtkFieldData from './DataSetAttributes/FieldData.js';\nimport Constants from './DataSetAttributes/Constants.js';\nimport vtkDataArray from '../Core/DataArray.js';\n\nconst {\n  AttributeTypes,\n  AttributeCopyOperations\n} = Constants;\nconst {\n  vtkWarningMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// vtkDataSetAttributes methods\n// ----------------------------------------------------------------------------\n\nfunction vtkDataSetAttributes(publicAPI, model) {\n  const attrTypes = ['Scalars', 'Vectors', 'Normals', 'TCoords', 'Tensors', 'GlobalIds', 'PedigreeIds'];\n  function cleanAttributeType(attType) {\n    // Given an integer or string, convert the result to one of the\n    // strings in the \"attrTypes\" array above or null (if\n    // no match is found)\n    let cleanAttType = attrTypes.find(ee => AttributeTypes[ee.toUpperCase()] === attType || typeof attType !== 'number' && ee.toLowerCase() === attType.toLowerCase());\n    if (typeof cleanAttType === 'undefined') {\n      cleanAttType = null;\n    }\n    return cleanAttType;\n  }\n\n  // Set our className\n  model.classHierarchy.push('vtkDataSetAttributes');\n  const superClass = {\n    ...publicAPI\n  };\n  publicAPI.checkNumberOfComponents = x => true; // TODO\n\n  publicAPI.setAttribute = (arr, uncleanAttType) => {\n    const attType = cleanAttributeType(uncleanAttType);\n    if (arr && attType.toUpperCase() === 'PEDIGREEIDS' && !arr.isA('vtkDataArray')) {\n      vtkWarningMacro(`Cannot set attribute ${attType}. The attribute must be a vtkDataArray.`);\n      return -1;\n    }\n    if (arr && !publicAPI.checkNumberOfComponents(arr, attType)) {\n      vtkWarningMacro(`Cannot set attribute ${attType}. Incorrect number of components.`);\n      return -1;\n    }\n    let currentAttribute = model[`active${attType}`];\n    if (currentAttribute >= 0 && currentAttribute < model.arrays.length) {\n      if (model.arrays[currentAttribute] === arr) {\n        return currentAttribute;\n      }\n      // FIXME setting an array actually changes its index\n      publicAPI.removeArrayByIndex(currentAttribute);\n    }\n    if (arr) {\n      currentAttribute = publicAPI.addArray(arr);\n      model[`active${attType}`] = currentAttribute;\n    } else {\n      model[`active${attType}`] = -1;\n    }\n    publicAPI.modified();\n    return model[`active${attType}`];\n  };\n  publicAPI.getAttributes = arr => attrTypes.filter(attrType => publicAPI[`get${attrType}`]() === arr);\n  publicAPI.setActiveAttributeByName = (arrayName, attType) => publicAPI.setActiveAttributeByIndex(publicAPI.getArrayWithIndex(arrayName).index, attType);\n  publicAPI.setActiveAttributeByIndex = (arrayIdx, uncleanAttType) => {\n    const attType = cleanAttributeType(uncleanAttType);\n    if (arrayIdx >= 0 && arrayIdx < model.arrays.length) {\n      if (attType.toUpperCase() !== 'PEDIGREEIDS') {\n        const arr = publicAPI.getArrayByIndex(arrayIdx);\n        if (!arr.isA('vtkDataArray')) {\n          vtkWarningMacro(`Cannot set attribute ${attType}. Only vtkDataArray subclasses can be set as active attributes.`);\n          return -1;\n        }\n        if (!publicAPI.checkNumberOfComponents(arr, attType)) {\n          vtkWarningMacro(`Cannot set attribute ${attType}. Incorrect number of components.`);\n          return -1;\n        }\n      }\n      model[`active${attType}`] = arrayIdx;\n      publicAPI.modified();\n      return arrayIdx;\n    }\n    if (arrayIdx === -1) {\n      model[`active${attType}`] = arrayIdx;\n      publicAPI.modified();\n    }\n    return -1;\n  };\n  publicAPI.getActiveAttribute = attType => {\n    // Given an integer enum value or a string (with random capitalization),\n    // find the matching string in attrTypes.\n    const cleanAttType = cleanAttributeType(attType);\n    return publicAPI[`get${cleanAttType}`]();\n  };\n\n  // Override to allow proper handling of active attributes\n  publicAPI.removeAllArrays = () => {\n    attrTypes.forEach(attType => {\n      model[`active${attType}`] = -1;\n    });\n    superClass.removeAllArrays();\n  };\n\n  // Override to allow proper handling of active attributes\n  publicAPI.removeArrayByIndex = arrayIdx => {\n    if (arrayIdx !== -1) {\n      attrTypes.forEach(attType => {\n        if (arrayIdx === model[`active${attType}`]) {\n          model[`active${attType}`] = -1;\n        } else if (arrayIdx < model[`active${attType}`]) {\n          model[`active${attType}`] -= 1;\n        }\n      });\n    }\n    return superClass.removeArrayByIndex(arrayIdx);\n  };\n  attrTypes.forEach(value => {\n    const activeVal = `active${value}`;\n    publicAPI[`get${value}`] = () => publicAPI.getArrayByIndex(model[activeVal]);\n    publicAPI[`set${value}`] = da => publicAPI.setAttribute(da, value);\n    publicAPI[`setActive${value}`] = arrayName => publicAPI.setActiveAttributeByIndex(publicAPI.getArrayWithIndex(arrayName).index, value);\n    publicAPI[`copy${value}Off`] = () => {\n      const attType = value.toUpperCase();\n      model.copyAttributeFlags[AttributeCopyOperations.PASSDATA][AttributeTypes[attType]] = false;\n    };\n    publicAPI[`copy${value}On`] = () => {\n      const attType = value.toUpperCase();\n      model.copyAttributeFlags[AttributeCopyOperations.PASSDATA][AttributeTypes[attType]] = true;\n    };\n  });\n  publicAPI.initializeAttributeCopyFlags = () => {\n    // Default to copying all attributes in every circumstance:\n    model.copyAttributeFlags = [];\n    Object.keys(AttributeCopyOperations).filter(op => op !== 'ALLCOPY').forEach(attCopyOp => {\n      model.copyAttributeFlags[AttributeCopyOperations[attCopyOp]] = Object.keys(AttributeTypes).filter(ty => ty !== 'NUM_ATTRIBUTES').reduce((a, b) => {\n        a[AttributeTypes[b]] = true;\n        return a;\n      }, []);\n    });\n    // Override some operations where we don't want to copy:\n    model.copyAttributeFlags[AttributeCopyOperations.COPYTUPLE][AttributeTypes.GLOBALIDS] = false;\n    model.copyAttributeFlags[AttributeCopyOperations.INTERPOLATE][AttributeTypes.GLOBALIDS] = false;\n    model.copyAttributeFlags[AttributeCopyOperations.COPYTUPLE][AttributeTypes.PEDIGREEIDS] = false;\n  };\n  publicAPI.initialize = macro.chain(publicAPI.initialize, publicAPI.initializeAttributeCopyFlags);\n\n  // Process dataArrays if any\n  if (model.dataArrays && Object.keys(model.dataArrays).length) {\n    Object.keys(model.dataArrays).forEach(name => {\n      if (!model.dataArrays[name].ref && model.dataArrays[name].type === 'vtkDataArray') {\n        publicAPI.addArray(vtkDataArray.newInstance(model.dataArrays[name]));\n      }\n    });\n  }\n  const superShallowCopy = publicAPI.shallowCopy;\n  publicAPI.shallowCopy = (other, debug) => {\n    superShallowCopy(other, debug);\n    model.arrays = other.getArrays().map(arr => {\n      const arrNew = arr.newClone();\n      arrNew.shallowCopy(arr, debug);\n      return {\n        data: arrNew\n      };\n    });\n  };\n  publicAPI.initializeAttributeCopyFlags();\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  activeScalars: -1,\n  activeVectors: -1,\n  activeTensors: -1,\n  activeNormals: -1,\n  activeTCoords: -1,\n  activeGlobalIds: -1,\n  activePedigreeIds: -1\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Object methods\n  vtkFieldData.extend(publicAPI, model, initialValues);\n  macro.setGet(publicAPI, model, ['activeScalars', 'activeNormals', 'activeTCoords', 'activeVectors', 'activeTensors', 'activeGlobalIds', 'activePedigreeIds']);\n  if (!model.arrays) {\n    model.arrays = {};\n  }\n\n  // Object specific methods\n  vtkDataSetAttributes(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkDataSetAttributes');\n\n// ----------------------------------------------------------------------------\n\nvar vtkDataSetAttributes$1 = {\n  newInstance,\n  extend,\n  ...Constants\n};\n\nexport { vtkDataSetAttributes$1 as default, extend, newInstance };\n","// Specify how data arrays can be used by data objects\nconst FieldDataTypes = {\n  UNIFORM: 0,\n  // data that does not vary over points/cells/etc.\n  DATA_OBJECT_FIELD: 0,\n  // to match VTK\n\n  COORDINATE: 1,\n  // data that specifies the location of each point\n  POINT_DATA: 1,\n  // to match VTK\n\n  POINT: 2,\n  // data defined at each point, but that does not specify the point location\n  POINT_FIELD_DATA: 2,\n  // to match VTK\n\n  CELL: 3,\n  // data defined at each cell, but that does not specify the cell\n  CELL_FIELD_DATA: 3,\n  // to match VTK\n\n  VERTEX: 4,\n  // data defined at each graph vertex, but that does not specify the graph vertex\n  VERTEX_FIELD_DATA: 4,\n  // to match VTK\n\n  EDGE: 5,\n  // data defined at each graph edge, but that does not specify the graph edge\n  EDGE_FIELD_DATA: 5,\n  // to match VTK\n\n  ROW: 6,\n  // data specifying a table row\n  ROW_DATA: 6 // to match VTK\n};\n\nconst FieldAssociations = {\n  FIELD_ASSOCIATION_POINTS: 0,\n  FIELD_ASSOCIATION_CELLS: 1,\n  FIELD_ASSOCIATION_NONE: 2,\n  FIELD_ASSOCIATION_POINTS_THEN_CELLS: 3,\n  FIELD_ASSOCIATION_VERTICES: 4,\n  FIELD_ASSOCIATION_EDGES: 5,\n  FIELD_ASSOCIATION_ROWS: 6,\n  NUMBER_OF_ASSOCIATIONS: 7\n};\nvar Constants = {\n  FieldDataTypes,\n  FieldAssociations\n};\n\nexport { FieldAssociations, FieldDataTypes, Constants as default };\n","import { m as macro } from '../../macros2.js';\nimport vtk from '../../vtk.js';\nimport vtkDataSetAttributes from './DataSetAttributes.js';\nimport Constants from './DataSet/Constants.js';\n\n// import vtkBoundingBox from '../BoundingBox';\n// import * as vtkMath from '../../Core/Math';\n//\n// function getBounds(dataset) {\n//   if (dataset.bounds) {\n//     return dataset.bounds;\n//   }\n//   if (dataset.type && dataset[dataset.type]) {\n//     const ds = dataset[dataset.type];\n//     if (ds.bounds) {\n//       return ds.bounds;\n//     }\n//     if (ds.Points && ds.Points.bounds) {\n//       return ds.Points.bounds;\n//     }\n\n//     if (ds.Points && ds.Points.values) {\n//       const array = ds.Points.values;\n//       const bbox = [...vtkBoundingBox.INIT_BOUNDS];\n//       const size = array.length;\n//       const delta = ds.Points.numberOfComponents ? ds.Points.numberOfComponents : 3;\n//       for (let idx = 0; idx < size; idx += delta) {\n//         vtkBoundingBox.addPoint(bbox, array[idx * delta], array[(idx * delta) + 1], array[(idx * delta) + 2]);\n//       }\n//       ds.Points.bounds = bbox;\n//       return ds.Points.bounds;\n//     }\n//   }\n//   return vtkMath.createUninitializedBounds();\n// }\n\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n\nconst DATASET_FIELDS = ['pointData', 'cellData', 'fieldData'];\n\n// ----------------------------------------------------------------------------\n// vtkDataSet methods\n// ----------------------------------------------------------------------------\n\nfunction vtkDataSet(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkDataSet');\n\n  // Add dataset attributes\n  DATASET_FIELDS.forEach(fieldName => {\n    if (!model[fieldName]) {\n      model[fieldName] = vtkDataSetAttributes.newInstance();\n    } else {\n      model[fieldName] = vtk(model[fieldName]);\n    }\n  });\n  const superShallowCopy = publicAPI.shallowCopy;\n  publicAPI.shallowCopy = function (other) {\n    let debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    superShallowCopy(other, debug);\n    DATASET_FIELDS.forEach(fieldName => {\n      model[fieldName] = vtkDataSetAttributes.newInstance();\n      model[fieldName].shallowCopy(other.getReferenceByName(fieldName));\n    });\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  // pointData: null,\n  // cellData: null,\n  // fieldData: null,\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Object methods\n  macro.obj(publicAPI, model);\n  macro.setGet(publicAPI, model, DATASET_FIELDS);\n\n  // Object specific methods\n  vtkDataSet(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkDataSet');\n\n// ----------------------------------------------------------------------------\n\nvar vtkDataSet$1 = {\n  newInstance,\n  extend,\n  ...Constants\n};\n\nexport { vtkDataSet$1 as default, extend, newInstance };\n","const StructuredType = {\n  UNCHANGED: 0,\n  SINGLE_POINT: 1,\n  X_LINE: 2,\n  Y_LINE: 3,\n  Z_LINE: 4,\n  XY_PLANE: 5,\n  YZ_PLANE: 6,\n  XZ_PLANE: 7,\n  XYZ_GRID: 8,\n  EMPTY: 9\n};\nvar Constants = {\n  StructuredType\n};\n\nexport { StructuredType, Constants as default };\n","import Constants from './StructuredData/Constants.js';\n\nconst {\n  StructuredType\n} = Constants;\nfunction getDataDescriptionFromExtent(inExt) {\n  let dataDim = 0;\n  for (let i = 0; i < 3; ++i) {\n    if (inExt[i * 2] < inExt[i * 2 + 1]) {\n      dataDim++;\n    }\n  }\n  if (inExt[0] > inExt[1] || inExt[2] > inExt[3] || inExt[4] > inExt[5]) {\n    return StructuredType.EMPTY;\n  }\n  if (dataDim === 3) {\n    return StructuredType.XYZ_GRID;\n  }\n  if (dataDim === 2) {\n    if (inExt[0] === inExt[1]) {\n      return StructuredType.YZ_PLANE;\n    }\n    if (inExt[2] === inExt[3]) {\n      return StructuredType.XZ_PLANE;\n    }\n    return StructuredType.XY_PLANE;\n  }\n  if (dataDim === 1) {\n    if (inExt[0] < inExt[1]) {\n      return StructuredType.X_LINE;\n    }\n    if (inExt[2] < inExt[3]) {\n      return StructuredType.Y_LINE;\n    }\n    return StructuredType.Z_LINE;\n  }\n  return StructuredType.SINGLE_POINT;\n}\nvar vtkStructuredData = {\n  getDataDescriptionFromExtent,\n  ...Constants\n};\n\nexport { vtkStructuredData as default, getDataDescriptionFromExtent };\n","import { m as macro } from '../../macros2.js';\nimport { b as roundVector, c as clampVector } from '../Core/Math/index.js';\nimport vtkBoundingBox from './BoundingBox.js';\nimport vtkDataSet from './DataSet.js';\nimport vtkStructuredData from './StructuredData.js';\nimport { StructuredType } from './StructuredData/Constants.js';\nimport { mat3, mat4, vec3 } from 'gl-matrix';\n\nconst {\n  vtkErrorMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// vtkImageData methods\n// ----------------------------------------------------------------------------\n\nfunction vtkImageData(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkImageData');\n  publicAPI.setExtent = function () {\n    if (model.deleted) {\n      vtkErrorMacro('instance deleted - cannot call any method');\n      return false;\n    }\n    for (var _len = arguments.length, inExtent = new Array(_len), _key = 0; _key < _len; _key++) {\n      inExtent[_key] = arguments[_key];\n    }\n    const extentArray = inExtent.length === 1 ? inExtent[0] : inExtent;\n    if (extentArray.length !== 6) {\n      return false;\n    }\n    const changeDetected = model.extent.some((item, index) => item !== extentArray[index]);\n    if (changeDetected) {\n      model.extent = extentArray.slice();\n      model.dataDescription = vtkStructuredData.getDataDescriptionFromExtent(model.extent);\n      publicAPI.modified();\n    }\n    return changeDetected;\n  };\n  publicAPI.setDimensions = function () {\n    let i;\n    let j;\n    let k;\n    if (model.deleted) {\n      vtkErrorMacro('instance deleted - cannot call any method');\n      return;\n    }\n    if (arguments.length === 1) {\n      const array = arguments.length <= 0 ? undefined : arguments[0];\n      i = array[0];\n      j = array[1];\n      k = array[2];\n    } else if (arguments.length === 3) {\n      i = arguments.length <= 0 ? undefined : arguments[0];\n      j = arguments.length <= 1 ? undefined : arguments[1];\n      k = arguments.length <= 2 ? undefined : arguments[2];\n    } else {\n      vtkErrorMacro('Bad dimension specification');\n      return;\n    }\n    publicAPI.setExtent(0, i - 1, 0, j - 1, 0, k - 1);\n  };\n  publicAPI.getDimensions = () => [model.extent[1] - model.extent[0] + 1, model.extent[3] - model.extent[2] + 1, model.extent[5] - model.extent[4] + 1];\n  publicAPI.getNumberOfCells = () => {\n    const dims = publicAPI.getDimensions();\n    let nCells = 1;\n    for (let i = 0; i < 3; i++) {\n      if (dims[i] === 0) {\n        return 0;\n      }\n      if (dims[i] > 1) {\n        nCells *= dims[i] - 1;\n      }\n    }\n    return nCells;\n  };\n  publicAPI.getNumberOfPoints = () => {\n    const dims = publicAPI.getDimensions();\n    return dims[0] * dims[1] * dims[2];\n  };\n  publicAPI.getPoint = index => {\n    const dims = publicAPI.getDimensions();\n    if (dims[0] === 0 || dims[1] === 0 || dims[2] === 0) {\n      vtkErrorMacro('Requesting a point from an empty image.');\n      return null;\n    }\n    const ijk = new Float64Array(3);\n    switch (model.dataDescription) {\n      case StructuredType.EMPTY:\n        return null;\n      case StructuredType.SINGLE_POINT:\n        break;\n      case StructuredType.X_LINE:\n        ijk[0] = index;\n        break;\n      case StructuredType.Y_LINE:\n        ijk[1] = index;\n        break;\n      case StructuredType.Z_LINE:\n        ijk[2] = index;\n        break;\n      case StructuredType.XY_PLANE:\n        ijk[0] = index % dims[0];\n        ijk[1] = index / dims[0];\n        break;\n      case StructuredType.YZ_PLANE:\n        ijk[1] = index % dims[1];\n        ijk[2] = index / dims[1];\n        break;\n      case StructuredType.XZ_PLANE:\n        ijk[0] = index % dims[0];\n        ijk[2] = index / dims[0];\n        break;\n      case StructuredType.XYZ_GRID:\n        ijk[0] = index % dims[0];\n        ijk[1] = index / dims[0] % dims[1];\n        ijk[2] = index / (dims[0] * dims[1]);\n        break;\n      default:\n        vtkErrorMacro('Invalid dataDescription');\n        break;\n    }\n    const coords = [0, 0, 0];\n    publicAPI.indexToWorld(ijk, coords);\n    return coords;\n  };\n\n  // vtkCell *GetCell(vtkIdType cellId) VTK_OVERRIDE;\n  // void GetCell(vtkIdType cellId, vtkGenericCell *cell) VTK_OVERRIDE;\n  // void GetCellBounds(vtkIdType cellId, double bounds[6]) VTK_OVERRIDE;\n  // virtual vtkIdType FindPoint(double x, double y, double z)\n  // {\n  //   return this->vtkDataSet::FindPoint(x, y, z);\n  // }\n  // vtkIdType FindPoint(double x[3]) VTK_OVERRIDE;\n  // vtkIdType FindCell(\n  //   double x[3], vtkCell *cell, vtkIdType cellId, double tol2,\n  //   int& subId, double pcoords[3], double *weights) VTK_OVERRIDE;\n  // vtkIdType FindCell(\n  //   double x[3], vtkCell *cell, vtkGenericCell *gencell,\n  //   vtkIdType cellId, double tol2, int& subId,\n  //   double pcoords[3], double *weights) VTK_OVERRIDE;\n  // vtkCell *FindAndGetCell(double x[3], vtkCell *cell, vtkIdType cellId,\n  //                                 double tol2, int& subId, double pcoords[3],\n  //                                 double *weights) VTK_OVERRIDE;\n  // int GetCellType(vtkIdType cellId) VTK_OVERRIDE;\n  // void GetCellPoints(vtkIdType cellId, vtkIdList *ptIds) VTK_OVERRIDE\n  //   {vtkStructuredData::GetCellPoints(cellId,ptIds,this->DataDescription,\n  //                                     this->GetDimensions());}\n  // void GetPointCells(vtkIdType ptId, vtkIdList *cellIds) VTK_OVERRIDE\n  //   {vtkStructuredData::GetPointCells(ptId,cellIds,this->GetDimensions());}\n  // void ComputeBounds() VTK_OVERRIDE;\n  // int GetMaxCellSize() VTK_OVERRIDE {return 8;}; //voxel is the largest\n\n  publicAPI.getBounds = () => publicAPI.extentToBounds(publicAPI.getSpatialExtent());\n  publicAPI.extentToBounds = ex => vtkBoundingBox.transformBounds(ex, model.indexToWorld);\n  publicAPI.getSpatialExtent = () => vtkBoundingBox.inflate([...model.extent], 0.5);\n\n  // Internal, shouldn't need to call this manually.\n  publicAPI.computeTransforms = () => {\n    mat4.fromTranslation(model.indexToWorld, model.origin);\n    model.indexToWorld[0] = model.direction[0];\n    model.indexToWorld[1] = model.direction[1];\n    model.indexToWorld[2] = model.direction[2];\n    model.indexToWorld[4] = model.direction[3];\n    model.indexToWorld[5] = model.direction[4];\n    model.indexToWorld[6] = model.direction[5];\n    model.indexToWorld[8] = model.direction[6];\n    model.indexToWorld[9] = model.direction[7];\n    model.indexToWorld[10] = model.direction[8];\n    mat4.scale(model.indexToWorld, model.indexToWorld, model.spacing);\n    mat4.invert(model.worldToIndex, model.indexToWorld);\n  };\n  publicAPI.indexToWorld = function (ain) {\n    let aout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    vec3.transformMat4(aout, ain, model.indexToWorld);\n    return aout;\n  };\n  publicAPI.indexToWorldVec3 = publicAPI.indexToWorld;\n  publicAPI.worldToIndex = function (ain) {\n    let aout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    vec3.transformMat4(aout, ain, model.worldToIndex);\n    return aout;\n  };\n  publicAPI.worldToIndexVec3 = publicAPI.worldToIndex;\n  publicAPI.indexToWorldBounds = function (bin) {\n    let bout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    return vtkBoundingBox.transformBounds(bin, model.indexToWorld, bout);\n  };\n  publicAPI.worldToIndexBounds = function (bin) {\n    let bout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    return vtkBoundingBox.transformBounds(bin, model.worldToIndex, bout);\n  };\n\n  // Make sure the transform is correct\n  publicAPI.onModified(publicAPI.computeTransforms);\n  publicAPI.computeTransforms();\n  publicAPI.getCenter = () => vtkBoundingBox.getCenter(publicAPI.getBounds());\n  publicAPI.computeHistogram = function (worldBounds) {\n    let voxelFunc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    const bounds = [0, 0, 0, 0, 0, 0];\n    publicAPI.worldToIndexBounds(worldBounds, bounds);\n    const point1 = [0, 0, 0];\n    const point2 = [0, 0, 0];\n    vtkBoundingBox.computeCornerPoints(bounds, point1, point2);\n    roundVector(point1, point1);\n    roundVector(point2, point2);\n    const dimensions = publicAPI.getDimensions();\n    clampVector(point1, [0, 0, 0], [dimensions[0] - 1, dimensions[1] - 1, dimensions[2] - 1], point1);\n    clampVector(point2, [0, 0, 0], [dimensions[0] - 1, dimensions[1] - 1, dimensions[2] - 1], point2);\n    const yStride = dimensions[0];\n    const zStride = dimensions[0] * dimensions[1];\n    const pixels = publicAPI.getPointData().getScalars().getData();\n    let maximum = -Infinity;\n    let minimum = Infinity;\n    let sumOfSquares = 0;\n    let isum = 0;\n    let inum = 0;\n    for (let z = point1[2]; z <= point2[2]; z++) {\n      for (let y = point1[1]; y <= point2[1]; y++) {\n        let index = point1[0] + y * yStride + z * zStride;\n        for (let x = point1[0]; x <= point2[0]; x++) {\n          if (!voxelFunc || voxelFunc([x, y, z], bounds)) {\n            const pixel = pixels[index];\n            if (pixel > maximum) maximum = pixel;\n            if (pixel < minimum) minimum = pixel;\n            sumOfSquares += pixel * pixel;\n            isum += pixel;\n            inum += 1;\n          }\n          ++index;\n        }\n      }\n    }\n    const average = inum > 0 ? isum / inum : 0;\n    const variance = inum ? Math.abs(sumOfSquares / inum - average * average) : 0;\n    const sigma = Math.sqrt(variance);\n    return {\n      minimum,\n      maximum,\n      average,\n      variance,\n      sigma,\n      count: inum\n    };\n  };\n\n  // TODO: use the unimplemented `vtkDataSetAttributes` for scalar length, that is currently also a TODO (GetNumberOfComponents).\n  // Scalar data could be tuples for color information?\n  publicAPI.computeIncrements = function (extent) {\n    let numberOfComponents = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    const increments = [];\n    let incr = numberOfComponents;\n\n    // Calculate array increment offsets\n    // similar to c++ vtkImageData::ComputeIncrements\n    for (let idx = 0; idx < 3; ++idx) {\n      increments[idx] = incr;\n      incr *= extent[idx * 2 + 1] - extent[idx * 2] + 1;\n    }\n    return increments;\n  };\n\n  /**\n   * @param {Number[]} index the localized `[i,j,k]` pixel array position. Float values will be rounded.\n   * @return {Number} the corresponding flattened index in the scalar array\n   */\n  publicAPI.computeOffsetIndex = _ref => {\n    let [i, j, k] = _ref;\n    const extent = publicAPI.getExtent();\n    const numberOfComponents = publicAPI.getPointData().getScalars().getNumberOfComponents();\n    const increments = publicAPI.computeIncrements(extent, numberOfComponents);\n    // Use the array increments to find the pixel index\n    // similar to c++ vtkImageData::GetArrayPointer\n    // Math.floor to catch \"practically 0\" e^-15 scenarios.\n    return Math.floor((Math.round(i) - extent[0]) * increments[0] + (Math.round(j) - extent[2]) * increments[1] + (Math.round(k) - extent[4]) * increments[2]);\n  };\n\n  /**\n   * @param {Number[]} xyz the [x,y,z] Array in world coordinates\n   * @return {Number|NaN} the corresponding pixel's index in the scalar array\n   */\n  publicAPI.getOffsetIndexFromWorld = xyz => {\n    const extent = publicAPI.getExtent();\n    const index = publicAPI.worldToIndex(xyz);\n\n    // Confirm indexed i,j,k coords are within the bounds of the volume\n    for (let idx = 0; idx < 3; ++idx) {\n      if (index[idx] < extent[idx * 2] || index[idx] > extent[idx * 2 + 1]) {\n        vtkErrorMacro(`GetScalarPointer: Pixel ${index} is not in memory. Current extent = ${extent}`);\n        return NaN;\n      }\n    }\n\n    // Assumed the index here is within 0 <-> scalarData.length, but doesn't hurt to check upstream\n    return publicAPI.computeOffsetIndex(index);\n  };\n  /**\n   * @param {Number[]} xyz the [x,y,z] Array in world coordinates\n   * @param {Number?} comp the scalar component index for multi-component scalars\n   * @return {Number|NaN} the corresponding pixel's scalar value\n   */\n  publicAPI.getScalarValueFromWorld = function (xyz) {\n    let comp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    const numberOfComponents = publicAPI.getPointData().getScalars().getNumberOfComponents();\n    if (comp < 0 || comp >= numberOfComponents) {\n      vtkErrorMacro(`GetScalarPointer: Scalar Component ${comp} is not within bounds. Current Scalar numberOfComponents: ${numberOfComponents}`);\n      return NaN;\n    }\n    const offsetIndex = publicAPI.getOffsetIndexFromWorld(xyz);\n    if (Number.isNaN(offsetIndex)) {\n      // VTK Error Macro will have been tripped already, no need to do it again,\n      return offsetIndex;\n    }\n    return publicAPI.getPointData().getScalars().getComponent(offsetIndex, comp);\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  direction: null,\n  // a mat3\n  indexToWorld: null,\n  // a mat4\n  worldToIndex: null,\n  // a mat4\n  spacing: [1.0, 1.0, 1.0],\n  origin: [0.0, 0.0, 0.0],\n  extent: [0, -1, 0, -1, 0, -1],\n  dataDescription: StructuredType.EMPTY\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkDataSet.extend(publicAPI, model, initialValues);\n  if (!model.direction) {\n    model.direction = mat3.identity(new Float64Array(9));\n  } else if (Array.isArray(model.direction)) {\n    model.direction = new Float64Array(model.direction.slice(0, 9));\n  }\n  model.indexToWorld = new Float64Array(16);\n  model.worldToIndex = new Float64Array(16);\n\n  // Set/Get methods\n  macro.get(publicAPI, model, ['indexToWorld', 'worldToIndex']);\n  macro.setGetArray(publicAPI, model, ['origin', 'spacing'], 3);\n  macro.setGetArray(publicAPI, model, ['direction'], 9);\n  macro.getArray(publicAPI, model, ['extent'], 6);\n\n  // Object specific methods\n  vtkImageData(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkImageData');\n\n// ----------------------------------------------------------------------------\n\nvar vtkImageData$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkImageData$1 as default, extend, newInstance };\n","const Wrap = {\n  CLAMP_TO_EDGE: 0,\n  REPEAT: 1,\n  MIRRORED_REPEAT: 2\n};\nconst Filter = {\n  NEAREST: 0,\n  LINEAR: 1,\n  NEAREST_MIPMAP_NEAREST: 2,\n  NEAREST_MIPMAP_LINEAR: 3,\n  LINEAR_MIPMAP_NEAREST: 4,\n  LINEAR_MIPMAP_LINEAR: 5\n};\nvar Constants = {\n  Wrap,\n  Filter\n};\n\nexport { Filter, Wrap, Constants as default };\n","/* eslint-disable no-bitwise */\n\nconst floatView = new Float32Array(1);\nconst int32View = new Int32Array(floatView.buffer);\n\n/* eslint-disable no-bitwise */\n/* This method is faster than the OpenEXR implementation (very often\n * used, eg. in Ogre), with the additional benefit of rounding, inspired\n * by James Tursa?s half-precision code. */\nfunction toHalf(val) {\n  floatView[0] = val;\n  const x = int32View[0];\n  let bits = x >> 16 & 0x8000; /* Get the sign */\n  let m = x >> 12 & 0x07ff; /* Keep one extra bit for rounding */\n  const e = x >> 23 & 0xff; /* Using int is faster here */\n\n  /* If zero, or denormal, or exponent underflows too much for a denormal\n   * half, return signed zero. */\n  if (e < 103) {\n    return bits;\n  }\n\n  /* If NaN, return NaN. If Inf or exponent overflow, return Inf. */\n  if (e > 142) {\n    bits |= 0x7c00;\n    /* If exponent was 0xff and one mantissa bit was set, it means NaN,\n     * not Inf, so make sure we set one mantissa bit too. */\n    bits |= (e === 255 ? 0 : 1) && x & 0x007fffff;\n    return bits;\n  }\n\n  /* If exponent underflows but not too much, return a denormal */\n  if (e < 113) {\n    m |= 0x0800;\n    /* Extra rounding may overflow and set mantissa to 0 and exponent\n     * to 1, which is OK. */\n    bits |= (m >> 114 - e) + (m >> 113 - e & 1);\n    return bits;\n  }\n  bits |= e - 112 << 10 | m >> 1;\n  /* Extra rounding. An overflow will set mantissa to 0 and increment\n   * the exponent, which is OK. */\n  bits += m & 1;\n  return bits;\n}\nfunction fromHalf(h) {\n  const s = (h & 0x8000) >> 15;\n  const e = (h & 0x7c00) >> 10;\n  const f = h & 0x03ff;\n  if (e === 0) {\n    return (s ? -1 : 1) * 2 ** -14 * (f / 2 ** 10);\n  }\n  if (e === 0x1f) {\n    return f ? NaN : (s ? -1 : 1) * Infinity;\n  }\n  return (s ? -1 : 1) * 2 ** (e - 15) * (1 + f / 2 ** 10);\n}\nvar HalfFloat = {\n  fromHalf,\n  toHalf\n};\n\nexport { HalfFloat as default };\n","import { m as macro } from '../../macros2.js';\n\nconst {\n  vtkErrorMacro\n} = macro;\nconst PASS_TYPES = ['Build', 'Render'];\n\n// ----------------------------------------------------------------------------\n// vtkViewNode methods\n// ----------------------------------------------------------------------------\n\nfunction vtkViewNode(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkViewNode');\n\n  // Builds myself.\n  publicAPI.build = prepass => {};\n\n  // Renders myself\n  publicAPI.render = prepass => {};\n  publicAPI.traverse = renderPass => {\n    // we can choose to do special\n    // traversal here based on pass\n    const passTraversal = renderPass.getTraverseOperation();\n    const fn = publicAPI[passTraversal];\n    if (fn) {\n      fn(renderPass);\n      return;\n    }\n\n    // default traversal\n    publicAPI.apply(renderPass, true);\n    for (let index = 0; index < model.children.length; index++) {\n      model.children[index].traverse(renderPass);\n    }\n    publicAPI.apply(renderPass, false);\n  };\n  publicAPI.apply = (renderPass, prepass) => {\n    const customRenderPass = publicAPI[renderPass.getOperation()];\n    if (customRenderPass) {\n      customRenderPass(prepass, renderPass);\n    }\n  };\n  publicAPI.getViewNodeFor = dataObject => {\n    if (model.renderable === dataObject) {\n      return publicAPI;\n    }\n    for (let index = 0; index < model.children.length; ++index) {\n      const child = model.children[index];\n      const vn = child.getViewNodeFor(dataObject);\n      if (vn) {\n        return vn;\n      }\n    }\n    return undefined;\n  };\n  publicAPI.getFirstAncestorOfType = type => {\n    if (!model._parent) {\n      return null;\n    }\n    if (model._parent.isA(type)) {\n      return model._parent;\n    }\n    return model._parent.getFirstAncestorOfType(type);\n  };\n\n  // add a missing node/child for the passed in renderables. This should\n  // be called only in between prepareNodes and removeUnusedNodes\n  publicAPI.addMissingNode = dobj => {\n    if (!dobj) {\n      return;\n    }\n    const result = model._renderableChildMap.get(dobj);\n    // if found just mark as visited\n    if (result !== undefined) {\n      result.setVisited(true);\n    } else {\n      // otherwise create a node\n      const newNode = publicAPI.createViewNode(dobj);\n      if (newNode) {\n        newNode.setParent(publicAPI);\n        newNode.setVisited(true);\n        model._renderableChildMap.set(dobj, newNode);\n        model.children.push(newNode);\n      }\n    }\n  };\n\n  // add missing nodes/children for the passed in renderables. This should\n  // be called only in between prepareNodes and removeUnusedNodes\n  publicAPI.addMissingNodes = dataObjs => {\n    if (!dataObjs || !dataObjs.length) {\n      return;\n    }\n    for (let index = 0; index < dataObjs.length; ++index) {\n      const dobj = dataObjs[index];\n      const result = model._renderableChildMap.get(dobj);\n      // if found just mark as visited\n      if (result !== undefined) {\n        result.setVisited(true);\n      } else {\n        // otherwise create a node\n        const newNode = publicAPI.createViewNode(dobj);\n        if (newNode) {\n          newNode.setParent(publicAPI);\n          newNode.setVisited(true);\n          model._renderableChildMap.set(dobj, newNode);\n          model.children.push(newNode);\n        }\n      }\n    }\n  };\n\n  // ability to add children that have no renderable use in the same manner\n  // as addMissingNodes This case is when a normal viewnode wants to\n  // delegate passes to a helper or child that doeasn't map to a clear\n  // renderable or any renderable\n  publicAPI.addMissingChildren = children => {\n    if (!children || !children.length) {\n      return;\n    }\n    for (let index = 0; index < children.length; ++index) {\n      const child = children[index];\n      const cindex = model.children.indexOf(child);\n      if (cindex === -1) {\n        child.setParent(publicAPI);\n        model.children.push(child);\n      }\n      child.setVisited(true);\n    }\n  };\n  publicAPI.prepareNodes = () => {\n    for (let index = 0; index < model.children.length; ++index) {\n      model.children[index].setVisited(false);\n    }\n  };\n  publicAPI.setVisited = val => {\n    model.visited = val;\n  };\n  publicAPI.removeUnusedNodes = () => {\n    let visitedCount = 0;\n    for (let index = 0; index < model.children.length; ++index) {\n      const child = model.children[index];\n      const visited = child.getVisited();\n      if (visited) {\n        model.children[visitedCount++] = child;\n        child.setVisited(false);\n      } else {\n        const renderable = child.getRenderable();\n        if (renderable) {\n          model._renderableChildMap.delete(renderable);\n        }\n        child.delete();\n      }\n    }\n    model.children.length = visitedCount;\n  };\n  publicAPI.createViewNode = dataObj => {\n    if (!model.myFactory) {\n      vtkErrorMacro('Cannot create view nodes without my own factory');\n      return null;\n    }\n    const ret = model.myFactory.createNode(dataObj);\n    if (ret) {\n      ret.setRenderable(dataObj);\n    }\n    return ret;\n  };\n  const parentDelete = publicAPI.delete;\n  publicAPI.delete = () => {\n    for (let i = 0; i < model.children.length; i++) {\n      model.children[i].delete();\n    }\n    parentDelete();\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  // _parent: null,\n  renderable: null,\n  myFactory: null,\n  children: [],\n  visited: false\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Build VTK API\n  macro.obj(publicAPI, model);\n  macro.event(publicAPI, model, 'event');\n  model._renderableChildMap = new Map();\n  macro.get(publicAPI, model, ['visited']);\n  macro.setGet(publicAPI, model, ['_parent', 'renderable', 'myFactory']);\n  macro.getArray(publicAPI, model, ['children']);\n  macro.moveToProtected(publicAPI, model, ['parent']);\n\n  // Object methods\n  vtkViewNode(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkViewNode');\n\n// ----------------------------------------------------------------------------\n\nvar vtkViewNode$1 = {\n  newInstance,\n  extend,\n  PASS_TYPES\n};\n\nexport { vtkViewNode$1 as default };\n","import { m as macro } from '../../macros2.js';\n\n// ----------------------------------------------------------------------------\n// vtkViewNodeFactory methods\n// ----------------------------------------------------------------------------\n\nfunction vtkViewNodeFactory(publicAPI, model) {\n  // Make sure our overrides is just for our instance not shared with everyone...\n  if (!model.overrides) {\n    model.overrides = {};\n  }\n\n  // Set our className\n  model.classHierarchy.push('vtkViewNodeFactory');\n  publicAPI.createNode = dataObject => {\n    if (dataObject.isDeleted()) {\n      return null;\n    }\n    let cpt = 0;\n    let className = dataObject.getClassName(cpt++);\n    let isObject = false;\n    const keys = Object.keys(model.overrides);\n    while (className && !isObject) {\n      if (keys.indexOf(className) !== -1) {\n        isObject = true;\n      } else {\n        className = dataObject.getClassName(cpt++);\n      }\n    }\n    if (!isObject) {\n      return null;\n    }\n    const vn = model.overrides[className]();\n    vn.setMyFactory(publicAPI);\n    return vn;\n  };\n  publicAPI.registerOverride = (className, func) => {\n    model.overrides[className] = func;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  // overrides: {},\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Build VTK API\n  macro.obj(publicAPI, model);\n\n  // Object methods\n  vtkViewNodeFactory(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkViewNodeFactory');\n\n// ----------------------------------------------------------------------------\n\nvar vtkViewNodeFactory$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkViewNodeFactory$1 as default, extend, newInstance };\n","import { m as macro } from '../../macros2.js';\nimport vtkViewNodeFactory$1 from '../SceneGraph/ViewNodeFactory.js';\n\nconst CLASS_MAPPING = Object.create(null);\nfunction registerOverride(className, fn) {\n  CLASS_MAPPING[className] = fn;\n}\n\n// ----------------------------------------------------------------------------\n// vtkOpenGLViewNodeFactory methods\n// ----------------------------------------------------------------------------\n\nfunction vtkOpenGLViewNodeFactory(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLViewNodeFactory');\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Static class mapping shared across instances\n  model.overrides = CLASS_MAPPING;\n\n  // Inheritance\n  vtkViewNodeFactory$1.extend(publicAPI, model, initialValues);\n\n  // Object methods\n  vtkOpenGLViewNodeFactory(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkOpenGLViewNodeFactory');\n\n// ----------------------------------------------------------------------------\n\nvar vtkViewNodeFactory = {\n  newInstance,\n  extend\n};\n\nexport { vtkViewNodeFactory as default, extend, newInstance, registerOverride };\n","import Constants from './Texture/Constants.js';\nimport HalfFloat from '../../Common/Core/HalfFloat.js';\nimport { n as newInstance$1, o as obj, s as set, e as setGet, g as get, i as moveToProtected, a as newTypedArray, c as macro } from '../../macros2.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\nimport { S as isPowerOfTwo, O as nearestPowerOfTwo } from '../../Common/Core/Math/index.js';\nimport vtkViewNode from '../SceneGraph/ViewNode.js';\nimport { registerOverride } from './ViewNodeFactory.js';\n\nconst {\n  Wrap,\n  Filter\n} = Constants;\nconst {\n  VtkDataTypes\n} = vtkDataArray;\nconst {\n  vtkDebugMacro,\n  vtkErrorMacro,\n  vtkWarningMacro\n} = macro;\nconst {\n  toHalf\n} = HalfFloat;\n\n// ----------------------------------------------------------------------------\n// vtkOpenGLTexture methods\n// ----------------------------------------------------------------------------\n\nfunction vtkOpenGLTexture(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLTexture');\n  // Renders myself\n  publicAPI.render = function () {\n    let renWin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    if (renWin) {\n      model._openGLRenderWindow = renWin;\n    } else {\n      model._openGLRenderer = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderer');\n      // sync renderable properties\n      model._openGLRenderWindow = model._openGLRenderer.getParent();\n    }\n    model.context = model._openGLRenderWindow.getContext();\n    if (model.renderable.getInterpolate()) {\n      if (model.generateMipmap) {\n        publicAPI.setMinificationFilter(Filter.LINEAR_MIPMAP_LINEAR);\n      } else {\n        publicAPI.setMinificationFilter(Filter.LINEAR);\n      }\n      publicAPI.setMagnificationFilter(Filter.LINEAR);\n    } else {\n      publicAPI.setMinificationFilter(Filter.NEAREST);\n      publicAPI.setMagnificationFilter(Filter.NEAREST);\n    }\n    if (model.renderable.getRepeat()) {\n      publicAPI.setWrapR(Wrap.REPEAT);\n      publicAPI.setWrapS(Wrap.REPEAT);\n      publicAPI.setWrapT(Wrap.REPEAT);\n    }\n    // clear image if input data is set\n    if (model.renderable.getInputData()) {\n      model.renderable.setImage(null);\n    }\n    // create the texture if it is not done already\n    if (!model.handle || model.renderable.getMTime() > model.textureBuildTime.getMTime()) {\n      // if we have an Image\n      if (model.renderable.getImage() !== null) {\n        if (model.renderable.getInterpolate()) {\n          model.generateMipmap = true;\n          publicAPI.setMinificationFilter(Filter.LINEAR_MIPMAP_LINEAR);\n        }\n        // Have an Image which may not be complete\n        if (model.renderable.getImage() && model.renderable.getImageLoaded()) {\n          publicAPI.create2DFromImage(model.renderable.getImage());\n          publicAPI.activate();\n          publicAPI.sendParameters();\n          model.textureBuildTime.modified();\n        }\n      }\n      // if we have a canvas\n      if (model.renderable.getCanvas() !== null) {\n        if (model.renderable.getInterpolate()) {\n          model.generateMipmap = true;\n          publicAPI.setMinificationFilter(Filter.LINEAR_MIPMAP_LINEAR);\n        }\n        const canvas = model.renderable.getCanvas();\n        publicAPI.create2DFromRaw(canvas.width, canvas.height, 4, VtkDataTypes.UNSIGNED_CHAR, canvas, true);\n        publicAPI.activate();\n        publicAPI.sendParameters();\n        model.textureBuildTime.modified();\n      }\n      // if we have jsImageData\n      if (model.renderable.getJsImageData() !== null) {\n        const jsid = model.renderable.getJsImageData();\n        if (model.renderable.getInterpolate()) {\n          model.generateMipmap = true;\n          publicAPI.setMinificationFilter(Filter.LINEAR_MIPMAP_LINEAR);\n        }\n        publicAPI.create2DFromRaw(jsid.width, jsid.height, 4, VtkDataTypes.UNSIGNED_CHAR, jsid.data, true);\n        publicAPI.activate();\n        publicAPI.sendParameters();\n        model.textureBuildTime.modified();\n      }\n      // if we have InputData\n      const input = model.renderable.getInputData(0);\n      if (input && input.getPointData().getScalars()) {\n        const ext = input.getExtent();\n        const inScalars = input.getPointData().getScalars();\n\n        // do we have a cube map? Six inputs\n        const data = [];\n        for (let i = 0; i < model.renderable.getNumberOfInputPorts(); ++i) {\n          const indata = model.renderable.getInputData(i);\n          const scalars = indata ? indata.getPointData().getScalars().getData() : null;\n          if (scalars) {\n            data.push(scalars);\n          }\n        }\n        if (model.renderable.getInterpolate() && inScalars.getNumberOfComponents() === 4) {\n          model.generateMipmap = true;\n          publicAPI.setMinificationFilter(Filter.LINEAR_MIPMAP_LINEAR);\n        }\n        if (data.length % 6 === 0) {\n          publicAPI.createCubeFromRaw(ext[1] - ext[0] + 1, ext[3] - ext[2] + 1, inScalars.getNumberOfComponents(), inScalars.getDataType(), data);\n        } else {\n          publicAPI.create2DFromRaw(ext[1] - ext[0] + 1, ext[3] - ext[2] + 1, inScalars.getNumberOfComponents(), inScalars.getDataType(), inScalars.getData());\n        }\n        publicAPI.activate();\n        publicAPI.sendParameters();\n        model.textureBuildTime.modified();\n      }\n    }\n    if (model.handle) {\n      publicAPI.activate();\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.destroyTexture = () => {\n    // deactivate it first\n    publicAPI.deactivate();\n    if (model.context && model.handle) {\n      model.context.deleteTexture(model.handle);\n    }\n    model.handle = 0;\n    model.numberOfDimensions = 0;\n    model.target = 0;\n    model.components = 0;\n    model.width = 0;\n    model.height = 0;\n    model.depth = 0;\n    publicAPI.resetFormatAndType();\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.createTexture = () => {\n    // reuse the existing handle if we have one\n    if (!model.handle) {\n      model.handle = model.context.createTexture();\n      if (model.target) {\n        model.context.bindTexture(model.target, model.handle);\n\n        // See: http://www.openmodel.context..org/wiki/Common_Mistakes#Creating_a_complete_texture\n        // turn off mip map filter or set the base and max level correctly. here\n        // both are done.\n        model.context.texParameteri(model.target, model.context.TEXTURE_MIN_FILTER, publicAPI.getOpenGLFilterMode(model.minificationFilter));\n        model.context.texParameteri(model.target, model.context.TEXTURE_MAG_FILTER, publicAPI.getOpenGLFilterMode(model.magnificationFilter));\n        model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_S, publicAPI.getOpenGLWrapMode(model.wrapS));\n        model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_T, publicAPI.getOpenGLWrapMode(model.wrapT));\n        if (model._openGLRenderWindow.getWebgl2()) {\n          model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_R, publicAPI.getOpenGLWrapMode(model.wrapR));\n        }\n        model.context.bindTexture(model.target, null);\n      }\n    }\n  };\n\n  //---------------------------------------------------------------------------\n  publicAPI.getTextureUnit = () => {\n    if (model._openGLRenderWindow) {\n      return model._openGLRenderWindow.getTextureUnitForTexture(publicAPI);\n    }\n    return -1;\n  };\n\n  //---------------------------------------------------------------------------\n  publicAPI.activate = () => {\n    // activate a free texture unit for this texture\n    model._openGLRenderWindow.activateTexture(publicAPI);\n    publicAPI.bind();\n  };\n\n  //---------------------------------------------------------------------------\n  publicAPI.deactivate = () => {\n    if (model._openGLRenderWindow) {\n      model._openGLRenderWindow.deactivateTexture(publicAPI);\n    }\n  };\n\n  //---------------------------------------------------------------------------\n  publicAPI.releaseGraphicsResources = rwin => {\n    if (rwin && model.handle) {\n      rwin.activateTexture(publicAPI);\n      rwin.deactivateTexture(publicAPI);\n      model.context.deleteTexture(model.handle);\n      model.handle = 0;\n      model.numberOfDimensions = 0;\n      model.target = 0;\n      model.internalFormat = 0;\n      model.format = 0;\n      model.openGLDataType = 0;\n      model.components = 0;\n      model.width = 0;\n      model.height = 0;\n      model.depth = 0;\n      model.allocatedGPUMemoryInBytes = 0;\n    }\n    if (model.shaderProgram) {\n      model.shaderProgram.releaseGraphicsResources(rwin);\n      model.shaderProgram = null;\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.bind = () => {\n    model.context.bindTexture(model.target, model.handle);\n    if (model.autoParameters && publicAPI.getMTime() > model.sendParametersTime.getMTime()) {\n      publicAPI.sendParameters();\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.isBound = () => {\n    let result = false;\n    if (model.context && model.handle) {\n      let target = 0;\n      switch (model.target) {\n        case model.context.TEXTURE_2D:\n          target = model.context.TEXTURE_BINDING_2D;\n          break;\n        default:\n          vtkWarningMacro('impossible case');\n          break;\n      }\n      const oid = model.context.getIntegerv(target);\n      result = oid === model.handle;\n    }\n    return result;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.sendParameters = () => {\n    model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_S, publicAPI.getOpenGLWrapMode(model.wrapS));\n    model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_T, publicAPI.getOpenGLWrapMode(model.wrapT));\n    if (model._openGLRenderWindow.getWebgl2()) {\n      model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_R, publicAPI.getOpenGLWrapMode(model.wrapR));\n    }\n    model.context.texParameteri(model.target, model.context.TEXTURE_MIN_FILTER, publicAPI.getOpenGLFilterMode(model.minificationFilter));\n    model.context.texParameteri(model.target, model.context.TEXTURE_MAG_FILTER, publicAPI.getOpenGLFilterMode(model.magnificationFilter));\n    if (model._openGLRenderWindow.getWebgl2()) {\n      model.context.texParameteri(model.target, model.context.TEXTURE_BASE_LEVEL, model.baseLevel);\n      model.context.texParameteri(model.target, model.context.TEXTURE_MAX_LEVEL, model.maxLevel);\n    }\n\n    // model.context.texParameterf(model.target, model.context.TEXTURE_MIN_LOD, model.minLOD);\n    // model.context.texParameterf(model.target, model.context.TEXTURE_MAX_LOD, model.maxLOD);\n\n    model.sendParametersTime.modified();\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getInternalFormat = (vtktype, numComps) => {\n    if (!model._forceInternalFormat) {\n      model.internalFormat = publicAPI.getDefaultInternalFormat(vtktype, numComps);\n    }\n    if (!model.internalFormat) {\n      vtkDebugMacro(`Unable to find suitable internal format for T=${vtktype} NC= ${numComps}`);\n    }\n    return model.internalFormat;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getDefaultInternalFormat = (vtktype, numComps) => {\n    let result = 0;\n    // try default next\n    result = model._openGLRenderWindow.getDefaultTextureInternalFormat(vtktype, numComps, model.oglNorm16Ext, model.useHalfFloat);\n    if (result) {\n      return result;\n    }\n    if (!result) {\n      vtkDebugMacro('Unsupported internal texture type!');\n      vtkDebugMacro(`Unable to find suitable internal format for T=${vtktype} NC= ${numComps}`);\n    }\n    return result;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.setInternalFormat = iFormat => {\n    model._forceInternalFormat = true;\n    if (iFormat !== model.internalFormat) {\n      model.internalFormat = iFormat;\n      publicAPI.modified();\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getFormat = (vtktype, numComps) => {\n    model.format = publicAPI.getDefaultFormat(vtktype, numComps);\n    return model.format;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getDefaultFormat = (vtktype, numComps) => {\n    if (model._openGLRenderWindow.getWebgl2()) {\n      switch (numComps) {\n        case 1:\n          return model.context.RED;\n        case 2:\n          return model.context.RG;\n        case 3:\n          return model.context.RGB;\n        case 4:\n          return model.context.RGBA;\n        default:\n          return model.context.RGB;\n      }\n    } else {\n      // webgl1\n      switch (numComps) {\n        case 1:\n          return model.context.LUMINANCE;\n        case 2:\n          return model.context.LUMINANCE_ALPHA;\n        case 3:\n          return model.context.RGB;\n        case 4:\n          return model.context.RGBA;\n        default:\n          return model.context.RGB;\n      }\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.resetFormatAndType = () => {\n    model.format = 0;\n    model.internalFormat = 0;\n    model._forceInternalFormat = false;\n    model.openGLDataType = 0;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getDefaultDataType = vtkScalarType => {\n    // DON'T DEAL with VTK_CHAR as this is platform dependent.\n    if (model._openGLRenderWindow.getWebgl2()) {\n      switch (vtkScalarType) {\n        // case VtkDataTypes.SIGNED_CHAR:\n        //   return model.context.BYTE;\n        case VtkDataTypes.UNSIGNED_CHAR:\n          return model.context.UNSIGNED_BYTE;\n        // prefer norm16 since that is accurate compared to\n        // half float which is not\n        case model.oglNorm16Ext && !model.useHalfFloat && VtkDataTypes.SHORT:\n          return model.context.SHORT;\n        case model.oglNorm16Ext && !model.useHalfFloat && VtkDataTypes.UNSIGNED_SHORT:\n          return model.context.UNSIGNED_SHORT;\n        // use half float type\n        case model.useHalfFloat && VtkDataTypes.SHORT:\n          return model.context.HALF_FLOAT;\n        case model.useHalfFloat && VtkDataTypes.UNSIGNED_SHORT:\n          return model.context.HALF_FLOAT;\n        // case VtkDataTypes.INT:\n        //   return model.context.INT;\n        // case VtkDataTypes.UNSIGNED_INT:\n        //   return model.context.UNSIGNED_INT;\n        case VtkDataTypes.FLOAT:\n        case VtkDataTypes.VOID: // used for depth component textures.\n        default:\n          return model.context.FLOAT;\n      }\n    }\n    switch (vtkScalarType) {\n      // case VtkDataTypes.SIGNED_CHAR:\n      //   return model.context.BYTE;\n      case VtkDataTypes.UNSIGNED_CHAR:\n        return model.context.UNSIGNED_BYTE;\n      // case VtkDataTypes.SHORT:\n      //   return model.context.SHORT;\n      // case VtkDataTypes.UNSIGNED_SHORT:\n      //   return model.context.UNSIGNED_SHORT;\n      // case VtkDataTypes.INT:\n      //   return model.context.INT;\n      // case VtkDataTypes.UNSIGNED_INT:\n      //   return model.context.UNSIGNED_INT;\n      case VtkDataTypes.FLOAT:\n      case VtkDataTypes.VOID: // used for depth component textures.\n      default:\n        if (model.context.getExtension('OES_texture_float') && model.context.getExtension('OES_texture_float_linear')) {\n          return model.context.FLOAT;\n        }\n        {\n          const halfFloat = model.context.getExtension('OES_texture_half_float');\n          if (halfFloat && model.context.getExtension('OES_texture_half_float_linear')) {\n            return halfFloat.HALF_FLOAT_OES;\n          }\n        }\n        return model.context.UNSIGNED_BYTE;\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getOpenGLDataType = function (vtkScalarType) {\n    let forceUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (!model.openGLDataType || forceUpdate) {\n      model.openGLDataType = publicAPI.getDefaultDataType(vtkScalarType);\n    }\n    return model.openGLDataType;\n  };\n  publicAPI.getShiftAndScale = () => {\n    let shift = 0.0;\n    let scale = 1.0;\n\n    // for all float type internal formats\n    switch (model.openGLDataType) {\n      case model.context.BYTE:\n        scale = 127.5;\n        shift = scale - 128.0;\n        break;\n      case model.context.UNSIGNED_BYTE:\n        scale = 255.0;\n        shift = 0.0;\n        break;\n      case model.context.SHORT:\n        scale = 32767.5;\n        shift = scale - 32768.0;\n        break;\n      case model.context.UNSIGNED_SHORT:\n        scale = 65536.0;\n        shift = 0.0;\n        break;\n      case model.context.INT:\n        scale = 2147483647.5;\n        shift = scale - 2147483648.0;\n        break;\n      case model.context.UNSIGNED_INT:\n        scale = 4294967295.0;\n        shift = 0.0;\n        break;\n      case model.context.FLOAT:\n    }\n    return {\n      shift,\n      scale\n    };\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getOpenGLFilterMode = emode => {\n    switch (emode) {\n      case Filter.NEAREST:\n        return model.context.NEAREST;\n      case Filter.LINEAR:\n        return model.context.LINEAR;\n      case Filter.NEAREST_MIPMAP_NEAREST:\n        return model.context.NEAREST_MIPMAP_NEAREST;\n      case Filter.NEAREST_MIPMAP_LINEAR:\n        return model.context.NEAREST_MIPMAP_LINEAR;\n      case Filter.LINEAR_MIPMAP_NEAREST:\n        return model.context.LINEAR_MIPMAP_NEAREST;\n      case Filter.LINEAR_MIPMAP_LINEAR:\n        return model.context.LINEAR_MIPMAP_LINEAR;\n      default:\n        return model.context.NEAREST;\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getOpenGLWrapMode = vtktype => {\n    switch (vtktype) {\n      case Wrap.CLAMP_TO_EDGE:\n        return model.context.CLAMP_TO_EDGE;\n      case Wrap.REPEAT:\n        return model.context.REPEAT;\n      case Wrap.MIRRORED_REPEAT:\n        return model.context.MIRRORED_REPEAT;\n      default:\n        return model.context.CLAMP_TO_EDGE;\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  function updateArrayDataType(dataType, data) {\n    let depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    const pixData = [];\n    let pixCount = model.width * model.height * model.components;\n    if (depth) {\n      pixCount *= model.depth;\n    }\n\n    // if the opengl data type is float\n    // then the data array must be float\n    if (dataType !== VtkDataTypes.FLOAT && model.openGLDataType === model.context.FLOAT) {\n      for (let idx = 0; idx < data.length; idx++) {\n        if (data[idx]) {\n          const dataArrayToCopy = data[idx].length > pixCount ? data[idx].subarray(0, pixCount) : data[idx];\n          pixData.push(new Float32Array(dataArrayToCopy));\n        } else {\n          pixData.push(null);\n        }\n      }\n    }\n\n    // if the opengl data type is ubyte\n    // then the data array must be u8, we currently simply truncate the data\n    if (dataType !== VtkDataTypes.UNSIGNED_CHAR && model.openGLDataType === model.context.UNSIGNED_BYTE) {\n      for (let idx = 0; idx < data.length; idx++) {\n        if (data[idx]) {\n          const dataArrayToCopy = data[idx].length > pixCount ? data[idx].subarray(0, pixCount) : data[idx];\n          pixData.push(new Uint8Array(dataArrayToCopy));\n        } else {\n          pixData.push(null);\n        }\n      }\n    }\n\n    // if the opengl data type is half float\n    // then the data array must be u16\n    let halfFloat = false;\n    if (model._openGLRenderWindow.getWebgl2()) {\n      halfFloat = model.openGLDataType === model.context.HALF_FLOAT;\n    } else {\n      const halfFloatExt = model.context.getExtension('OES_texture_half_float');\n      halfFloat = halfFloatExt && model.openGLDataType === halfFloatExt.HALF_FLOAT_OES;\n    }\n    if (halfFloat) {\n      for (let idx = 0; idx < data.length; idx++) {\n        if (data[idx]) {\n          const newArray = new Uint16Array(pixCount);\n          const src = data[idx];\n          for (let i = 0; i < pixCount; i++) {\n            newArray[i] = toHalf(src[i]);\n          }\n          pixData.push(newArray);\n        } else {\n          pixData.push(null);\n        }\n      }\n    }\n\n    // The output has to be filled\n    if (pixData.length === 0) {\n      for (let i = 0; i < data.length; i++) {\n        pixData.push(data[i]);\n      }\n    }\n    return pixData;\n  }\n\n  //----------------------------------------------------------------------------\n  function scaleTextureToHighestPowerOfTwo(data) {\n    if (model._openGLRenderWindow.getWebgl2()) {\n      // No need if webGL2\n      return data;\n    }\n    const pixData = [];\n    const width = model.width;\n    const height = model.height;\n    const numComps = model.components;\n    if (data && (!isPowerOfTwo(width) || !isPowerOfTwo(height))) {\n      // Scale up the texture to the next highest power of two dimensions.\n      const halfFloat = model.context.getExtension('OES_texture_half_float');\n      const newWidth = nearestPowerOfTwo(width);\n      const newHeight = nearestPowerOfTwo(height);\n      const pixCount = newWidth * newHeight * model.components;\n      for (let idx = 0; idx < data.length; idx++) {\n        if (data[idx] !== null) {\n          let newArray = null;\n          const jFactor = height / newHeight;\n          const iFactor = width / newWidth;\n          let usingHalf = false;\n          if (model.openGLDataType === model.context.FLOAT) {\n            newArray = new Float32Array(pixCount);\n          } else if (halfFloat && model.openGLDataType === halfFloat.HALF_FLOAT_OES) {\n            newArray = new Uint16Array(pixCount);\n            usingHalf = true;\n          } else {\n            newArray = new Uint8Array(pixCount);\n          }\n          for (let j = 0; j < newHeight; j++) {\n            const joff = j * newWidth * numComps;\n            const jidx = j * jFactor;\n            let jlow = Math.floor(jidx);\n            let jhi = Math.ceil(jidx);\n            if (jhi >= height) {\n              jhi = height - 1;\n            }\n            const jmix = jidx - jlow;\n            const jmix1 = 1.0 - jmix;\n            jlow = jlow * width * numComps;\n            jhi = jhi * width * numComps;\n            for (let i = 0; i < newWidth; i++) {\n              const ioff = i * numComps;\n              const iidx = i * iFactor;\n              let ilow = Math.floor(iidx);\n              let ihi = Math.ceil(iidx);\n              if (ihi >= width) {\n                ihi = width - 1;\n              }\n              const imix = iidx - ilow;\n              ilow *= numComps;\n              ihi *= numComps;\n              for (let c = 0; c < numComps; c++) {\n                if (usingHalf) {\n                  newArray[joff + ioff + c] = HalfFloat.toHalf(HalfFloat.fromHalf(data[idx][jlow + ilow + c]) * jmix1 * (1.0 - imix) + HalfFloat.fromHalf(data[idx][jlow + ihi + c]) * jmix1 * imix + HalfFloat.fromHalf(data[idx][jhi + ilow + c]) * jmix * (1.0 - imix) + HalfFloat.fromHalf(data[idx][jhi + ihi + c]) * jmix * imix);\n                } else {\n                  newArray[joff + ioff + c] = data[idx][jlow + ilow + c] * jmix1 * (1.0 - imix) + data[idx][jlow + ihi + c] * jmix1 * imix + data[idx][jhi + ilow + c] * jmix * (1.0 - imix) + data[idx][jhi + ihi + c] * jmix * imix;\n                }\n              }\n            }\n          }\n          pixData.push(newArray);\n          model.width = newWidth;\n          model.height = newHeight;\n        } else {\n          pixData.push(null);\n        }\n      }\n    }\n\n    // The output has to be filled\n    if (pixData.length === 0) {\n      for (let i = 0; i < data.length; i++) {\n        pixData.push(data[i]);\n      }\n    }\n    return pixData;\n  }\n\n  //----------------------------------------------------------------------------\n  function useTexStorage(dataType) {\n    if (model._openGLRenderWindow) {\n      if (model.resizable || model.renderable?.getResizable()) {\n        // Cannot use texStorage if the texture is supposed to be resizable.\n        return false;\n      }\n      if (model._openGLRenderWindow.getWebgl2()) {\n        const webGLInfo = model._openGLRenderWindow.getGLInformations();\n        if (webGLInfo.RENDERER.value.match(/WebKit/gi) && navigator.platform.match(/Mac/gi) && model.oglNorm16Ext && (dataType === VtkDataTypes.UNSIGNED_SHORT || dataType === VtkDataTypes.SHORT)) {\n          // Cannot use texStorage with EXT_texture_norm16 textures on Mac M1 GPU.\n          // No errors reported but the texture is unusable.\n          return false;\n        }\n        // Use texStorage for WebGL2\n        return true;\n      }\n      return false;\n    }\n    return false;\n  }\n\n  //----------------------------------------------------------------------------\n  publicAPI.create2DFromRaw = function (width, height, numComps, dataType, data) {\n    let flip = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n    // Now determine the texture parameters using the arguments.\n    publicAPI.getOpenGLDataType(dataType, true);\n    publicAPI.getInternalFormat(dataType, numComps);\n    publicAPI.getFormat(dataType, numComps);\n    if (!model.internalFormat || !model.format || !model.openGLDataType) {\n      vtkErrorMacro('Failed to determine texture parameters.');\n      return false;\n    }\n    model.target = model.context.TEXTURE_2D;\n    model.components = numComps;\n    model.width = width;\n    model.height = height;\n    model.depth = 1;\n    model.numberOfDimensions = 2;\n    model._openGLRenderWindow.activateTexture(publicAPI);\n    publicAPI.createTexture();\n    publicAPI.bind();\n\n    // Create an array of texture with one texture\n    const dataArray = [data];\n    const pixData = updateArrayDataType(dataType, dataArray);\n    const scaledData = scaleTextureToHighestPowerOfTwo(pixData);\n\n    // Source texture data from the PBO.\n    model.context.pixelStorei(model.context.UNPACK_FLIP_Y_WEBGL, flip);\n    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);\n    if (useTexStorage(dataType)) {\n      model.context.texStorage2D(model.target, 1, model.internalFormat, model.width, model.height);\n      if (scaledData[0] != null) {\n        model.context.texSubImage2D(model.target, 0, 0, 0, model.width, model.height, model.format, model.openGLDataType, scaledData[0]);\n      }\n    } else {\n      model.context.texImage2D(model.target, 0, model.internalFormat, model.width, model.height, 0, model.format, model.openGLDataType, scaledData[0]);\n    }\n    if (model.generateMipmap) {\n      model.context.generateMipmap(model.target);\n    }\n\n    // always reset the flip\n    if (flip) {\n      model.context.pixelStorei(model.context.UNPACK_FLIP_Y_WEBGL, false);\n    }\n    model.allocatedGPUMemoryInBytes = model.width * model.height * model.depth * numComps * model._openGLRenderWindow.getDefaultTextureByteSize(dataType, model.oglNorm16Ext, model.useHalfFloat);\n    publicAPI.deactivate();\n    return true;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.createCubeFromRaw = (width, height, numComps, dataType, data) => {\n    // Now determine the texture parameters using the arguments.\n    publicAPI.getOpenGLDataType(dataType);\n    publicAPI.getInternalFormat(dataType, numComps);\n    publicAPI.getFormat(dataType, numComps);\n    if (!model.internalFormat || !model.format || !model.openGLDataType) {\n      vtkErrorMacro('Failed to determine texture parameters.');\n      return false;\n    }\n    model.target = model.context.TEXTURE_CUBE_MAP;\n    model.components = numComps;\n    model.width = width;\n    model.height = height;\n    model.depth = 1;\n    model.numberOfDimensions = 2;\n    model._openGLRenderWindow.activateTexture(publicAPI);\n    model.maxLevel = data.length / 6 - 1;\n    publicAPI.createTexture();\n    publicAPI.bind();\n    const pixData = updateArrayDataType(dataType, data);\n    const scaledData = scaleTextureToHighestPowerOfTwo(pixData);\n\n    // invert the data because opengl is messed up with cube maps\n    // and uses the old renderman standard with Y going down\n    // even though it is completely at odds with OpenGL standards\n    const invertedData = [];\n    let widthLevel = model.width;\n    let heightLevel = model.height;\n    for (let i = 0; i < scaledData.length; i++) {\n      if (i % 6 === 0 && i !== 0) {\n        widthLevel /= 2;\n        heightLevel /= 2;\n      }\n      invertedData[i] = newTypedArray(dataType, heightLevel * widthLevel * model.components);\n      for (let y = 0; y < heightLevel; ++y) {\n        const row1 = y * widthLevel * model.components;\n        const row2 = (heightLevel - y - 1) * widthLevel * model.components;\n        invertedData[i].set(scaledData[i].slice(row2, row2 + widthLevel * model.components), row1);\n      }\n    }\n\n    // Source texture data from the PBO.\n    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);\n    if (useTexStorage(dataType)) {\n      model.context.texStorage2D(model.target, 6, model.internalFormat, model.width, model.height);\n    }\n    // We get the 6 images\n    for (let i = 0; i < 6; i++) {\n      // For each mipmap level\n      let j = 0;\n      let w = model.width;\n      let h = model.height;\n      while (w >= 1 && h >= 1) {\n        // In webgl 1, all levels need to be defined. So if the latest level size is\n        // 8x8, we have to add 3 more null textures (4x4, 2x2, 1x1)\n        // In webgl 2, the attribute maxLevel will be use.\n        let tempData = null;\n        if (j <= model.maxLevel) {\n          tempData = invertedData[6 * j + i];\n        }\n        if (useTexStorage(dataType)) {\n          if (tempData != null) {\n            model.context.texSubImage2D(model.context.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, 0, 0, w, h, model.format, model.openGLDataType, tempData);\n          }\n        } else {\n          model.context.texImage2D(model.context.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, model.internalFormat, w, h, 0, model.format, model.openGLDataType, tempData);\n        }\n        j++;\n        w /= 2;\n        h /= 2;\n      }\n    }\n    model.allocatedGPUMemoryInBytes = model.width * model.height * model.depth * numComps * model._openGLRenderWindow.getDefaultTextureByteSize(dataType, model.oglNorm16Ext, model.useHalfFloat);\n    // generateMipmap must not be called here because we manually upload all levels\n    // if it is called, all levels will be overwritten\n\n    publicAPI.deactivate();\n    return true;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.createDepthFromRaw = (width, height, dataType, data) => {\n    // Now determine the texture parameters using the arguments.\n    publicAPI.getOpenGLDataType(dataType);\n    model.format = model.context.DEPTH_COMPONENT;\n    if (model._openGLRenderWindow.getWebgl2()) {\n      if (dataType === VtkDataTypes.FLOAT) {\n        model.internalFormat = model.context.DEPTH_COMPONENT32F;\n      } else {\n        model.internalFormat = model.context.DEPTH_COMPONENT16;\n      }\n    } else {\n      model.internalFormat = model.context.DEPTH_COMPONENT;\n    }\n    if (!model.internalFormat || !model.format || !model.openGLDataType) {\n      vtkErrorMacro('Failed to determine texture parameters.');\n      return false;\n    }\n    model.target = model.context.TEXTURE_2D;\n    model.components = 1;\n    model.width = width;\n    model.height = height;\n    model.depth = 1;\n    model.numberOfDimensions = 2;\n    model._openGLRenderWindow.activateTexture(publicAPI);\n    publicAPI.createTexture();\n    publicAPI.bind();\n\n    // Source texture data from the PBO.\n    // model.context.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\n    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);\n    if (useTexStorage(dataType)) {\n      model.context.texStorage2D(model.target, 1, model.internalFormat, model.width, model.height);\n      if (data != null) {\n        model.context.texSubImage2D(model.target, 0, 0, 0, model.width, model.height, model.format, model.openGLDataType, data);\n      }\n    } else {\n      model.context.texImage2D(model.target, 0, model.internalFormat, model.width, model.height, 0, model.format, model.openGLDataType, data);\n    }\n    if (model.generateMipmap) {\n      model.context.generateMipmap(model.target);\n    }\n    model.allocatedGPUMemoryInBytes = model.width * model.height * model.depth * model.components * model._openGLRenderWindow.getDefaultTextureByteSize(dataType, model.oglNorm16Ext, model.useHalfFloat);\n    publicAPI.deactivate();\n    return true;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.create2DFromImage = image => {\n    // Now determine the texture parameters using the arguments.\n    publicAPI.getOpenGLDataType(VtkDataTypes.UNSIGNED_CHAR);\n    publicAPI.getInternalFormat(VtkDataTypes.UNSIGNED_CHAR, 4);\n    publicAPI.getFormat(VtkDataTypes.UNSIGNED_CHAR, 4);\n    if (!model.internalFormat || !model.format || !model.openGLDataType) {\n      vtkErrorMacro('Failed to determine texture parameters.');\n      return false;\n    }\n    model.target = model.context.TEXTURE_2D;\n    model.components = 4;\n    model.depth = 1;\n    model.numberOfDimensions = 2;\n    model._openGLRenderWindow.activateTexture(publicAPI);\n    publicAPI.createTexture();\n    publicAPI.bind();\n\n    // Source texture data from the PBO.\n    // model.context.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\n    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);\n\n    // Scale up the texture to the next highest power of two dimensions (if needed) and flip y.\n    const needNearestPowerOfTwo = !model._openGLRenderWindow.getWebgl2() && (!isPowerOfTwo(image.width) || !isPowerOfTwo(image.height));\n    const canvas = document.createElement('canvas');\n    canvas.width = needNearestPowerOfTwo ? nearestPowerOfTwo(image.width) : image.width;\n    canvas.height = needNearestPowerOfTwo ? nearestPowerOfTwo(image.height) : image.height;\n    model.width = canvas.width;\n    model.height = canvas.height;\n    const ctx = canvas.getContext('2d');\n    ctx.translate(0, canvas.height);\n    ctx.scale(1, -1);\n    ctx.drawImage(image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height);\n    const safeImage = canvas;\n    if (useTexStorage(VtkDataTypes.UNSIGNED_CHAR)) {\n      model.context.texStorage2D(model.target, 1, model.internalFormat, model.width, model.height);\n      if (safeImage != null) {\n        model.context.texSubImage2D(model.target, 0, 0, 0, model.width, model.height, model.format, model.openGLDataType, safeImage);\n      }\n    } else {\n      model.context.texImage2D(model.target, 0, model.internalFormat, model.width, model.height, 0, model.format, model.openGLDataType, safeImage);\n    }\n    if (model.generateMipmap) {\n      model.context.generateMipmap(model.target);\n    }\n    model.allocatedGPUMemoryInBytes = model.width * model.height * model.depth * model.components * model._openGLRenderWindow.getDefaultTextureByteSize(VtkDataTypes.UNSIGNED_CHAR, model.oglNorm16Ext, model.useHalfFloat);\n    publicAPI.deactivate();\n    return true;\n  };\n\n  // Compute scale and offset per component from min and max per component\n  function computeScaleOffsets(min, max, numComps) {\n    const offset = new Array(numComps);\n    const scale = new Array(numComps);\n    for (let c = 0; c < numComps; ++c) {\n      offset[c] = min[c];\n      scale[c] = max[c] - min[c] || 1.0;\n    }\n    return {\n      scale,\n      offset\n    };\n  }\n\n  // HalfFloat only represents numbers between [-2048, 2048] exactly accurate,\n  // for numbers outside of this range there is a precision limitation\n  function hasExactHalfFloat(offset, scale) {\n    // Per Component\n    for (let c = 0; c < offset.length; c++) {\n      const min = offset[c];\n      const max = scale[c] + min;\n      if (min < -2048 || min > 2048 || max < -2048 || max > 2048) {\n        return false;\n      }\n    }\n    return true;\n  }\n  function setUseHalfFloat(dataType, offset, scale, preferSizeOverAccuracy) {\n    publicAPI.getOpenGLDataType(dataType);\n    let useHalfFloat = false;\n    if (model._openGLRenderWindow.getWebgl2()) {\n      useHalfFloat = model.openGLDataType === model.context.HALF_FLOAT;\n    } else {\n      const halfFloatExt = model.context.getExtension('OES_texture_half_float');\n      useHalfFloat = halfFloatExt && model.openGLDataType === halfFloatExt.HALF_FLOAT_OES;\n    }\n\n    // Don't consider halfFloat and convert back to Float when the range of data does not generate an accurate halfFloat\n    // AND it is not preferable to have a smaller texture than an exact texture.\n    const isHalfFloat = useHalfFloat && (hasExactHalfFloat(offset, scale) || preferSizeOverAccuracy);\n    model.useHalfFloat = isHalfFloat;\n  }\n  function processDataArray(dataArray, preferSizeOverAccuracy) {\n    const numComps = dataArray.getNumberOfComponents();\n    const dataType = dataArray.getDataType();\n    const data = dataArray.getData();\n\n    // Compute min max from array\n    // Using the vtkDataArray.getRange() enables caching\n    const minArray = new Array(numComps);\n    const maxArray = new Array(numComps);\n    for (let c = 0; c < numComps; ++c) {\n      const [min, max] = dataArray.getRange(c);\n      minArray[c] = min;\n      maxArray[c] = max;\n    }\n    const scaleOffsets = computeScaleOffsets(minArray, maxArray, numComps);\n\n    // preferSizeOverAccuracy will override norm16 due to bug with norm16 implementation\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=1408247\n    setUseHalfFloat(dataType, scaleOffsets.offset, scaleOffsets.scale, preferSizeOverAccuracy);\n\n    // since our default is to use half float, in case that we can't use it\n    // we need to use another type\n    if (!model.useHalfFloat) {\n      publicAPI.getOpenGLDataType(dataType, true);\n    }\n    return {\n      numComps,\n      dataType,\n      data,\n      scaleOffsets\n    };\n  }\n  publicAPI.create2DFilterableFromRaw = function (width, height, numberOfComponents, dataType, values) {\n    let preferSizeOverAccuracy = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n    return publicAPI.create2DFilterableFromDataArray(width, height, vtkDataArray.newInstance({\n      numberOfComponents,\n      dataType,\n      values\n    }), preferSizeOverAccuracy);\n  };\n  publicAPI.create2DFilterableFromDataArray = function (width, height, dataArray) {\n    let preferSizeOverAccuracy = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    const {\n      numComps,\n      dataType,\n      data\n    } = processDataArray(dataArray, preferSizeOverAccuracy);\n    publicAPI.create2DFromRaw(width, height, numComps, dataType, data);\n  };\n  //----------------------------------------------------------------------------\n  publicAPI.create3DFromRaw = (width, height, depth, numComps, dataType, data) => {\n    // Permit OpenGLDataType to be half float, if applicable, for 3D\n    publicAPI.getOpenGLDataType(dataType);\n\n    // Now determine the texture parameters using the arguments.\n    publicAPI.getInternalFormat(dataType, numComps);\n    publicAPI.getFormat(dataType, numComps);\n    if (!model.internalFormat || !model.format || !model.openGLDataType) {\n      vtkErrorMacro('Failed to determine texture parameters.');\n      return false;\n    }\n    model.target = model.context.TEXTURE_3D;\n    model.components = numComps;\n    model.width = width;\n    model.height = height;\n    model.depth = depth;\n    model.numberOfDimensions = 3;\n    model._openGLRenderWindow.activateTexture(publicAPI);\n    publicAPI.createTexture();\n    publicAPI.bind();\n    // Create an array of texture with one texture\n    const dataArray = [data];\n    const is3DArray = true;\n    const pixData = updateArrayDataType(dataType, dataArray, is3DArray);\n    const scaledData = scaleTextureToHighestPowerOfTwo(pixData);\n\n    // Source texture data from the PBO.\n    // model.context.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\n    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);\n\n    // openGLDataType\n\n    if (useTexStorage(dataType)) {\n      model.context.texStorage3D(model.target, 1, model.internalFormat, model.width, model.height, model.depth);\n      if (scaledData[0] != null) {\n        model.context.texSubImage3D(model.target, 0, 0, 0, 0, model.width, model.height, model.depth, model.format, model.openGLDataType, scaledData[0]);\n      }\n    } else {\n      model.context.texImage3D(model.target, 0, model.internalFormat, model.width, model.height, model.depth, 0, model.format, model.openGLDataType, scaledData[0]);\n    }\n    if (model.generateMipmap) {\n      model.context.generateMipmap(model.target);\n    }\n    model.allocatedGPUMemoryInBytes = model.width * model.height * model.depth * model.components * model._openGLRenderWindow.getDefaultTextureByteSize(dataType, model.oglNorm16Ext, model.useHalfFloat);\n    publicAPI.deactivate();\n    return true;\n  };\n\n  //----------------------------------------------------------------------------\n  // This method simulates a 3D texture using 2D\n  // Prefer create3DFilterableFromDataArray to enable caching of min and max values\n  publicAPI.create3DFilterableFromRaw = function (width, height, depth, numberOfComponents, dataType, values) {\n    let preferSizeOverAccuracy = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n    return publicAPI.create3DFilterableFromDataArray(width, height, depth, vtkDataArray.newInstance({\n      numberOfComponents,\n      dataType,\n      values\n    }), preferSizeOverAccuracy);\n  };\n\n  //----------------------------------------------------------------------------\n  // This method create a 3D texture from dimensions and a DataArray\n  publicAPI.create3DFilterableFromDataArray = function (width, height, depth, dataArray) {\n    let preferSizeOverAccuracy = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    const {\n      numComps,\n      dataType,\n      data,\n      scaleOffsets\n    } = processDataArray(dataArray, preferSizeOverAccuracy);\n    const numPixelsIn = width * height * depth;\n    const offset = [];\n    const scale = [];\n    for (let c = 0; c < numComps; ++c) {\n      offset[c] = 0.0;\n      scale[c] = 1.0;\n    }\n\n    // store the information, we will need it later\n    // offset and scale are the offset and scale required to get\n    // the texture value back to data values ala\n    // data = texture * scale + offset\n    // and texture = (data - offset)/scale\n    model.volumeInfo = {\n      scale,\n      offset,\n      dataComputedScale: scaleOffsets.scale,\n      dataComputedOffset: scaleOffsets.offset,\n      width,\n      height,\n      depth\n    };\n\n    // Create a copy of scale and offset to avoid aliasing issues\n    // Original is read only, copy is read/write\n    // Use the copy as volumeInfo.scale and volumeInfo.offset\n    const scaleOffsetsCopy = structuredClone(scaleOffsets);\n\n    // WebGL2 path, we have 3d textures etc\n    if (model._openGLRenderWindow.getWebgl2()) {\n      if (model.oglNorm16Ext && !model.useHalfFloat && dataType === VtkDataTypes.SHORT) {\n        for (let c = 0; c < numComps; ++c) {\n          model.volumeInfo.scale[c] = 32767.0;\n        }\n        return publicAPI.create3DFromRaw(width, height, depth, numComps, dataType, data);\n      }\n      if (model.oglNorm16Ext && !model.useHalfFloat && dataType === VtkDataTypes.UNSIGNED_SHORT) {\n        for (let c = 0; c < numComps; ++c) {\n          model.volumeInfo.scale[c] = 65535.0;\n        }\n        return publicAPI.create3DFromRaw(width, height, depth, numComps, dataType, data);\n      }\n      if (dataType === VtkDataTypes.FLOAT || model.useHalfFloat && (dataType === VtkDataTypes.SHORT || dataType === VtkDataTypes.UNSIGNED_SHORT)) {\n        return publicAPI.create3DFromRaw(width, height, depth, numComps, dataType, data);\n      }\n      if (dataType === VtkDataTypes.UNSIGNED_CHAR) {\n        for (let c = 0; c < numComps; ++c) {\n          model.volumeInfo.scale[c] = 255.0;\n        }\n        return publicAPI.create3DFromRaw(width, height, depth, numComps, dataType, data);\n      }\n      // otherwise convert to float\n      const newArray = new Float32Array(numPixelsIn * numComps);\n      // use computed scale and offset\n      model.volumeInfo.offset = scaleOffsetsCopy.offset;\n      model.volumeInfo.scale = scaleOffsetsCopy.scale;\n      let count = 0;\n      const scaleInverse = scaleOffsetsCopy.scale.map(s => 1 / s);\n      for (let i = 0; i < numPixelsIn; i++) {\n        for (let nc = 0; nc < numComps; nc++) {\n          newArray[count] = (data[count] - scaleOffsetsCopy.offset[nc]) * scaleInverse[nc];\n          count++;\n        }\n      }\n      return publicAPI.create3DFromRaw(width, height, depth, numComps, VtkDataTypes.FLOAT, newArray);\n    }\n\n    // not webgl2, deal with webgl1, no 3d textures\n    // and maybe no float textures\n\n    let volCopyData = (outArray, outIdx, inValue, smin, smax) => {\n      outArray[outIdx] = inValue;\n    };\n    let dataTypeToUse = VtkDataTypes.UNSIGNED_CHAR;\n    // unsigned char gets used as is\n    if (dataType === VtkDataTypes.UNSIGNED_CHAR) {\n      for (let c = 0; c < numComps; ++c) {\n        scaleOffsetsCopy.offset[c] = 0.0;\n        scaleOffsetsCopy.scale[c] = 255.0;\n      }\n    } else if (model.context.getExtension('OES_texture_float') && model.context.getExtension('OES_texture_float_linear')) {\n      // use float textures scaled to 0.0 to 1.0\n      dataTypeToUse = VtkDataTypes.FLOAT;\n      volCopyData = (outArray, outIdx, inValue, soffset, sscale) => {\n        outArray[outIdx] = (inValue - soffset) / sscale;\n      };\n    } else {\n      // worst case, scale data to uchar\n      dataTypeToUse = VtkDataTypes.UNSIGNED_CHAR;\n      volCopyData = (outArray, outIdx, inValue, soffset, sscale) => {\n        outArray[outIdx] = 255.0 * (inValue - soffset) / sscale;\n      };\n    }\n\n    // Now determine the texture parameters using the arguments.\n    publicAPI.getOpenGLDataType(dataTypeToUse);\n    publicAPI.getInternalFormat(dataTypeToUse, numComps);\n    publicAPI.getFormat(dataTypeToUse, numComps);\n    if (!model.internalFormat || !model.format || !model.openGLDataType) {\n      vtkErrorMacro('Failed to determine texture parameters.');\n      return false;\n    }\n\n    // have to pack this 3D texture into pot 2D texture\n    model.target = model.context.TEXTURE_2D;\n    model.components = numComps;\n    model.depth = 1;\n    model.numberOfDimensions = 2;\n\n    // MAX_TEXTURE_SIZE gives the max dimensions that can be supported by the GPU,\n    // but it doesn't mean it will fit in memory. If we have to use a float data type\n    // or 4 components, there are good chances that the texture size will blow up\n    // and could not fit in the GPU memory. Use a smaller texture size in that case,\n    // which will force a downsampling of the dataset.\n    // That problem does not occur when using webGL2 since we can pack the data in\n    // denser textures based on our data type.\n    // TODO: try to fit in the biggest supported texture, catch the gl error if it\n    // does not fix (OUT_OF_MEMORY), then attempt with smaller texture\n    let maxTexDim = model.context.getParameter(model.context.MAX_TEXTURE_SIZE);\n    if (maxTexDim > 4096 && (dataTypeToUse === VtkDataTypes.FLOAT || numComps >= 3)) {\n      maxTexDim = 4096;\n    }\n\n    // compute estimate for XY subsample\n    let xstride = 1;\n    let ystride = 1;\n    if (numPixelsIn > maxTexDim * maxTexDim) {\n      xstride = Math.ceil(Math.sqrt(numPixelsIn / (maxTexDim * maxTexDim)));\n      ystride = xstride;\n    }\n    let targetWidth = Math.sqrt(numPixelsIn) / xstride;\n    targetWidth = nearestPowerOfTwo(targetWidth);\n    // determine X reps\n    const xreps = Math.floor(targetWidth * xstride / width);\n    const yreps = Math.ceil(depth / xreps);\n    const targetHeight = nearestPowerOfTwo(height * yreps / ystride);\n    model.width = targetWidth;\n    model.height = targetHeight;\n    model._openGLRenderWindow.activateTexture(publicAPI);\n    publicAPI.createTexture();\n    publicAPI.bind();\n\n    // store the information, we will need it later\n    model.volumeInfo.xreps = xreps;\n    model.volumeInfo.yreps = yreps;\n    model.volumeInfo.xstride = xstride;\n    model.volumeInfo.ystride = ystride;\n    model.volumeInfo.offset = scaleOffsetsCopy.offset;\n    model.volumeInfo.scale = scaleOffsetsCopy.scale;\n\n    // OK stuff the data into the 2d TEXTURE\n\n    // first allocate the new texture\n    let newArray;\n    const pixCount = targetWidth * targetHeight * numComps;\n    if (dataTypeToUse === VtkDataTypes.FLOAT) {\n      newArray = new Float32Array(pixCount);\n    } else {\n      newArray = new Uint8Array(pixCount);\n    }\n\n    // then stuff the data into it, nothing fancy right now\n    // for stride\n    let outIdx = 0;\n    const tileWidth = Math.floor(width / xstride);\n    const tileHeight = Math.floor(height / ystride);\n    for (let yRep = 0; yRep < yreps; yRep++) {\n      const xrepsThisRow = Math.min(xreps, depth - yRep * xreps);\n      const outXContIncr = numComps * (model.width - xrepsThisRow * Math.floor(width / xstride));\n      for (let tileY = 0; tileY < tileHeight; tileY++) {\n        for (let xRep = 0; xRep < xrepsThisRow; xRep++) {\n          const inOffset = numComps * ((yRep * xreps + xRep) * width * height + ystride * tileY * width);\n          for (let tileX = 0; tileX < tileWidth; tileX++) {\n            // copy value\n            for (let nc = 0; nc < numComps; nc++) {\n              volCopyData(newArray, outIdx, data[inOffset + xstride * tileX * numComps + nc], scaleOffsetsCopy.offset[nc], scaleOffsetsCopy.scale[nc]);\n              outIdx++;\n            }\n          }\n        }\n        outIdx += outXContIncr;\n      }\n    }\n\n    // Source texture data from the PBO.\n    // model.context.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\n    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);\n    if (useTexStorage(dataTypeToUse)) {\n      model.context.texStorage2D(model.target, 1, model.internalFormat, model.width, model.height);\n      if (newArray != null) {\n        model.context.texSubImage2D(model.target, 0, 0, 0, model.width, model.height, model.format, model.openGLDataType, newArray);\n      }\n    } else {\n      model.context.texImage2D(model.target, 0, model.internalFormat, model.width, model.height, 0, model.format, model.openGLDataType, newArray);\n    }\n    publicAPI.deactivate();\n    return true;\n  };\n  publicAPI.setOpenGLRenderWindow = rw => {\n    if (model._openGLRenderWindow === rw) {\n      return;\n    }\n    publicAPI.releaseGraphicsResources();\n    model._openGLRenderWindow = rw;\n    model.context = null;\n    if (rw) {\n      model.context = model._openGLRenderWindow.getContext();\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getMaximumTextureSize = ctx => {\n    if (ctx && ctx.isCurrent()) {\n      return ctx.getIntegerv(ctx.MAX_TEXTURE_SIZE);\n    }\n    return -1;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  _openGLRenderWindow: null,\n  _forceInternalFormat: false,\n  context: null,\n  handle: 0,\n  sendParametersTime: null,\n  textureBuildTime: null,\n  numberOfDimensions: 0,\n  target: 0,\n  format: 0,\n  openGLDataType: 0,\n  components: 0,\n  width: 0,\n  height: 0,\n  depth: 0,\n  autoParameters: true,\n  wrapS: Wrap.CLAMP_TO_EDGE,\n  wrapT: Wrap.CLAMP_TO_EDGE,\n  wrapR: Wrap.CLAMP_TO_EDGE,\n  minificationFilter: Filter.NEAREST,\n  magnificationFilter: Filter.NEAREST,\n  minLOD: -1000.0,\n  maxLOD: 1000.0,\n  baseLevel: 0,\n  maxLevel: 1000,\n  generateMipmap: false,\n  // use half float by default, but it will get set\n  // to false if the context does not support it or\n  // the voxel intensity range is out of the accurate\n  // range of half float\n  useHalfFloat: true,\n  oglNorm16Ext: null,\n  allocatedGPUMemoryInBytes: 0\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkViewNode.extend(publicAPI, model, initialValues);\n  model.sendParametersTime = {};\n  obj(model.sendParametersTime, {\n    mtime: 0\n  });\n  model.textureBuildTime = {};\n  obj(model.textureBuildTime, {\n    mtime: 0\n  });\n\n  // Build VTK API\n  set(publicAPI, model, ['format', 'openGLDataType']);\n  setGet(publicAPI, model, ['keyMatrixTime', 'minificationFilter', 'magnificationFilter', 'wrapS', 'wrapT', 'wrapR', 'generateMipmap', 'oglNorm16Ext']);\n  get(publicAPI, model, ['width', 'height', 'volumeInfo', 'components', 'handle', 'target', 'allocatedGPUMemoryInBytes']);\n  moveToProtected(publicAPI, model, ['openGLRenderWindow']);\n\n  // Object methods\n  vtkOpenGLTexture(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = newInstance$1(extend, 'vtkOpenGLTexture');\n\n// ----------------------------------------------------------------------------\n\nvar vtkOpenGLTexture$1 = {\n  newInstance,\n  extend,\n  ...Constants\n};\n\n// Register ourself to OpenGL backend if imported\nregisterOverride('vtkTexture', newInstance);\n\nexport { vtkOpenGLTexture$1 as default, extend, newInstance };\n","import { m as macro } from '../../macros2.js';\nimport vtkDataArray from './DataArray.js';\nimport { VtkDataTypes } from './DataArray/Constants.js';\n\nconst {\n  vtkErrorMacro\n} = macro;\nconst INVALID_BOUNDS = [1, -1, 1, -1, 1, -1];\n\n// ----------------------------------------------------------------------------\n// vtkPoints methods\n// ----------------------------------------------------------------------------\n\nfunction vtkPoints(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkPoints');\n\n  // Forwarding methods\n  publicAPI.getNumberOfPoints = publicAPI.getNumberOfTuples;\n  publicAPI.setNumberOfPoints = function (nbPoints) {\n    let dimension = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;\n    if (publicAPI.getNumberOfPoints() !== nbPoints) {\n      model.size = nbPoints * dimension;\n      model.values = macro.newTypedArray(model.dataType, model.size);\n      publicAPI.setNumberOfComponents(dimension);\n      publicAPI.modified();\n    }\n  };\n  publicAPI.setPoint = function (idx) {\n    for (var _len = arguments.length, xyz = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      xyz[_key - 1] = arguments[_key];\n    }\n    publicAPI.setTuple(idx, xyz);\n  };\n  publicAPI.getPoint = publicAPI.getTuple;\n  publicAPI.findPoint = publicAPI.findTuple;\n  publicAPI.insertNextPoint = (x, y, z) => publicAPI.insertNextTuple([x, y, z]);\n  publicAPI.getBounds = () => {\n    if (publicAPI.getNumberOfComponents() === 3) {\n      const xRange = publicAPI.getRange(0);\n      model.bounds[0] = xRange[0];\n      model.bounds[1] = xRange[1];\n      const yRange = publicAPI.getRange(1);\n      model.bounds[2] = yRange[0];\n      model.bounds[3] = yRange[1];\n      const zRange = publicAPI.getRange(2);\n      model.bounds[4] = zRange[0];\n      model.bounds[5] = zRange[1];\n      return model.bounds;\n    }\n    if (publicAPI.getNumberOfComponents() !== 2) {\n      vtkErrorMacro(`getBounds called on an array with components of\n        ${publicAPI.getNumberOfComponents()}`);\n      return INVALID_BOUNDS;\n    }\n    const xRange = publicAPI.getRange(0);\n    model.bounds[0] = xRange[0];\n    model.bounds[1] = xRange[1];\n    const yRange = publicAPI.getRange(1);\n    model.bounds[2] = yRange[0];\n    model.bounds[3] = yRange[1];\n    model.bounds[4] = 0;\n    model.bounds[5] = 0;\n    return model.bounds;\n  };\n\n  // Trigger the computation of bounds\n  publicAPI.computeBounds = publicAPI.getBounds;\n\n  // Initialize\n  publicAPI.setNumberOfComponents(model.numberOfComponents < 2 ? 3 : model.numberOfComponents);\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  empty: true,\n  numberOfComponents: 3,\n  dataType: VtkDataTypes.FLOAT,\n  bounds: [1, -1, 1, -1, 1, -1]\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n  vtkDataArray.extend(publicAPI, model, initialValues);\n  vtkPoints(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkPoints');\n\n// ----------------------------------------------------------------------------\n\nvar vtkPoints$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkPoints$1 as default, extend, newInstance };\n","import { m as macro } from '../../macros2.js';\nimport vtkDataArray from './DataArray.js';\nimport { VtkDataTypes } from './DataArray/Constants.js';\n\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n\nfunction extractCellSizes(cellArray) {\n  let currentIdx = 0;\n  return cellArray.filter((value, index) => {\n    if (index === currentIdx) {\n      currentIdx += value + 1;\n      return true;\n    }\n    return false;\n  });\n}\nfunction getNumberOfCells(cellArray) {\n  let cellId = 0;\n  for (let cellArrayIndex = 0; cellArrayIndex < cellArray.length;) {\n    cellArrayIndex += cellArray[cellArrayIndex] + 1;\n    cellId++;\n  }\n  return cellId;\n}\n\n// ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\n\nconst STATIC = {\n  extractCellSizes,\n  getNumberOfCells\n};\n\n// ----------------------------------------------------------------------------\n// vtkCellArray methods\n// ----------------------------------------------------------------------------\n\nfunction vtkCellArray(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkCellArray');\n  const superClass = {\n    ...publicAPI\n  };\n  publicAPI.getNumberOfCells = recompute => {\n    if (model.numberOfCells !== undefined && !recompute) {\n      return model.numberOfCells;\n    }\n    if (model.cellSizes) {\n      model.numberOfCells = model.cellSizes.length;\n    } else {\n      model.numberOfCells = getNumberOfCells(publicAPI.getData());\n    }\n    return model.numberOfCells;\n  };\n  publicAPI.getCellSizes = recompute => {\n    if (model.cellSizes !== undefined && !recompute) {\n      return model.cellSizes;\n    }\n    model.cellSizes = extractCellSizes(publicAPI.getData());\n    return model.cellSizes;\n  };\n\n  /**\n   * When `resize()` is being used, you then MUST use `insertNextCell()`.\n   */\n  publicAPI.resize = requestedNumTuples => {\n    const oldNumTuples = publicAPI.getNumberOfTuples();\n    superClass.resize(requestedNumTuples);\n    const newNumTuples = publicAPI.getNumberOfTuples();\n    if (newNumTuples < oldNumTuples) {\n      if (newNumTuples === 0) {\n        model.numberOfCells = 0;\n        model.cellSizes = [];\n      } else {\n        // We do not know how many cells are left.\n        // Set to undefined to ensure insertNextCell works correctly.\n        model.numberOfCells = undefined;\n        model.cellSizes = undefined;\n      }\n    }\n  };\n  publicAPI.setData = typedArray => {\n    superClass.setData(typedArray, 1);\n    model.numberOfCells = undefined;\n    model.cellSizes = undefined;\n  };\n  publicAPI.getCell = loc => {\n    let cellLoc = loc;\n    const numberOfPoints = model.values[cellLoc++];\n    return model.values.subarray(cellLoc, cellLoc + numberOfPoints);\n  };\n  publicAPI.insertNextCell = cellPointIds => {\n    const cellId = publicAPI.getNumberOfCells();\n    publicAPI.insertNextTuples([cellPointIds.length, ...cellPointIds]);\n    // By computing the number of cells earlier, we made sure that numberOfCells is defined\n    ++model.numberOfCells;\n    if (model.cellSizes != null) {\n      model.cellSizes.push(cellPointIds.length);\n    }\n    return cellId;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nfunction defaultValues(initialValues) {\n  return {\n    empty: true,\n    numberOfComponents: 1,\n    dataType: VtkDataTypes.UNSIGNED_INT,\n    ...initialValues\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  vtkDataArray.extend(publicAPI, model, defaultValues(initialValues));\n  vtkCellArray(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkCellArray');\n\n// ----------------------------------------------------------------------------\n\nvar vtkCellArray$1 = {\n  newInstance,\n  extend,\n  ...STATIC\n};\n\nexport { STATIC, vtkCellArray$1 as default, extend, newInstance };\n","import { m as macro } from '../../macros2.js';\nimport { u as uninitializeBounds } from '../Core/Math/index.js';\nimport vtkPoints from '../Core/Points.js';\n\n// ----------------------------------------------------------------------------\n// vtkCell methods\n// ----------------------------------------------------------------------------\n\nfunction vtkCell(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkCell');\n  publicAPI.initialize = function (points) {\n    let pointIdsList = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    if (!pointIdsList) {\n      model.points = points;\n      model.pointsIds = new Array(points.getNumberOfPoints());\n      for (let i = points.getNumberOfPoints() - 1; i >= 0; --i) {\n        model.pointsIds[i] = i;\n      }\n    } else {\n      model.pointsIds = pointIdsList;\n      let triangleData = model.points.getData();\n      if (triangleData.length !== 3 * model.pointsIds.length) {\n        triangleData = macro.newTypedArray(points.getDataType(), 3 * model.pointsIds.length);\n      }\n      const pointsData = points.getData();\n      model.pointsIds.forEach((pointId, index) => {\n        // const start = 3 * pointId;\n        // pointsData.set(p.subarray(start, start + 3), 3 * index);\n        let pointOffset = 3 * pointId;\n        let trianglePointOffset = 3 * index;\n        triangleData[trianglePointOffset] = pointsData[pointOffset];\n        triangleData[++trianglePointOffset] = pointsData[++pointOffset];\n        triangleData[++trianglePointOffset] = pointsData[++pointOffset];\n      });\n      model.points.setData(triangleData);\n    }\n  };\n  publicAPI.getBounds = () => {\n    const nbPoints = model.points.getNumberOfPoints();\n    const x = [];\n    if (nbPoints) {\n      model.points.getPoint(0, x);\n      model.bounds[0] = x[0];\n      model.bounds[1] = x[0];\n      model.bounds[2] = x[1];\n      model.bounds[3] = x[1];\n      model.bounds[4] = x[2];\n      model.bounds[5] = x[2];\n      for (let i = 1; i < nbPoints; i++) {\n        model.points.getPoint(i, x);\n        model.bounds[0] = x[0] < model.bounds[0] ? x[0] : model.bounds[0];\n        model.bounds[1] = x[0] > model.bounds[1] ? x[0] : model.bounds[1];\n        model.bounds[2] = x[1] < model.bounds[2] ? x[1] : model.bounds[2];\n        model.bounds[3] = x[1] > model.bounds[3] ? x[1] : model.bounds[3];\n        model.bounds[4] = x[2] < model.bounds[4] ? x[2] : model.bounds[4];\n        model.bounds[5] = x[2] > model.bounds[5] ? x[2] : model.bounds[5];\n      }\n    } else {\n      uninitializeBounds(model.bounds);\n    }\n    return model.bounds;\n  };\n  publicAPI.getLength2 = () => {\n    publicAPI.getBounds();\n    let length = 0.0;\n    let diff = 0;\n    for (let i = 0; i < 3; i++) {\n      diff = model.bounds[2 * i + 1] - model.bounds[2 * i];\n      length += diff * diff;\n    }\n    return length;\n  };\n  publicAPI.getParametricDistance = pcoords => {\n    let pDist;\n    let pDistMax = 0.0;\n    for (let i = 0; i < 3; i++) {\n      if (pcoords[i] < 0.0) {\n        pDist = -pcoords[i];\n      } else if (pcoords[i] > 1.0) {\n        pDist = pcoords[i] - 1.0;\n      } else {\n        // inside the cell in the parametric direction\n        pDist = 0.0;\n      }\n      if (pDist > pDistMax) {\n        pDistMax = pDist;\n      }\n    }\n    return pDistMax;\n  };\n  publicAPI.getNumberOfPoints = () => model.points.getNumberOfPoints();\n  publicAPI.deepCopy = cell => {\n    cell.initialize(model.points, model.pointsIds);\n  };\n  publicAPI.getCellDimension = () => {}; // virtual\n  publicAPI.intersectWithLine = (p1, p2, tol, t, x, pcoords, subId) => {}; // virtual\n  publicAPI.evaluatePosition = (x, closestPoint, subId, pcoords, dist2, weights) => {\n    macro.vtkErrorMacro('vtkCell.evaluatePosition is not implemented.');\n  }; // virtual\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  bounds: [-1, -1, -1, -1, -1, -1],\n  pointsIds: []\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n  macro.obj(publicAPI, model);\n  if (!model.points) {\n    model.points = vtkPoints.newInstance();\n  }\n  macro.get(publicAPI, model, ['points', 'pointsIds']);\n  vtkCell(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkCell');\n\n// ----------------------------------------------------------------------------\n\nvar vtkCell$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkCell$1 as default, extend, newInstance };\n","import { m as macro } from '../../macros2.js';\nimport vtkCell from './Cell.js';\n\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\nconst InitLink = {\n  ncells: 0,\n  cells: null\n};\nfunction resize(model, sz) {\n  let newSize = sz;\n  if (sz >= model.array.length) {\n    newSize += model.array.length;\n  }\n  while (newSize > model.array.length) model.array.push({\n    ncells: 0,\n    cells: null\n  });\n  model.array.length = newSize;\n}\n\n// ----------------------------------------------------------------------------\n// vtkCellLinks methods\n// ----------------------------------------------------------------------------\n\nfunction vtkCellLinks(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkCellLinks');\n\n  /**\n   * Build the link list array. All subclasses of vtkAbstractCellLinks\n   * must support this method.\n   */\n  publicAPI.buildLinks = data => {\n    const numPts = data.getPoints().getNumberOfPoints();\n    const numCells = data.getNumberOfCells();\n\n    // fill out lists with number of references to cells\n    const linkLoc = new Uint32Array(numPts);\n\n    // Use fast path if polydata\n    if (data.isA('vtkPolyData')) {\n      // traverse data to determine number of uses of each point\n      for (let cellId = 0; cellId < numCells; ++cellId) {\n        const {\n          cellPointIds\n        } = data.getCellPoints(cellId);\n        cellPointIds.forEach(cellPointId => {\n          publicAPI.incrementLinkCount(cellPointId);\n        });\n      }\n\n      // now allocate storage for the links\n      publicAPI.allocateLinks(numPts);\n      model.maxId = numPts - 1;\n      for (let cellId = 0; cellId < numCells; ++cellId) {\n        const {\n          cellPointIds\n        } = data.getCellPoints(cellId);\n        cellPointIds.forEach(cellPointId => {\n          publicAPI.insertCellReference(cellPointId, linkLoc[cellPointId]++, cellId);\n        });\n      }\n    } // any other type of dataset\n    else {\n      // traverse data to determine number of uses of each point\n      for (let cellId = 0; cellId < numCells; cellId++) {\n        // TODO: Currently not supported: const cell = data.getCell(cellId);\n        const cell = vtkCell.newInstance();\n        cell.getPointsIds().forEach(cellPointId => {\n          publicAPI.incrementLinkCount(cellPointId);\n        });\n      }\n\n      // now allocate storage for the links\n      publicAPI.allocateLinks(numPts);\n      model.maxId = numPts - 1;\n      for (let cellId = 0; cellId < numCells; ++cellId) {\n        // TODO: Currently not supported: const cell = data.getCell(cellId);\n        const cell = vtkCell.newInstance();\n        cell.getPointsIds().forEach(cellPointId => {\n          publicAPI.insertCellReference(cellPointId, linkLoc[cellPointId]++, cellId);\n        });\n      }\n    } // end else\n  };\n\n  /**\n   * Build the link list array with a provided connectivity array.\n   */\n  // publicAPI.buildLinks = (data, connectivity) => {};\n\n  /**\n   * Allocate the specified number of links (i.e., number of points) that\n   * will be built.\n   */\n  publicAPI.allocate = function (numLinks) {\n    let ext = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;\n    model.array = Array(numLinks).fill().map(() => ({\n      ncells: 0,\n      cells: null\n    }));\n    model.extend = ext;\n    model.maxId = -1;\n  };\n  publicAPI.initialize = () => {\n    model.array = null;\n  };\n\n  /**\n   * Get a link structure given a point id.\n   */\n  publicAPI.getLink = ptId => model.array[ptId];\n\n  /**\n   * Get the number of cells using the point specified by ptId.\n   */\n  publicAPI.getNcells = ptId => model.array[ptId].ncells;\n\n  /**\n   * Return a list of cell ids using the point.\n   */\n  publicAPI.getCells = ptId => model.array[ptId].cells;\n\n  /**\n   * Insert a new point into the cell-links data structure. The size parameter\n   * is the initial size of the list.\n   */\n  publicAPI.insertNextPoint = numLinks => {\n    model.array.push({\n      ncells: numLinks,\n      cells: Array(numLinks)\n    });\n    ++model.maxId;\n  };\n\n  /**\n   * Insert a cell id into the list of cells (at the end) using the cell id\n   * provided. (Make sure to extend the link list (if necessary) using the\n   * method resizeCellList().)\n   */\n  publicAPI.insertNextCellReference = (ptId, cellId) => {\n    model.array[ptId].cells[model.array[ptId].ncells++] = cellId;\n  };\n\n  /**\n   * Delete point (and storage) by destroying links to using cells.\n   */\n  publicAPI.deletePoint = ptId => {\n    model.array[ptId].ncells = 0;\n    model.array[ptId].cells = null;\n  };\n\n  /**\n   * Delete the reference to the cell (cellId) from the point (ptId). This\n   * removes the reference to the cellId from the cell list, but does not\n   * resize the list (recover memory with resizeCellList(), if necessary).\n   */\n  publicAPI.removeCellReference = (cellId, ptId) => {\n    model.array[ptId].cells = model.array[ptId].cells.filter(cell => cell !== cellId);\n    model.array[ptId].ncells = model.array[ptId].cells.length;\n  };\n\n  /**\n   * Add the reference to the cell (cellId) from the point (ptId). This\n   * adds a reference to the cellId from the cell list, but does not resize\n   * the list (extend memory with resizeCellList(), if necessary).\n   */\n  publicAPI.addCellReference = (cellId, ptId) => {\n    model.array[ptId].cells[model.array[ptId].ncells++] = cellId;\n  };\n\n  /**\n   * Change the length of a point's link list (i.e., list of cells using a\n   * point) by the size specified.\n   */\n  publicAPI.resizeCellList = (ptId, size) => {\n    model.array[ptId].cells.length = size;\n  };\n\n  /**\n   * Reclaim any unused memory.\n   */\n  publicAPI.squeeze = () => {\n    resize(model, model.maxId + 1);\n  };\n\n  /**\n   * Reset to a state of no entries without freeing the memory.\n   */\n  publicAPI.reset = () => {\n    model.maxId = -1;\n  };\n\n  /**\n   * Standard DeepCopy method.  Since this object contains no reference\n   * to other objects, there is no ShallowCopy.\n   */\n  publicAPI.deepCopy = src => {\n    model.array = [...src.array];\n    model.extend = src.extend;\n    model.maxId = src.maxId;\n  };\n\n  /**\n   * Increment the count of the number of cells using the point.\n   */\n  publicAPI.incrementLinkCount = ptId => {\n    ++model.array[ptId].ncells;\n  };\n  publicAPI.allocateLinks = n => {\n    for (let i = 0; i < n; ++i) {\n      model.array[i].cells = new Array(model.array[i].ncells);\n    }\n  };\n\n  /**\n   * Insert a cell id into the list of cells using the point.\n   */\n  publicAPI.insertCellReference = (ptId, pos, cellId) => {\n    model.array[ptId].cells[pos] = cellId;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  array: null,\n  // pointer to data\n  maxId: 0,\n  // maximum index inserted thus far\n  extend: 0 // grow array by this point\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n  macro.obj(publicAPI, model);\n  vtkCellLinks(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkCellLinks');\n\n// ----------------------------------------------------------------------------\n\nvar vtkCellLinks$1 = {\n  newInstance,\n  extend\n};\n\nexport { InitLink, vtkCellLinks$1 as default, extend, newInstance };\n","const CellType = {\n  // Linear cells\n  VTK_EMPTY_CELL: 0,\n  VTK_VERTEX: 1,\n  VTK_POLY_VERTEX: 2,\n  VTK_LINE: 3,\n  VTK_POLY_LINE: 4,\n  VTK_TRIANGLE: 5,\n  VTK_TRIANGLE_STRIP: 6,\n  VTK_POLYGON: 7,\n  VTK_PIXEL: 8,\n  VTK_QUAD: 9,\n  VTK_TETRA: 10,\n  VTK_VOXEL: 11,\n  VTK_HEXAHEDRON: 12,\n  VTK_WEDGE: 13,\n  VTK_PYRAMID: 14,\n  VTK_PENTAGONAL_PRISM: 15,\n  VTK_HEXAGONAL_PRISM: 16,\n  // Quadratic, isoparametric cells\n  VTK_QUADRATIC_EDGE: 21,\n  VTK_QUADRATIC_TRIANGLE: 22,\n  VTK_QUADRATIC_QUAD: 23,\n  VTK_QUADRATIC_POLYGON: 36,\n  VTK_QUADRATIC_TETRA: 24,\n  VTK_QUADRATIC_HEXAHEDRON: 25,\n  VTK_QUADRATIC_WEDGE: 26,\n  VTK_QUADRATIC_PYRAMID: 27,\n  VTK_BIQUADRATIC_QUAD: 28,\n  VTK_TRIQUADRATIC_HEXAHEDRON: 29,\n  VTK_QUADRATIC_LINEAR_QUAD: 30,\n  VTK_QUADRATIC_LINEAR_WEDGE: 31,\n  VTK_BIQUADRATIC_QUADRATIC_WEDGE: 32,\n  VTK_BIQUADRATIC_QUADRATIC_HEXAHEDRON: 33,\n  VTK_BIQUADRATIC_TRIANGLE: 34,\n  // Cubic, isoparametric cell\n  VTK_CUBIC_LINE: 35,\n  // Special class of cells formed by convex group of points\n  VTK_CONVEX_POINT_SET: 41,\n  // Polyhedron cell (consisting of polygonal faces)\n  VTK_POLYHEDRON: 42,\n  // Higher order cells in parametric form\n  VTK_PARAMETRIC_CURVE: 51,\n  VTK_PARAMETRIC_SURFACE: 52,\n  VTK_PARAMETRIC_TRI_SURFACE: 53,\n  VTK_PARAMETRIC_QUAD_SURFACE: 54,\n  VTK_PARAMETRIC_TETRA_REGION: 55,\n  VTK_PARAMETRIC_HEX_REGION: 56,\n  // Higher order cells\n  VTK_HIGHER_ORDER_EDGE: 60,\n  VTK_HIGHER_ORDER_TRIANGLE: 61,\n  VTK_HIGHER_ORDER_QUAD: 62,\n  VTK_HIGHER_ORDER_POLYGON: 63,\n  VTK_HIGHER_ORDER_TETRAHEDRON: 64,\n  VTK_HIGHER_ORDER_WEDGE: 65,\n  VTK_HIGHER_ORDER_PYRAMID: 66,\n  VTK_HIGHER_ORDER_HEXAHEDRON: 67,\n  // Arbitrary order Lagrange elements (formulated separated from generic higher order cells)\n  VTK_LAGRANGE_CURVE: 68,\n  VTK_LAGRANGE_TRIANGLE: 69,\n  VTK_LAGRANGE_QUADRILATERAL: 70,\n  VTK_LAGRANGE_TETRAHEDRON: 71,\n  VTK_LAGRANGE_HEXAHEDRON: 72,\n  VTK_LAGRANGE_WEDGE: 73,\n  VTK_LAGRANGE_PYRAMID: 74,\n  VTK_NUMBER_OF_CELL_TYPES: 75\n};\n\n// This list should contain the cell class names in\n// the same order as in CellType.\nconst CellTypesStrings = ['vtkEmptyCell', 'vtkVertex', 'vtkPolyVertex', 'vtkLine', 'vtkPolyLine', 'vtkTriangle', 'vtkTriangleStrip', 'vtkPolygon', 'vtkPixel', 'vtkQuad', 'vtkTetra', 'vtkVoxel', 'vtkHexahedron', 'vtkWedge', 'vtkPyramid', 'vtkPentagonalPrism', 'vtkHexagonalPrism', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'vtkQuadraticEdge', 'vtkQuadraticTriangle', 'vtkQuadraticQuad', 'vtkQuadraticTetra', 'vtkQuadraticHexahedron', 'vtkQuadraticWedge', 'vtkQuadraticPyramid', 'vtkBiQuadraticQuad', 'vtkTriQuadraticHexahedron', 'vtkQuadraticLinearQuad', 'vtkQuadraticLinearWedge', 'vtkBiQuadraticQuadraticWedge', 'vtkBiQuadraticQuadraticHexahedron', 'vtkBiQuadraticTriangle', 'vtkCubicLine', 'vtkQuadraticPolygon', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'vtkConvexPointSet', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'vtkParametricCurve', 'vtkParametricSurface', 'vtkParametricTriSurface', 'vtkParametricQuadSurface', 'vtkParametricTetraRegion', 'vtkParametricHexRegion', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'vtkHigherOrderEdge', 'vtkHigherOrderTriangle', 'vtkHigherOrderQuad', 'vtkHigherOrderPolygon', 'vtkHigherOrderTetrahedron', 'vtkHigherOrderWedge', 'vtkHigherOrderPyramid', 'vtkHigherOrderHexahedron'];\nvar Constants = {\n  CellType,\n  CellTypesStrings\n};\n\nexport { CellType, CellTypesStrings, Constants as default };\n","import { m as macro } from '../../macros2.js';\nimport { CellTypesStrings, CellType } from './CellTypes/Constants.js';\n\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n\n/**\n * Given an int (as defined in vtkCellType.h) identifier for a class\n * return it's classname.\n */\nfunction getClassNameFromTypeId(typeId) {\n  return typeId < CellTypesStrings.length ? CellTypesStrings[typeId] : 'UnknownClass';\n}\n\n/**\n * Given a data object classname, return it's int identified (as\n * defined in vtkCellType.h)\n */\nfunction getTypeIdFromClassName(cellTypeString) {\n  return CellTypesStrings.findIndex(cellTypeString);\n}\n\n/**\n * This convenience method is a fast check to determine if a cell type\n * represents a linear or nonlinear cell.  This is generally much more\n * efficient than getting the appropriate vtkCell and checking its IsLinear\n * method.\n */\nfunction isLinear(type) {\n  return type < CellType.VTK_QUADRATIC_EDGE || type === CellType.VTK_CONVEX_POINT_SET || type === CellType.VTK_POLYHEDRON;\n}\nfunction hasSubCells(cellType) {\n  return cellType === CellType.VTK_TRIANGLE_STRIP || cellType === CellType.VTK_POLY_LINE || cellType === CellType.VTK_POLY_VERTEX;\n}\n\n// ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\n\nconst STATIC = {\n  getClassNameFromTypeId,\n  getTypeIdFromClassName,\n  isLinear,\n  hasSubCells\n};\n\n// ----------------------------------------------------------------------------\n// vtkCellTypes methods\n// ----------------------------------------------------------------------------\n\nfunction vtkCellTypes(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkCellTypes');\n\n  /**\n   * Allocate memory for this array. Delete old storage only if necessary.\n   */\n  publicAPI.allocate = function () {\n    let sz = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 512;\n    let ext = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;\n    model.size = sz > 0 ? sz : 1;\n    model.extend = ext > 0 ? ext : 1;\n    model.maxId = -1;\n    model.typeArray = new Uint8Array(sz);\n    model.locationArray = new Uint32Array(sz);\n  };\n\n  /**\n   * Add a cell at specified id.\n   */\n  publicAPI.insertCell = (cellId, type, loc) => {\n    model.typeArray[cellId] = type;\n    model.locationArray[cellId] = loc;\n    if (cellId > model.maxId) {\n      model.maxId = cellId;\n    }\n  };\n\n  /**\n   * Add a cell to the object in the next available slot.\n   */\n  publicAPI.insertNextCell = (type, loc) => {\n    publicAPI.insertCell(++model.maxId, type, loc);\n    return model.maxId;\n  };\n\n  /**\n   * Specify a group of cell types. This version is provided to maintain\n   * backwards compatibility and does a copy of the cellLocations\n   */\n  publicAPI.setCellTypes = (ncells, cellTypes, cellLocations) => {\n    model.size = ncells;\n    model.typeArray = cellTypes;\n    model.locationArray = cellLocations;\n    model.maxId = ncells - 1;\n  };\n\n  /**\n   * Return the location of the cell in the associated vtkCellArray.\n   */\n  publicAPI.getCellLocation = cellId => model.locationArray[cellId];\n\n  /**\n   * Delete cell by setting to nullptr cell type.\n   */\n  publicAPI.deleteCell = cellId => {\n    model.typeArray[cellId] = CellType.VTK_EMPTY_CELL;\n  };\n\n  /**\n   * Return the number of types in the list.\n   */\n  publicAPI.getNumberOfTypes = () => model.maxId + 1;\n\n  /**\n   * Return true if type specified is contained in list; false otherwise.\n   */\n  publicAPI.isType = type => {\n    const numTypes = publicAPI.getNumberOfTypes();\n    for (let i = 0; i < numTypes; ++i) {\n      if (type === publicAPI.getCellType(i)) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  /**\n   * Add the type specified to the end of the list. Range checking is performed.\n   */\n  publicAPI.insertNextType = type => publicAPI.insertNextCell(type, -1);\n\n  /**\n   * Return the type of cell.\n   */\n  publicAPI.getCellType = cellId => model.typeArray[cellId];\n\n  /**\n   * Reclaim any extra memory.\n   */\n  // TODO: publicAPI.squeeze = () =>  {};\n\n  /**\n   * Initialize object without releasing memory.\n   */\n  publicAPI.reset = () => {\n    model.maxId = -1;\n  };\n\n  /**\n   * Standard DeepCopy method.  Since this object contains no reference\n   * to other objects, there is no ShallowCopy.\n   */\n  publicAPI.deepCopy = src => {\n    publicAPI.allocate(src.getSize(), src.getExtend());\n    model.typeArray.set(src.getTypeArray());\n    model.locationArray.set(src.getLocationArray());\n    model.maxId = src.getMaxId();\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  // typeArray: null, // pointer to types array\n  // locationArray: null;   // pointer to array of offsets\n  size: 0,\n  // allocated size of data\n  maxId: -1,\n  // maximum index inserted thus far\n  extend: 1000 // grow array by this point\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n  macro.obj(publicAPI, model);\n  macro.get(publicAPI, model, ['size', 'maxId', 'extend']);\n  macro.getArray(publicAPI, model, ['typeArray', 'locationArray']);\n  vtkCellTypes(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkCellTypes');\n\n// ----------------------------------------------------------------------------\n\nvar vtkCellTypes$1 = {\n  newInstance,\n  extend,\n  ...STATIC\n};\n\nexport { STATIC, vtkCellTypes$1 as default, extend, newInstance };\n","const IntersectionState = {\n  NO_INTERSECTION: 0,\n  YES_INTERSECTION: 1,\n  ON_LINE: 2\n};\nvar Constants = {\n  IntersectionState\n};\n\nexport { IntersectionState, Constants as default };\n","import { m as macro } from '../../macros2.js';\nimport Constants from './Line/Constants.js';\nimport vtkCell from './Cell.js';\nimport { d as dot, e as distance2BetweenPoints, s as subtract, g as solveLinearSystem } from '../Core/Math/index.js';\nimport { quat } from 'gl-matrix';\n\nconst {\n  IntersectionState\n} = Constants;\n\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\nfunction distanceToLine(x, p1, p2) {\n  let closestPoint = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  const outObj = {\n    t: Number.MIN_VALUE,\n    distance: 0\n  };\n  const p21 = [];\n  let closest;\n  // Determine appropriate vector\n  p21[0] = p2[0] - p1[0];\n  p21[1] = p2[1] - p1[1];\n  p21[2] = p2[2] - p1[2];\n\n  // Get parametric location\n  const num = p21[0] * (x[0] - p1[0]) + p21[1] * (x[1] - p1[1]) + p21[2] * (x[2] - p1[2]);\n  const denom = dot(p21, p21);\n\n  // trying to avoid an expensive fabs\n  let tolerance = 1e-5 * num;\n  if (denom !== 0.0) {\n    outObj.t = num / denom;\n  }\n  if (tolerance < 0.0) {\n    tolerance = -tolerance;\n  }\n  if (-tolerance < denom && denom < tolerance) {\n    closest = p1;\n  } else if (denom <= 0.0 || outObj.t < 0.0) {\n    // If parametric coordinate is within 0<=p<=1, then the point is closest to\n    // the line.  Otherwise, it's closest to a point at the end of the line.\n    closest = p1;\n  } else if (outObj.t > 1.0) {\n    closest = p2;\n  } else {\n    closest = p21;\n    p21[0] = p1[0] + outObj.t * p21[0];\n    p21[1] = p1[1] + outObj.t * p21[1];\n    p21[2] = p1[2] + outObj.t * p21[2];\n  }\n  if (closestPoint) {\n    closestPoint[0] = closest[0];\n    closestPoint[1] = closest[1];\n    closestPoint[2] = closest[2];\n  }\n  outObj.distance = distance2BetweenPoints(closest, x);\n  return outObj;\n}\nfunction intersection(a1, a2, b1, b2, u, v) {\n  const a21 = [];\n  const b21 = [];\n  const b1a1 = [];\n  u[0] = 0.0;\n  v[0] = 0.0;\n\n  // Determine line vectors.\n  subtract(a2, a1, a21);\n  subtract(b2, b1, b21);\n  subtract(b1, a1, b1a1);\n\n  // Compute the system (least squares) matrix.\n  const A = [dot(a21, a21), -dot(a21, b21), -dot(a21, b21), dot(b21, b21)];\n\n  // Compute the least squares system constant term.\n  const c = [];\n  c[0] = dot(a21, b1a1);\n  c[1] = -dot(b21, b1a1);\n  // Solve the system of equations\n  if (solveLinearSystem(A, c, 2) === 0) {\n    // The lines are colinear. Therefore, one of the four endpoints is the\n    // point of closest approach\n    let minDist = Number.MAX_VALUE;\n    const p = [a1, a2, b1, b2];\n    const l1 = [b1, b1, a1, a1];\n    const l2 = [b2, b2, a2, a2];\n    [v[0], v[0], u[0], u[0]];\n    [u[0], u[0], v[0], v[0]];\n    let obj;\n    for (let i = 0; i < 4; i++) {\n      obj = distanceToLine(p[i], l1[i], l2[i]);\n      if (obj.distance < minDist) {\n        minDist = obj.distance;\n      }\n    }\n    return IntersectionState.ON_LINE;\n  }\n  u[0] = c[0];\n  v[0] = c[1];\n\n  // Check parametric coordinates for intersection.\n  if (u[0] >= 0.0 && u[0] <= 1.0 && v[0] >= 0.0 && v[0] <= 1.0) {\n    return IntersectionState.YES_INTERSECTION;\n  }\n  return IntersectionState.NO_INTERSECTION;\n}\n\n// ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\n\nconst STATIC = {\n  distanceToLine,\n  intersection\n};\n\n// ----------------------------------------------------------------------------\n// vtkLine methods\n// ----------------------------------------------------------------------------\n\nfunction vtkLine(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkLine');\n  function isBetweenPoints(t) {\n    return t >= 0.0 && t <= 1.0;\n  }\n  publicAPI.getCellDimension = () => 1;\n  publicAPI.intersectWithLine = (p1, p2, tol, x, pcoords) => {\n    const outObj = {\n      intersect: 0,\n      t: Number.MAX_VALUE,\n      subId: 0,\n      betweenPoints: null\n    };\n    pcoords[1] = 0.0;\n    pcoords[2] = 0.0;\n    const projXYZ = [];\n    const a1 = [];\n    const a2 = [];\n    model.points.getPoint(0, a1);\n    model.points.getPoint(1, a2);\n    const u = [];\n    const v = [];\n    const intersect = intersection(p1, p2, a1, a2, u, v);\n    outObj.t = u[0];\n    outObj.betweenPoints = isBetweenPoints(outObj.t);\n    pcoords[0] = v[0];\n    if (intersect === IntersectionState.YES_INTERSECTION) {\n      // make sure we are within tolerance\n      for (let i = 0; i < 3; i++) {\n        x[i] = a1[i] + pcoords[0] * (a2[i] - a1[i]);\n        projXYZ[i] = p1[i] + outObj.t * (p2[i] - p1[i]);\n      }\n      if (distance2BetweenPoints(x, projXYZ) <= tol * tol) {\n        outObj.intersect = 1;\n        return outObj;\n      }\n    } else {\n      let outDistance;\n      // check to see if it lies within tolerance\n      // one of the parametric coords must be outside 0-1\n      if (outObj.t < 0.0) {\n        outDistance = distanceToLine(p1, a1, a2, x);\n        if (outDistance.distance <= tol * tol) {\n          outObj.t = 0.0;\n          outObj.intersect = 1;\n          outObj.betweenPoints = true; // Intersection is near p1\n          return outObj;\n        }\n        return outObj;\n      }\n      if (outObj.t > 1.0) {\n        outDistance = distanceToLine(p2, a1, a2, x);\n        if (outDistance.distance <= tol * tol) {\n          outObj.t = 1.0;\n          outObj.intersect = 1;\n          outObj.betweenPoints = true; // Intersection is near p2\n          return outObj;\n        }\n        return outObj;\n      }\n      if (pcoords[0] < 0.0) {\n        pcoords[0] = 0.0;\n        outDistance = distanceToLine(a1, p1, p2, x);\n        outObj.t = outDistance.t;\n        if (outDistance.distance <= tol * tol) {\n          outObj.intersect = 1;\n          return outObj;\n        }\n        return outObj;\n      }\n      if (pcoords[0] > 1.0) {\n        pcoords[0] = 1.0;\n        outDistance = distanceToLine(a2, p1, p2, x);\n        outObj.t = outDistance.t;\n        if (outDistance.distance <= tol * tol) {\n          outObj.intersect = 1;\n          return outObj;\n        }\n        return outObj;\n      }\n    }\n    return outObj;\n  };\n  publicAPI.evaluateLocation = (pcoords, x, weights) => {\n    const a1 = [];\n    const a2 = [];\n    model.points.getPoint(0, a1);\n    model.points.getPoint(1, a2);\n    for (let i = 0; i < 3; i++) {\n      x[i] = a1[i] + pcoords[0] * (a2[i] - a1[i]);\n    }\n    weights[0] = 1.0 - pcoords[0];\n    weights[1] = pcoords[0];\n  };\n  publicAPI.evaluateOrientation = (pcoords, q, weights) => {\n    if (model.orientations) {\n      quat.slerp(q, model.orientations[0], model.orientations[1], pcoords[0]);\n      weights[0] = 1.0 - pcoords[0];\n      weights[1] = pcoords[0];\n      return true;\n    }\n    return false;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  orientations: null // an array of two quat or null\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n  vtkCell.extend(publicAPI, model, initialValues);\n  macro.setGet(publicAPI, model, ['orientations']);\n  vtkLine(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkLine');\n\n// ----------------------------------------------------------------------------\n\nvar vtkLine$1 = {\n  newInstance,\n  extend,\n  ...STATIC,\n  ...Constants\n};\n\nexport { STATIC, vtkLine$1 as default, extend, newInstance };\n","import vtk from '../../vtk.js';\nimport { m as macro } from '../../macros2.js';\nimport vtkDataSet from './DataSet.js';\nimport vtkPoints from '../Core/Points.js';\n\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n// vtkPointSet methods\n// ----------------------------------------------------------------------------\n\nfunction vtkPointSet(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkPointSet');\n\n  // Create empty points\n  if (!model.points) {\n    model.points = vtkPoints.newInstance();\n  } else {\n    model.points = vtk(model.points);\n  }\n  publicAPI.getNumberOfPoints = () => model.points.getNumberOfPoints();\n  publicAPI.getBounds = () => model.points.getBounds();\n  publicAPI.computeBounds = () => {\n    publicAPI.getBounds();\n  };\n  const superShallowCopy = publicAPI.shallowCopy;\n  publicAPI.shallowCopy = function (other) {\n    let debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    superShallowCopy(other, debug);\n    model.points = vtkPoints.newInstance();\n    model.points.shallowCopy(other.getPoints());\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  // points: null,\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkDataSet.extend(publicAPI, model, initialValues);\n  macro.setGet(publicAPI, model, ['points']);\n\n  // Object specific methods\n  vtkPointSet(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkPointSet');\n\n// ----------------------------------------------------------------------------\n\nvar vtkPointSet$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkPointSet$1 as default, extend, newInstance };\n","import { m as macro } from '../../macros2.js';\nimport vtkCell from './Cell.js';\nimport { d as dot, j as cross, l as normalize, m as multiplyAccumulate, e as distance2BetweenPoints, o as determinant2x2 } from '../Core/Math/index.js';\nimport vtkLine from './Line.js';\nimport vtkPlane from './Plane.js';\n\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n\nfunction computeNormalDirection(v1, v2, v3, n) {\n  // order is important!!! maintain consistency with triangle vertex order\n  const ax = v3[0] - v2[0];\n  const ay = v3[1] - v2[1];\n  const az = v3[2] - v2[2];\n  const bx = v1[0] - v2[0];\n  const by = v1[1] - v2[1];\n  const bz = v1[2] - v2[2];\n  n[0] = ay * bz - az * by;\n  n[1] = az * bx - ax * bz;\n  n[2] = ax * by - ay * bx;\n}\nfunction computeNormal(v1, v2, v3, n) {\n  computeNormalDirection(v1, v2, v3, n);\n  const length = Math.sqrt(n[0] * n[0] + n[1] * n[1] + n[2] * n[2]);\n  if (length !== 0.0) {\n    n[0] /= length;\n    n[1] /= length;\n    n[2] /= length;\n  }\n}\nfunction intersectWithTriangle(p1, q1, r1, p2, q2, r2) {\n  let tolerance = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 1e-6;\n  let coplanar = false;\n  const pt1 = [];\n  const pt2 = [];\n  const surfaceId = [];\n  const n1 = [];\n  const n2 = [];\n\n  // Compute supporting plane normals.\n  computeNormal(p1, q1, r1, n1);\n  computeNormal(p2, q2, r2, n2);\n  const s1 = -dot(n1, p1);\n  const s2 = -dot(n2, p2);\n\n  // Compute signed distances of points p1, q1, r1 from supporting\n  // plane of second triangle.\n  const dist1 = [dot(n2, p1) + s2, dot(n2, q1) + s2, dot(n2, r1) + s2];\n\n  // If signs of all points are the same, all the points lie on the\n  // same side of the supporting plane, and we can exit early.\n  if (dist1[0] * dist1[1] > tolerance && dist1[0] * dist1[2] > tolerance) {\n    // vtkDebugMacro(<<\"Same side supporting plane 1!\");\n    return {\n      intersect: false,\n      coplanar,\n      pt1,\n      pt2,\n      surfaceId\n    };\n  }\n  // Do the same for p2, q2, r2 and supporting plane of first\n  // triangle.\n  const dist2 = [dot(n1, p2) + s1, dot(n1, q2) + s1, dot(n1, r2) + s1];\n\n  // If signs of all points are the same, all the points lie on the\n  // same side of the supporting plane, and we can exit early.\n  if (dist2[0] * dist2[1] > tolerance && dist2[0] * dist2[2] > tolerance) {\n    // vtkDebugMacro(<<\"Same side supporting plane 2!\");\n    return {\n      intersect: false,\n      coplanar,\n      pt1,\n      pt2,\n      surfaceId\n    };\n  }\n  // Check for coplanarity of the supporting planes.\n  if (Math.abs(n1[0] - n2[0]) < 1e-9 && Math.abs(n1[1] - n2[1]) < 1e-9 && Math.abs(n1[2] - n2[2]) < 1e-9 && Math.abs(s1 - s2) < 1e-9) {\n    coplanar = true;\n    // vtkDebugMacro(<<\"Coplanar!\");\n    return {\n      intersect: false,\n      coplanar,\n      pt1,\n      pt2,\n      surfaceId\n    };\n  }\n\n  // There are more efficient ways to find the intersection line (if\n  // it exists), but this is clear enough.\n  const pts1 = [p1, q1, r1];\n  const pts2 = [p2, q2, r2];\n\n  // Find line of intersection (L = p + t*v) between two planes.\n  const n1n2 = dot(n1, n2);\n  const a = (s1 - s2 * n1n2) / (n1n2 * n1n2 - 1.0);\n  const b = (s2 - s1 * n1n2) / (n1n2 * n1n2 - 1.0);\n  const p = [a * n1[0] + b * n2[0], a * n1[1] + b * n2[1], a * n1[2] + b * n2[2]];\n  const v = cross(n1, n2, []);\n  normalize(v);\n  let index1 = 0;\n  let index2 = 0;\n  const t1 = [];\n  const t2 = [];\n  let ts1 = 50;\n  let ts2 = 50;\n  for (let i = 0; i < 3; i++) {\n    const id1 = i;\n    const id2 = (i + 1) % 3;\n\n    // Find t coordinate on line of intersection between two planes.\n    const val1 = vtkPlane.intersectWithLine(pts1[id1], pts1[id2], p2, n2);\n    if (val1.intersection && val1.t > 0 - tolerance && val1.t < 1 + tolerance) {\n      if (val1.t < 1 + tolerance && val1.t > 1 - tolerance) {\n        ts1 = index1;\n      }\n      t1[index1++] = dot(val1.x, v) - dot(p, v);\n    }\n    const val2 = vtkPlane.intersectWithLine(pts2[id1], pts2[id2], p1, n1);\n    if (val2.intersection && val2.t > 0 - tolerance && val2.t < 1 + tolerance) {\n      if (val2.t < 1 + tolerance && val2.t > 1 - tolerance) {\n        ts2 = index2;\n      }\n      t2[index2++] = dot(val2.x, v) - dot(p, v);\n    }\n  }\n\n  // If the value of the index is greater than 2, the intersecting point\n  // actually is intersected by all three edges. In this case, set the two\n  // edges to the two edges where the intersecting point is not the end point\n  if (index1 > 2) {\n    index1--;\n    // swap\n    const t12 = t1[2];\n    t1[2] = t1[ts1];\n    t1[ts1] = t12;\n  }\n  if (index2 > 2) {\n    index2--;\n    const t22 = t2[2];\n    t2[2] = t2[ts2];\n    t2[ts2] = t22;\n  }\n  // Check if only one edge or all edges intersect the supporting\n  // planes intersection.\n  if (index1 !== 2 || index2 !== 2) {\n    // vtkDebugMacro(<<\"Only one edge intersecting!\");\n    return {\n      intersect: false,\n      coplanar,\n      pt1,\n      pt2,\n      surfaceId\n    };\n  }\n\n  // Check for NaNs\n  if (Number.isNaN(t1[0]) || Number.isNaN(t1[1]) || Number.isNaN(t2[0]) || Number.isNaN(t2[1])) {\n    // vtkWarningMacro(<<\"NaNs!\");\n    return {\n      intersect: false,\n      coplanar,\n      pt1,\n      pt2,\n      surfaceId\n    };\n  }\n  if (t1[0] > t1[1]) {\n    // swap\n    const t11 = t1[1];\n    t1[1] = t1[0];\n    t1[0] = t11;\n  }\n  if (t2[0] > t2[1]) {\n    // swap\n    const t21 = t2[1];\n    t2[1] = t2[0];\n    t2[0] = t21;\n  }\n  // Handle the different interval configuration cases.\n  let tt1;\n  let tt2;\n  if (t1[1] < t2[0] || t2[1] < t1[0]) {\n    // vtkDebugMacro(<<\"No Overlap!\");\n    return {\n      intersect: false,\n      coplanar,\n      pt1,\n      pt2,\n      surfaceId\n    }; // No overlap\n  }\n\n  if (t1[0] < t2[0]) {\n    if (t1[1] < t2[1]) {\n      // First point on surface 2, second point on surface 1\n      surfaceId[0] = 2;\n      surfaceId[1] = 1;\n      tt1 = t2[0];\n      tt2 = t1[1];\n    } else {\n      // Both points belong to lines on surface 2\n      surfaceId[0] = 2;\n      surfaceId[1] = 2;\n      tt1 = t2[0];\n      tt2 = t2[1];\n    }\n  } // t1[0] >= t2[0]\n  else if (t1[1] < t2[1]) {\n    // Both points belong to lines on surface 1\n    surfaceId[0] = 1;\n    surfaceId[1] = 1;\n    tt1 = t1[0];\n    tt2 = t1[1];\n  } else {\n    // First point on surface 1, second point on surface 2\n    surfaceId[0] = 1;\n    surfaceId[1] = 2;\n    tt1 = t1[0];\n    tt2 = t2[1];\n  }\n\n  // Create actual intersection points.\n  multiplyAccumulate(p, v, tt1, pt1);\n  multiplyAccumulate(p, v, tt2, pt2);\n  return {\n    intersect: true,\n    coplanar,\n    pt1,\n    pt2,\n    surfaceId\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\n\nconst STATIC = {\n  computeNormalDirection,\n  computeNormal,\n  intersectWithTriangle\n};\n\n// ----------------------------------------------------------------------------\n// vtkTriangle methods\n// ----------------------------------------------------------------------------\n\nfunction vtkTriangle(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkTriangle');\n  publicAPI.getCellDimension = () => 2;\n  publicAPI.intersectWithLine = (p1, p2, tol, x, pcoords) => {\n    const outObj = {\n      subId: 0,\n      t: Number.MAX_VALUE,\n      intersect: 0,\n      betweenPoints: false\n    };\n    pcoords[2] = 0.0;\n    const closestPoint = [];\n    const tol2 = tol * tol;\n\n    // Get normal for triangle\n    const pt1 = [];\n    const pt2 = [];\n    const pt3 = [];\n    model.points.getPoint(0, pt1);\n    model.points.getPoint(1, pt2);\n    model.points.getPoint(2, pt3);\n    const n = [];\n    const weights = [];\n    computeNormal(pt1, pt2, pt3, n);\n    if (n[0] !== 0 || n[1] !== 0 || n[2] !== 0) {\n      // Intersect plane of triangle with line\n      const plane = vtkPlane.intersectWithLine(p1, p2, pt1, n);\n      outObj.betweenPoints = plane.betweenPoints;\n      outObj.t = plane.t;\n      x[0] = plane.x[0];\n      x[1] = plane.x[1];\n      x[2] = plane.x[2];\n      if (!plane.intersection) {\n        pcoords[0] = 0.0;\n        pcoords[1] = 0.0;\n        outObj.intersect = 0;\n        return outObj;\n      }\n\n      // Evaluate position\n      const inside = publicAPI.evaluatePosition(x, closestPoint, pcoords, weights);\n      if (inside.evaluation >= 0) {\n        if (inside.dist2 <= tol2) {\n          outObj.intersect = 1;\n          return outObj;\n        }\n        outObj.intersect = inside.evaluation;\n        return outObj;\n      }\n    }\n\n    // Normals are null, so the triangle is degenerated and\n    // we still need to check intersection between line and\n    // the longest edge.\n    const dist2Pt1Pt2 = distance2BetweenPoints(pt1, pt2);\n    const dist2Pt2Pt3 = distance2BetweenPoints(pt2, pt3);\n    const dist2Pt3Pt1 = distance2BetweenPoints(pt3, pt1);\n    if (!model.line) {\n      model.line = vtkLine.newInstance();\n    }\n    if (dist2Pt1Pt2 > dist2Pt2Pt3 && dist2Pt1Pt2 > dist2Pt3Pt1) {\n      model.line.getPoints().setPoint(0, pt1);\n      model.line.getPoints().setPoint(1, pt2);\n    } else if (dist2Pt2Pt3 > dist2Pt3Pt1 && dist2Pt2Pt3 > dist2Pt1Pt2) {\n      model.line.getPoints().setPoint(0, pt2);\n      model.line.getPoints().setPoint(1, pt3);\n    } else {\n      model.line.getPoints().setPoint(0, pt3);\n      model.line.getPoints().setPoint(1, pt1);\n    }\n    const intersectLine = model.line.intersectWithLine(p1, p2, tol, x, pcoords);\n    outObj.betweenPoints = intersectLine.betweenPoints;\n    outObj.t = intersectLine.t;\n    if (intersectLine.intersect) {\n      const pt3Pt1 = [];\n      const pt3Pt2 = [];\n      const pt3X = [];\n      // Compute r and s manually, using dot and norm.\n      for (let i = 0; i < 3; i++) {\n        pt3Pt1[i] = pt1[i] - pt3[i];\n        pt3Pt2[i] = pt2[i] - pt3[i];\n        pt3X[i] = x[i] - pt3[i];\n      }\n      pcoords[0] = dot(pt3X, pt3Pt1) / dist2Pt3Pt1;\n      pcoords[1] = dot(pt3X, pt3Pt2) / dist2Pt2Pt3;\n      outObj.intersect = 1;\n      return outObj;\n    }\n    pcoords[0] = 0.0;\n    pcoords[1] = 0.0;\n    outObj.intersect = 0;\n    return outObj;\n  };\n  publicAPI.evaluatePosition = (x, closestPoint, pcoords, weights) => {\n    // will return obj\n    const outObj = {\n      subId: 0,\n      dist2: 0,\n      evaluation: -1\n    };\n    let i;\n    let j;\n    const pt1 = [];\n    const pt2 = [];\n    const pt3 = [];\n    const n = [];\n    let fabsn;\n    const rhs = [];\n    const c1 = [];\n    const c2 = [];\n    let det = 0;\n    let idx = 0;\n    const indices = [];\n    let dist2Point;\n    let dist2Line1;\n    let dist2Line2;\n    let closest = [];\n    const closestPoint1 = [];\n    const closestPoint2 = [];\n    const cp = [];\n    outObj.subId = 0;\n    pcoords[2] = 0.0;\n\n    // Get normal for triangle, only the normal direction is needed, i.e. the\n    // normal need not be normalized (unit length)\n    //\n    model.points.getPoint(1, pt1);\n    model.points.getPoint(2, pt2);\n    model.points.getPoint(0, pt3);\n    computeNormalDirection(pt1, pt2, pt3, n);\n\n    // Project point to plane\n    vtkPlane.generalizedProjectPoint(x, pt1, n, cp);\n\n    // Construct matrices.  Since we have over determined system, need to find\n    // which 2 out of 3 equations to use to develop equations. (Any 2 should\n    // work since we've projected point to plane.)\n    let maxComponent = 0.0;\n    for (i = 0; i < 3; i++) {\n      // trying to avoid an expensive call to fabs()\n      if (n[i] < 0) {\n        fabsn = -n[i];\n      } else {\n        fabsn = n[i];\n      }\n      if (fabsn > maxComponent) {\n        maxComponent = fabsn;\n        idx = i;\n      }\n    }\n    for (j = 0, i = 0; i < 3; i++) {\n      if (i !== idx) {\n        indices[j++] = i;\n      }\n    }\n    for (i = 0; i < 2; i++) {\n      rhs[i] = cp[indices[i]] - pt3[indices[i]];\n      c1[i] = pt1[indices[i]] - pt3[indices[i]];\n      c2[i] = pt2[indices[i]] - pt3[indices[i]];\n    }\n    det = determinant2x2(c1, c2);\n    if (det === 0.0) {\n      pcoords[0] = 0.0;\n      pcoords[1] = 0.0;\n      outObj.evaluation = -1;\n      return outObj;\n    }\n    pcoords[0] = determinant2x2(rhs, c2) / det;\n    pcoords[1] = determinant2x2(c1, rhs) / det;\n\n    // Okay, now find closest point to element\n    weights[0] = 1 - (pcoords[0] + pcoords[1]);\n    weights[1] = pcoords[0];\n    weights[2] = pcoords[1];\n    if (weights[0] >= 0.0 && weights[0] <= 1.0 && weights[1] >= 0.0 && weights[1] <= 1.0 && weights[2] >= 0.0 && weights[2] <= 1.0) {\n      // projection distance\n      if (closestPoint) {\n        outObj.dist2 = distance2BetweenPoints(cp, x);\n        closestPoint[0] = cp[0];\n        closestPoint[1] = cp[1];\n        closestPoint[2] = cp[2];\n      }\n      outObj.evaluation = 1;\n    } else {\n      let t;\n      if (closestPoint) {\n        if (weights[1] < 0.0 && weights[2] < 0.0) {\n          dist2Point = distance2BetweenPoints(x, pt3);\n          dist2Line1 = vtkLine.distanceToLine(x, pt1, pt3, t, closestPoint1);\n          dist2Line2 = vtkLine.distanceToLine(x, pt3, pt2, t, closestPoint2);\n          if (dist2Point < dist2Line1) {\n            outObj.dist2 = dist2Point;\n            closest = pt3;\n          } else {\n            outObj.dist2 = dist2Line1;\n            closest = closestPoint1;\n          }\n          if (dist2Line2 < outObj.dist2) {\n            outObj.dist2 = dist2Line2;\n            closest = closestPoint2;\n          }\n          for (i = 0; i < 3; i++) {\n            closestPoint[i] = closest[i];\n          }\n        } else if (weights[2] < 0.0 && weights[0] < 0.0) {\n          dist2Point = distance2BetweenPoints(x, pt1);\n          dist2Line1 = vtkLine.distanceToLine(x, pt1, pt3, t, closestPoint1);\n          dist2Line2 = vtkLine.distanceToLine(x, pt1, pt2, t, closestPoint2);\n          if (dist2Point < dist2Line1) {\n            outObj.dist2 = dist2Point;\n            closest = pt1;\n          } else {\n            outObj.dist2 = dist2Line1;\n            closest = closestPoint1;\n          }\n          if (dist2Line2 < outObj.dist2) {\n            outObj.dist2 = dist2Line2;\n            closest = closestPoint2;\n          }\n          for (i = 0; i < 3; i++) {\n            closestPoint[i] = closest[i];\n          }\n        } else if (weights[1] < 0.0 && weights[0] < 0.0) {\n          dist2Point = distance2BetweenPoints(x, pt2);\n          dist2Line1 = vtkLine.distanceToLine(x, pt2, pt3, t, closestPoint1);\n          dist2Line2 = vtkLine.distanceToLine(x, pt1, pt2, t, closestPoint2);\n          if (dist2Point < dist2Line1) {\n            outObj.dist2 = dist2Point;\n            closest = pt2;\n          } else {\n            outObj.dist2 = dist2Line1;\n            closest = closestPoint1;\n          }\n          if (dist2Line2 < outObj.dist2) {\n            outObj.dist2 = dist2Line2;\n            closest = closestPoint2;\n          }\n          for (i = 0; i < 3; i++) {\n            closestPoint[i] = closest[i];\n          }\n        } else if (weights[0] < 0.0) {\n          const lineDistance = vtkLine.distanceToLine(x, pt1, pt2, closestPoint);\n          outObj.dist2 = lineDistance.distance;\n        } else if (weights[1] < 0.0) {\n          const lineDistance = vtkLine.distanceToLine(x, pt2, pt3, closestPoint);\n          outObj.dist2 = lineDistance.distance;\n        } else if (weights[2] < 0.0) {\n          const lineDistance = vtkLine.distanceToLine(x, pt1, pt3, closestPoint);\n          outObj.dist2 = lineDistance.distance;\n        }\n      }\n      outObj.evaluation = 0;\n    }\n    return outObj;\n  };\n  publicAPI.evaluateLocation = (pcoords, x, weights) => {\n    const p0 = [];\n    const p1 = [];\n    const p2 = [];\n    model.points.getPoint(0, p0);\n    model.points.getPoint(1, p1);\n    model.points.getPoint(2, p2);\n    const u3 = 1.0 - pcoords[0] - pcoords[1];\n    for (let i = 0; i < 3; i++) {\n      x[i] = p0[i] * u3 + p1[i] * pcoords[0] + p2[i] * pcoords[1];\n    }\n    weights[0] = u3;\n    weights[1] = pcoords[0];\n    weights[2] = pcoords[1];\n  };\n  publicAPI.getParametricDistance = pcoords => {\n    let pDist;\n    let pDistMax = 0.0;\n    const pc = [];\n    pc[0] = pcoords[0];\n    pc[1] = pcoords[1];\n    pc[2] = 1.0 - pcoords[0] - pcoords[1];\n    for (let i = 0; i < 3; i++) {\n      if (pc[i] < 0.0) {\n        pDist = -pc[i];\n      } else if (pc[i] > 1.0) {\n        pDist = pc[i] - 1.0;\n      } else {\n        // inside the cell in the parametric direction\n        pDist = 0.0;\n      }\n      if (pDist > pDistMax) {\n        pDistMax = pDist;\n      }\n    }\n    return pDistMax;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n  vtkCell.extend(publicAPI, model, initialValues);\n  vtkTriangle(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkTriangle');\n\n// ----------------------------------------------------------------------------\n\nvar vtkTriangle$1 = {\n  newInstance,\n  extend,\n  ...STATIC\n};\n\nexport { STATIC, vtkTriangle$1 as default, extend, newInstance };\n","const POLYDATA_FIELDS = ['verts', 'lines', 'polys', 'strips'];\nvar Constants = {\n  POLYDATA_FIELDS\n};\n\nexport { POLYDATA_FIELDS, Constants as default };\n","import { m as macro } from '../../macros2.js';\nimport vtk from '../../vtk.js';\nimport vtkCellArray from '../Core/CellArray.js';\nimport vtkCellLinks from './CellLinks.js';\nimport vtkCellTypes from './CellTypes.js';\nimport vtkLine from './Line.js';\nimport vtkPointSet from './PointSet.js';\nimport vtkTriangle from './Triangle.js';\nimport { CellType } from './CellTypes/Constants.js';\nimport { POLYDATA_FIELDS } from './PolyData/Constants.js';\n\nconst {\n  vtkWarningMacro\n} = macro;\nconst CELL_FACTORY = {\n  [CellType.VTK_LINE]: vtkLine,\n  [CellType.VTK_POLY_LINE]: vtkLine,\n  [CellType.VTK_TRIANGLE]: vtkTriangle\n};\n\n// ----------------------------------------------------------------------------\n// vtkPolyData methods\n// ----------------------------------------------------------------------------\n\nfunction vtkPolyData(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkPolyData');\n  function camelize(str) {\n    return str.replace(/(?:^\\w|[A-Z]|\\b\\w)/g, letter => letter.toUpperCase()).replace(/\\s+/g, '');\n  }\n\n  // build empty cell arrays and set methods\n  POLYDATA_FIELDS.forEach(type => {\n    publicAPI[`getNumberOf${camelize(type)}`] = () => model[type].getNumberOfCells();\n    if (!model[type]) {\n      model[type] = vtkCellArray.newInstance();\n    } else {\n      model[type] = vtk(model[type]);\n    }\n  });\n  publicAPI.getNumberOfCells = () => POLYDATA_FIELDS.reduce((num, cellType) => num + model[cellType].getNumberOfCells(), 0);\n  const superShallowCopy = publicAPI.shallowCopy;\n  publicAPI.shallowCopy = function (other) {\n    let debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    superShallowCopy(other, debug);\n    POLYDATA_FIELDS.forEach(type => {\n      model[type] = vtkCellArray.newInstance();\n      model[type].shallowCopy(other.getReferenceByName(type));\n    });\n  };\n  publicAPI.buildCells = () => {\n    // here are the number of cells we have\n    const nVerts = publicAPI.getNumberOfVerts();\n    const nLines = publicAPI.getNumberOfLines();\n    const nPolys = publicAPI.getNumberOfPolys();\n    const nStrips = publicAPI.getNumberOfStrips();\n\n    // pre-allocate the space we need\n    const nCells = nVerts + nLines + nPolys + nStrips;\n    const types = new Uint8Array(nCells);\n    let pTypes = types;\n    const locs = new Uint32Array(nCells);\n    let pLocs = locs;\n\n    // record locations and type of each cell.\n    // verts\n    if (nVerts) {\n      let nextCellPts = 0;\n      model.verts.getCellSizes().forEach((numCellPts, index) => {\n        pLocs[index] = nextCellPts;\n        pTypes[index] = numCellPts > 1 ? CellType.VTK_POLY_VERTEX : CellType.VTK_VERTEX;\n        nextCellPts += numCellPts + 1;\n      });\n      pLocs = pLocs.subarray(nVerts);\n      pTypes = pTypes.subarray(nVerts);\n    }\n\n    // lines\n    if (nLines) {\n      let nextCellPts = 0;\n      model.lines.getCellSizes().forEach((numCellPts, index) => {\n        pLocs[index] = nextCellPts;\n        pTypes[index] = numCellPts > 2 ? CellType.VTK_POLY_LINE : CellType.VTK_LINE;\n        if (numCellPts === 1) {\n          vtkWarningMacro('Building VTK_LINE ', index, ' with only one point, but VTK_LINE needs at least two points. Check the input.');\n        }\n        nextCellPts += numCellPts + 1;\n      });\n      pLocs = pLocs.subarray(nLines);\n      pTypes = pTypes.subarray(nLines);\n    }\n\n    // polys\n    if (nPolys) {\n      let nextCellPts = 0;\n      model.polys.getCellSizes().forEach((numCellPts, index) => {\n        pLocs[index] = nextCellPts;\n        switch (numCellPts) {\n          case 3:\n            pTypes[index] = CellType.VTK_TRIANGLE;\n            break;\n          case 4:\n            pTypes[index] = CellType.VTK_QUAD;\n            break;\n          default:\n            pTypes[index] = CellType.VTK_POLYGON;\n            break;\n        }\n        if (numCellPts < 3) {\n          vtkWarningMacro('Building VTK_TRIANGLE ', index, ' with less than three points, but VTK_TRIANGLE needs at least three points. Check the input.');\n        }\n        nextCellPts += numCellPts + 1;\n      });\n      pLocs += pLocs.subarray(nPolys);\n      pTypes += pTypes.subarray(nPolys);\n    }\n\n    // strips\n    if (nStrips) {\n      let nextCellPts = 0;\n      pTypes.fill(CellType.VTK_TRIANGLE_STRIP, 0, nStrips);\n      model.strips.getCellSizes().forEach((numCellPts, index) => {\n        pLocs[index] = nextCellPts;\n        nextCellPts += numCellPts + 1;\n      });\n    }\n\n    // set up the cell types data structure\n    model.cells = vtkCellTypes.newInstance();\n    model.cells.setCellTypes(nCells, types, locs);\n  };\n\n  /**\n   * Create upward links from points to cells that use each point. Enables\n   * topologically complex queries.\n   */\n  publicAPI.buildLinks = function () {\n    let initialSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    if (model.cells === undefined) {\n      publicAPI.buildCells();\n    }\n    model.links = vtkCellLinks.newInstance();\n    if (initialSize > 0) {\n      model.links.allocate(initialSize);\n    } else {\n      model.links.allocate(publicAPI.getPoints().getNumberOfPoints());\n    }\n    model.links.buildLinks(publicAPI);\n  };\n  publicAPI.getCellType = cellId => model.cells.getCellType(cellId);\n  publicAPI.getCellPoints = cellId => {\n    const cellType = publicAPI.getCellType(cellId);\n    let cells = null;\n    switch (cellType) {\n      case CellType.VTK_VERTEX:\n      case CellType.VTK_POLY_VERTEX:\n        cells = model.verts;\n        break;\n      case CellType.VTK_LINE:\n      case CellType.VTK_POLY_LINE:\n        cells = model.lines;\n        break;\n      case CellType.VTK_TRIANGLE:\n      case CellType.VTK_QUAD:\n      case CellType.VTK_POLYGON:\n        cells = model.polys;\n        break;\n      case CellType.VTK_TRIANGLE_STRIP:\n        cells = model.strips;\n        break;\n      default:\n        cells = null;\n        return {\n          type: 0,\n          cellPointIds: null\n        };\n    }\n    const loc = model.cells.getCellLocation(cellId);\n    const cellPointIds = cells.getCell(loc);\n    return {\n      cellType,\n      cellPointIds\n    };\n  };\n  publicAPI.getPointCells = ptId => model.links.getCells(ptId);\n  publicAPI.getCellEdgeNeighbors = (cellId, point1, point2) => {\n    const link1 = model.links.getLink(point1);\n    const link2 = model.links.getLink(point2);\n    return link1.cells.filter(cell => cell !== cellId && link2.cells.indexOf(cell) !== -1);\n  };\n\n  /**\n   * If you know the type of cell, you may provide it to improve performances.\n   */\n  publicAPI.getCell = function (cellId) {\n    let cellHint = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    const cellInfo = publicAPI.getCellPoints(cellId);\n    const cell = cellHint || CELL_FACTORY[cellInfo.cellType].newInstance();\n    cell.initialize(publicAPI.getPoints(), cellInfo.cellPointIds);\n    return cell;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  // verts: null,\n  // lines: null,\n  // polys: null,\n  // strips: null,\n  // cells: null,\n  // links: null,\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkPointSet.extend(publicAPI, model, initialValues);\n  macro.get(publicAPI, model, ['cells', 'links']);\n  macro.setGet(publicAPI, model, ['verts', 'lines', 'polys', 'strips']);\n\n  // Object specific methods\n  vtkPolyData(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkPolyData');\n\n// ----------------------------------------------------------------------------\n\nvar vtkPolyData$1 = {\n  newInstance,\n  extend\n};\n\nexport { CELL_FACTORY, vtkPolyData$1 as default, extend, newInstance };\n","import macro from '@kitware/vtk.js/macros';\nimport vtkOpenGLTexture from '@kitware/vtk.js/Rendering/OpenGL/Texture';\nimport HalfFloat from '@kitware/vtk.js/Common/Core/HalfFloat';\nimport { getConfiguration } from '../../init';\nfunction vtkStreamingOpenGLTexture(publicAPI, model) {\n    model.classHierarchy.push('vtkStreamingOpenGLTexture');\n    const superCreate3DFilterableFromRaw = publicAPI.create3DFilterableFromRaw;\n    publicAPI.create3DFilterableFromRaw = (width, height, depth, numComps, dataType, data, preferSizeOverAccuracy) => {\n        model.inputDataType = dataType;\n        model.inputNumComps = numComps;\n        superCreate3DFilterableFromRaw(width, height, depth, numComps, dataType, data, preferSizeOverAccuracy);\n    };\n    publicAPI.update3DFromRaw = (data) => {\n        const { updatedFrames } = model;\n        if (!updatedFrames.length) {\n            return;\n        }\n        model._openGLRenderWindow.activateTexture(publicAPI);\n        publicAPI.createTexture();\n        publicAPI.bind();\n        let bytesPerVoxel;\n        let TypedArrayConstructor;\n        if (data instanceof Uint8Array) {\n            bytesPerVoxel = 1;\n            TypedArrayConstructor = Uint8Array;\n        }\n        else if (data instanceof Int16Array) {\n            bytesPerVoxel = 2;\n            TypedArrayConstructor = Int16Array;\n        }\n        else if (data instanceof Uint16Array) {\n            bytesPerVoxel = 2;\n            TypedArrayConstructor = Uint16Array;\n        }\n        else if (data instanceof Float32Array) {\n            bytesPerVoxel = 4;\n            TypedArrayConstructor = Float32Array;\n        }\n        else {\n            throw new Error(`No support for given TypedArray.`);\n        }\n        for (let i = 0; i < updatedFrames.length; i++) {\n            if (updatedFrames[i]) {\n                model.fillSubImage3D(data, i, bytesPerVoxel, TypedArrayConstructor);\n            }\n        }\n        model.updatedFrames = [];\n        if (model.generateMipmap) {\n            model.context.generateMipmap(model.target);\n        }\n        publicAPI.deactivate();\n        return true;\n    };\n    model.fillSubImage3D = (data, frameIndex, bytesPerVoxel, TypedArrayConstructor) => {\n        const buffer = data.buffer;\n        const frameLength = model.width * model.height;\n        const frameLengthInBytes = frameLength * model.components * bytesPerVoxel;\n        const zOffset = frameIndex * frameLengthInBytes;\n        const rowLength = model.width * model.components;\n        const gl = model.context;\n        const MAX_TEXTURE_SIZE = gl.getParameter(gl.MAX_TEXTURE_SIZE);\n        let blockHeight = Math.floor((bytesPerVoxel * MAX_TEXTURE_SIZE) / model.width);\n        blockHeight = Math.min(blockHeight, model.height);\n        const { useNorm16Texture, preferSizeOverAccuracy } = getConfiguration().rendering;\n        if (useNorm16Texture && !preferSizeOverAccuracy) {\n            blockHeight = 1;\n        }\n        const multiRowBlockLength = rowLength * blockHeight;\n        const multiRowBlockLengthInBytes = multiRowBlockLength * bytesPerVoxel;\n        const normalBlocks = Math.floor(model.height / blockHeight);\n        const lastBlockHeight = model.height % blockHeight;\n        const multiRowLastBlockLength = rowLength * lastBlockHeight;\n        for (let block = 0; block < normalBlocks; block++) {\n            const yOffset = block * blockHeight;\n            let dataView = new TypedArrayConstructor(buffer, zOffset + block * multiRowBlockLengthInBytes, multiRowBlockLength);\n            if (model.useHalfFloat &&\n                (TypedArrayConstructor === Uint16Array ||\n                    TypedArrayConstructor === Int16Array)) {\n                for (let idx = 0; idx < dataView.length; idx++) {\n                    dataView[idx] = HalfFloat.toHalf(dataView[idx]);\n                }\n                if (TypedArrayConstructor === Int16Array) {\n                    dataView = new Uint16Array(dataView);\n                }\n            }\n            gl.texSubImage3D(model.target, 0, 0, yOffset, frameIndex, model.width, blockHeight, 1, model.format, model.openGLDataType, dataView);\n        }\n        if (lastBlockHeight !== 0) {\n            const yOffset = normalBlocks * blockHeight;\n            const dataView = new TypedArrayConstructor(buffer, zOffset + normalBlocks * multiRowBlockLengthInBytes, multiRowLastBlockLength);\n            gl.texSubImage3D(model.target, 0, 0, yOffset, frameIndex, model.width, lastBlockHeight, 1, model.format, model.openGLDataType, dataView);\n        }\n    };\n    publicAPI.getTextureParameters = () => {\n        return {\n            width: model.width,\n            height: model.height,\n            depth: model.depth,\n            numComps: model.inputNumComps,\n            dataType: model.inputDataType,\n        };\n    };\n    publicAPI.setUpdatedFrame = (frameIndex) => {\n        model.updatedFrames[frameIndex] = true;\n    };\n}\nconst DEFAULT_VALUES = {\n    updatedFrames: [],\n};\nexport function extend(publicAPI, model, initialValues = {}) {\n    Object.assign(model, DEFAULT_VALUES, initialValues);\n    vtkOpenGLTexture.extend(publicAPI, model, initialValues);\n    vtkStreamingOpenGLTexture(publicAPI, model);\n}\nexport const newInstance = macro.newInstance(extend, 'vtkStreamingOpenGLTexture');\nexport default { newInstance, extend };\n//# sourceMappingURL=vtkStreamingOpenGLTexture.js.map","const providers = [];\nexport function addProvider(provider, priority = 0) {\n    let i;\n    for (i = 0; i < providers.length; i++) {\n        if (providers[i].priority <= priority) {\n            break;\n        }\n    }\n    providers.splice(i, 0, {\n        priority,\n        provider,\n    });\n}\nexport function removeProvider(provider) {\n    for (let i = 0; i < providers.length; i++) {\n        if (providers[i].provider === provider) {\n            providers.splice(i, 1);\n            break;\n        }\n    }\n}\nexport function removeAllProviders() {\n    while (providers.length > 0) {\n        providers.pop();\n    }\n}\nfunction getMetaData(type, ...queries) {\n    for (let i = 0; i < providers.length; i++) {\n        const result = providers[i].provider(type, ...queries);\n        if (result !== undefined) {\n            return result;\n        }\n    }\n}\nexport { getMetaData as get };\n//# sourceMappingURL=metaData.js.map","import vtkImageData from '@kitware/vtk.js/Common/DataModel/ImageData';\nimport vtkDataArray from '@kitware/vtk.js/Common/Core/DataArray';\nimport isTypedArray from '../../utilities/isTypedArray';\nimport { genericMetadataProvider, getMinMax, imageIdToURI, } from '../../utilities';\nimport { vtkStreamingOpenGLTexture } from '../../RenderingEngine/vtkClasses';\nimport cache from '../cache';\nimport * as metaData from '../../metaData';\nexport class ImageVolume {\n    constructor(props) {\n        this._imageIdsIndexMap = new Map();\n        this._imageURIsIndexMap = new Map();\n        this.cornerstoneImageMetaData = null;\n        this.imageCacheOffsetMap = new Map();\n        this.isPreScaled = false;\n        const { imageIds, scalarData, scaling, dimensions, spacing, origin, direction, volumeId, referencedVolumeId, sizeInBytes, imageData, metadata, referencedImageIds, additionalDetails, } = props;\n        this.imageIds = imageIds;\n        this.volumeId = volumeId;\n        this.metadata = metadata;\n        this.dimensions = dimensions;\n        this.spacing = spacing;\n        this.origin = origin;\n        this.direction = direction;\n        this.scalarData = scalarData;\n        this.sizeInBytes = sizeInBytes;\n        this.vtkOpenGLTexture = vtkStreamingOpenGLTexture.newInstance();\n        this.numVoxels =\n            this.dimensions[0] * this.dimensions[1] * this.dimensions[2];\n        if (imageData) {\n            this.imageData = imageData;\n        }\n        else {\n            const imageData = vtkImageData.newInstance();\n            const scalarArray = vtkDataArray.newInstance({\n                name: 'Pixels',\n                numberOfComponents: 1,\n                values: scalarData,\n            });\n            imageData.setDimensions(dimensions);\n            imageData.setSpacing(spacing);\n            imageData.setDirection(direction);\n            imageData.setOrigin(origin);\n            imageData.getPointData().setScalars(scalarArray);\n            this.imageData = imageData;\n        }\n        this.numFrames = this._getNumFrames();\n        this._reprocessImageIds();\n        this._createCornerstoneImageMetaData();\n        if (scaling) {\n            this.scaling = scaling;\n        }\n        if (referencedVolumeId) {\n            this.referencedVolumeId = referencedVolumeId;\n        }\n        if (referencedImageIds) {\n            this.referencedImageIds = referencedImageIds;\n        }\n        if (additionalDetails) {\n            this.additionalDetails = additionalDetails;\n        }\n    }\n    get imageIds() {\n        return this._imageIds;\n    }\n    set imageIds(newImageIds) {\n        this._imageIds = newImageIds;\n        this._reprocessImageIds();\n    }\n    _reprocessImageIds() {\n        this._imageIdsIndexMap.clear();\n        this._imageURIsIndexMap.clear();\n        this._imageIds.forEach((imageId, i) => {\n            const imageURI = imageIdToURI(imageId);\n            this._imageIdsIndexMap.set(imageId, i);\n            this._imageURIsIndexMap.set(imageURI, i);\n        });\n    }\n    isDynamicVolume() {\n        return false;\n    }\n    getScalarData() {\n        if (isTypedArray(this.scalarData)) {\n            return this.scalarData;\n        }\n        throw new Error('Unknown scalar data type');\n    }\n    getImageIdIndex(imageId) {\n        return this._imageIdsIndexMap.get(imageId);\n    }\n    getImageURIIndex(imageURI) {\n        return this._imageURIsIndexMap.get(imageURI);\n    }\n    destroy() {\n        this.imageData.delete();\n        this.imageData = null;\n        this.scalarData = null;\n        this.vtkOpenGLTexture.releaseGraphicsResources();\n        this.vtkOpenGLTexture.delete();\n    }\n    getScalarDataArrays() {\n        return this.isDynamicVolume()\n            ? this.scalarData\n            : [this.scalarData];\n    }\n    decache(completelyRemove = false) {\n        if (completelyRemove) {\n            this.removeFromCache();\n        }\n        else {\n            this.convertToImageSlicesAndCache();\n        }\n    }\n    removeFromCache() {\n        cache.removeVolumeLoadObject(this.volumeId);\n    }\n    getScalarDataLength() {\n        const { scalarData } = this;\n        return this.isDynamicVolume()\n            ? scalarData[0].length\n            : scalarData.length;\n    }\n    _getNumFrames() {\n        const { imageIds, scalarData } = this;\n        const scalarDataCount = this.isDynamicVolume() ? scalarData.length : 1;\n        return imageIds.length / scalarDataCount;\n    }\n    _getScalarDataLength() {\n        const { scalarData } = this;\n        return this.isDynamicVolume()\n            ? scalarData[0].length\n            : scalarData.length;\n    }\n    _createCornerstoneImageMetaData() {\n        const { numFrames } = this;\n        if (numFrames === 0) {\n            return;\n        }\n        const bytesPerImage = this.sizeInBytes / numFrames;\n        const scalarDataLength = this._getScalarDataLength();\n        const numComponents = scalarDataLength / this.numVoxels;\n        const pixelsPerImage = this.dimensions[0] * this.dimensions[1] * numComponents;\n        const { PhotometricInterpretation, voiLut, VOILUTFunction } = this.metadata;\n        let windowCenter = [];\n        let windowWidth = [];\n        if (voiLut && voiLut.length) {\n            windowCenter = voiLut.map((voi) => {\n                return voi.windowCenter;\n            });\n            windowWidth = voiLut.map((voi) => {\n                return voi.windowWidth;\n            });\n        }\n        const color = numComponents > 1 ? true : false;\n        this.cornerstoneImageMetaData = {\n            bytesPerImage,\n            numComponents,\n            pixelsPerImage,\n            windowCenter,\n            windowWidth,\n            color,\n            rgba: false,\n            spacing: this.spacing,\n            dimensions: this.dimensions,\n            photometricInterpretation: PhotometricInterpretation,\n            voiLUTFunction: VOILUTFunction,\n            invert: PhotometricInterpretation === 'MONOCHROME1',\n        };\n    }\n    getScalarDataByImageIdIndex(imageIdIndex) {\n        if (imageIdIndex < 0 || imageIdIndex >= this.imageIds.length) {\n            throw new Error('imageIdIndex out of range');\n        }\n        const scalarDataArrays = this.getScalarDataArrays();\n        const scalarDataIndex = Math.floor(imageIdIndex / this.numFrames);\n        return scalarDataArrays[scalarDataIndex];\n    }\n    getCornerstoneImage(imageId, imageIdIndex) {\n        const { imageIds } = this;\n        const frameIndex = this.imageIdIndexToFrameIndex(imageIdIndex);\n        const { bytesPerImage, pixelsPerImage, windowCenter, windowWidth, numComponents, color, dimensions, spacing, invert, voiLUTFunction, photometricInterpretation, } = this.cornerstoneImageMetaData;\n        const scalarData = this.getScalarDataByImageIdIndex(imageIdIndex);\n        const volumeBuffer = scalarData.buffer;\n        const TypedArray = scalarData.constructor;\n        const bytePerPixel = bytesPerImage / pixelsPerImage;\n        let byteOffset = bytesPerImage * frameIndex;\n        if (scalarData.BYTES_PER_ELEMENT !== bytePerPixel) {\n            byteOffset *= scalarData.BYTES_PER_ELEMENT / bytePerPixel;\n        }\n        const imageScalarData = new TypedArray(pixelsPerImage);\n        const volumeBufferView = new TypedArray(volumeBuffer, byteOffset, pixelsPerImage);\n        imageScalarData.set(volumeBufferView);\n        const volumeImageId = imageIds[imageIdIndex];\n        const modalityLutModule = metaData.get('modalityLutModule', volumeImageId) || {};\n        const minMax = getMinMax(imageScalarData);\n        const intercept = modalityLutModule.rescaleIntercept\n            ? modalityLutModule.rescaleIntercept\n            : 0;\n        return {\n            imageId,\n            intercept,\n            windowCenter,\n            windowWidth,\n            voiLUTFunction,\n            color,\n            rgba: false,\n            numComps: numComponents,\n            rows: dimensions[1],\n            columns: dimensions[0],\n            sizeInBytes: imageScalarData.byteLength,\n            getPixelData: () => imageScalarData,\n            minPixelValue: minMax.min,\n            maxPixelValue: minMax.max,\n            slope: modalityLutModule.rescaleSlope\n                ? modalityLutModule.rescaleSlope\n                : 1,\n            getCanvas: undefined,\n            height: dimensions[0],\n            width: dimensions[1],\n            columnPixelSpacing: spacing[0],\n            rowPixelSpacing: spacing[1],\n            invert,\n            photometricInterpretation,\n        };\n    }\n    imageIdIndexToFrameIndex(imageIdIndex) {\n        return imageIdIndex % this.numFrames;\n    }\n    convertToCornerstoneImage(imageId, imageIdIndex) {\n        return this.getCornerstoneImageLoadObject(imageId, imageIdIndex);\n    }\n    getCornerstoneImageLoadObject(imageId, imageIdIndex) {\n        const image = this.getCornerstoneImage(imageId, imageIdIndex);\n        const imageLoadObject = {\n            promise: Promise.resolve(image),\n        };\n        return imageLoadObject;\n    }\n    getCornerstoneImages() {\n        const { imageIds } = this;\n        return imageIds.map((imageId, imageIdIndex) => {\n            return this.getCornerstoneImage(imageId, imageIdIndex);\n        });\n    }\n    convertToImageSlicesAndCache() {\n        const byteLength = this.sizeInBytes;\n        if (!this.imageIds?.length) {\n            const referencedVolumeId = this.referencedVolumeId;\n            const referencedVolume = cache.getVolume(referencedVolumeId);\n            const numSlices = referencedVolume?.imageIds?.length || this.dimensions[2];\n            this.imageIds = Array.from({ length: numSlices }, (_, i) => {\n                return `generated:${this.volumeId}:${i}`;\n            });\n            this._reprocessImageIds();\n            this.numFrames = this._getNumFrames();\n            this._createCornerstoneImageMetaData();\n        }\n        const numImages = this.imageIds.length;\n        const { bytesPerImage } = this.cornerstoneImageMetaData;\n        let bytesRemaining = cache.decacheIfNecessaryUntilBytesAvailable(byteLength, this.imageIds);\n        for (let imageIdIndex = 0; imageIdIndex < numImages; imageIdIndex++) {\n            const imageId = this.imageIds[imageIdIndex];\n            bytesRemaining = bytesRemaining - bytesPerImage;\n            const image = this.getCornerstoneImage(imageId, imageIdIndex);\n            const imageLoadObject = {\n                promise: Promise.resolve(image),\n            };\n            if (!cache.getImageLoadObject(imageId)) {\n                cache.putImageLoadObject(imageId, imageLoadObject).catch((err) => {\n                    console.error(err);\n                });\n            }\n            if (bytesRemaining <= bytesPerImage) {\n                break;\n            }\n            const imageOrientationPatient = [\n                this.direction[0],\n                this.direction[1],\n                this.direction[2],\n                this.direction[3],\n                this.direction[4],\n                this.direction[5],\n            ];\n            const precision = 6;\n            const imagePositionPatient = [\n                parseFloat((this.origin[0] +\n                    imageIdIndex * this.direction[6] * this.spacing[0]).toFixed(precision)),\n                parseFloat((this.origin[1] +\n                    imageIdIndex * this.direction[7] * this.spacing[1]).toFixed(precision)),\n                parseFloat((this.origin[2] +\n                    imageIdIndex * this.direction[8] * this.spacing[2]).toFixed(precision)),\n            ];\n            const pixelData = image.getPixelData();\n            const bitsAllocated = pixelData.BYTES_PER_ELEMENT * 8;\n            const imagePixelModule = {\n                bitsAllocated,\n                photometricInterpretation: image.photometricInterpretation,\n                windowWidth: image.windowWidth,\n                windowCenter: image.windowCenter,\n                voiLUTFunction: image.voiLUTFunction,\n            };\n            const imagePlaneModule = {\n                rowCosines: [this.direction[0], this.direction[1], this.direction[2]],\n                columnCosines: [\n                    this.direction[3],\n                    this.direction[4],\n                    this.direction[5],\n                ],\n                pixelSpacing: [this.spacing[0], this.spacing[1]],\n                imageOrientationPatient: imageOrientationPatient,\n                imagePositionPatient: imagePositionPatient,\n                columnPixelSpacing: image.columnPixelSpacing,\n                rowPixelSpacing: image.rowPixelSpacing,\n                columns: image.columns,\n                rows: image.rows,\n            };\n            const generalSeriesModule = {};\n            const metadata = {\n                imagePixelModule,\n                imagePlaneModule,\n                generalSeriesModule,\n            };\n            ['imagePixelModule', 'imagePlaneModule', 'generalSeriesModule'].forEach((type) => {\n                genericMetadataProvider.add(imageId, {\n                    type,\n                    metadata: metadata[type],\n                });\n            });\n        }\n        this.removeFromCache();\n        return this.imageIds;\n    }\n}\nexport default ImageVolume;\n//# sourceMappingURL=ImageVolume.js.map","export default function isTypedArray(obj) {\n    return (obj instanceof Int8Array ||\n        obj instanceof Uint8Array ||\n        obj instanceof Uint8ClampedArray ||\n        obj instanceof Int16Array ||\n        obj instanceof Uint16Array ||\n        obj instanceof Int32Array ||\n        obj instanceof Uint32Array ||\n        obj instanceof Float32Array ||\n        obj instanceof Float64Array);\n}\n//# sourceMappingURL=isTypedArray.js.map","export default function getMinMax(storedPixelData) {\n    let min = storedPixelData[0];\n    let max = storedPixelData[0];\n    let storedPixel;\n    const numPixels = storedPixelData.length;\n    for (let index = 1; index < numPixels; index++) {\n        storedPixel = storedPixelData[index];\n        min = Math.min(min, storedPixel);\n        max = Math.max(max, storedPixel);\n    }\n    return {\n        min,\n        max,\n    };\n}\n//# sourceMappingURL=getMinMax.js.map","import { triggerEvent, imageIdToURI } from '../utilities';\nimport eventTarget from '../eventTarget';\nimport Events from '../enums/Events';\nimport { ImageVolume } from './classes/ImageVolume';\nconst ONE_GB = 1073741824;\nclass Cache {\n    constructor() {\n        this._imageCache = new Map();\n        this._volumeCache = new Map();\n        this._imageCacheSize = 0;\n        this._volumeCacheSize = 0;\n        this._maxCacheSize = 3 * ONE_GB;\n        this._maxInstanceSize = 2 * ONE_GB - 8;\n        this.setMaxCacheSize = (newMaxCacheSize) => {\n            if (!newMaxCacheSize || typeof newMaxCacheSize !== 'number') {\n                const errorMessage = `New max cacheSize ${this._maxCacheSize} should be defined and should be a number.`;\n                throw new Error(errorMessage);\n            }\n            this._maxCacheSize = newMaxCacheSize;\n        };\n        this.isCacheable = (byteLength) => {\n            if (byteLength > this._maxInstanceSize) {\n                return false;\n            }\n            const unallocatedSpace = this.getBytesAvailable();\n            const imageCacheSize = this._imageCacheSize;\n            const availableSpace = unallocatedSpace + imageCacheSize;\n            return availableSpace > byteLength;\n        };\n        this.getMaxCacheSize = () => this._maxCacheSize;\n        this.getMaxInstanceSize = () => this._maxInstanceSize;\n        this.getCacheSize = () => this._imageCacheSize + this._volumeCacheSize;\n        this._decacheImage = (imageId) => {\n            const { imageLoadObject } = this._imageCache.get(imageId);\n            if (imageLoadObject.cancelFn) {\n                imageLoadObject.cancelFn();\n            }\n            if (imageLoadObject.decache) {\n                imageLoadObject.decache();\n            }\n            this._imageCache.delete(imageId);\n        };\n        this._decacheVolume = (volumeId) => {\n            const cachedVolume = this._volumeCache.get(volumeId);\n            const { volumeLoadObject, volume } = cachedVolume;\n            if (volume.cancelLoading) {\n                volume.cancelLoading();\n            }\n            if (volume.imageData) {\n                volume.imageData.delete();\n            }\n            this._restoreImagesFromBuffer(volume);\n            if (volumeLoadObject.cancelFn) {\n                volumeLoadObject.cancelFn();\n            }\n            if (volumeLoadObject.decache) {\n                volumeLoadObject.decache();\n            }\n            this._volumeCache.delete(volumeId);\n        };\n        this.purgeCache = () => {\n            const imageIterator = this._imageCache.keys();\n            while (true) {\n                const { value: imageId, done } = imageIterator.next();\n                if (done) {\n                    break;\n                }\n                this.removeImageLoadObject(imageId);\n                triggerEvent(eventTarget, Events.IMAGE_CACHE_IMAGE_REMOVED, { imageId });\n            }\n            this.purgeVolumeCache();\n        };\n        this.purgeVolumeCache = () => {\n            const volumeIterator = this._volumeCache.keys();\n            while (true) {\n                const { value: volumeId, done } = volumeIterator.next();\n                if (done) {\n                    break;\n                }\n                this.removeVolumeLoadObject(volumeId);\n                triggerEvent(eventTarget, Events.VOLUME_CACHE_VOLUME_REMOVED, {\n                    volumeId,\n                });\n            }\n        };\n        this.getVolumeLoadObject = (volumeId) => {\n            if (volumeId === undefined) {\n                throw new Error('getVolumeLoadObject: volumeId must not be undefined');\n            }\n            const cachedVolume = this._volumeCache.get(volumeId);\n            if (cachedVolume === undefined) {\n                return;\n            }\n            cachedVolume.timeStamp = Date.now();\n            return cachedVolume.volumeLoadObject;\n        };\n        this.getGeometry = (geometryId) => {\n            if (geometryId == null) {\n                throw new Error('getGeometry: geometryId must not be undefined');\n            }\n            const cachedGeometry = this._geometryCache.get(geometryId);\n            if (cachedGeometry === undefined) {\n                return;\n            }\n            cachedGeometry.timeStamp = Date.now();\n            return cachedGeometry.geometry;\n        };\n        this.getImage = (imageId) => {\n            if (imageId === undefined) {\n                throw new Error('getImage: imageId must not be undefined');\n            }\n            const cachedImage = this._imageCache.get(imageId);\n            if (cachedImage === undefined) {\n                return;\n            }\n            cachedImage.timeStamp = Date.now();\n            return cachedImage.image;\n        };\n        this.getVolume = (volumeId) => {\n            if (volumeId === undefined) {\n                throw new Error('getVolume: volumeId must not be undefined');\n            }\n            const cachedVolume = this._volumeCache.get(volumeId);\n            if (cachedVolume === undefined) {\n                return;\n            }\n            cachedVolume.timeStamp = Date.now();\n            return cachedVolume.volume;\n        };\n        this.removeImageLoadObject = (imageId) => {\n            if (imageId === undefined) {\n                throw new Error('removeImageLoadObject: imageId must not be undefined');\n            }\n            const cachedImage = this._imageCache.get(imageId);\n            if (cachedImage === undefined) {\n                throw new Error('removeImageLoadObject: imageId was not present in imageCache');\n            }\n            this.incrementImageCacheSize(-cachedImage.sizeInBytes);\n            const eventDetails = {\n                imageId,\n            };\n            triggerEvent(eventTarget, Events.IMAGE_CACHE_IMAGE_REMOVED, eventDetails);\n            this._decacheImage(imageId);\n        };\n        this.removeVolumeLoadObject = (volumeId) => {\n            if (volumeId === undefined) {\n                throw new Error('removeVolumeLoadObject: volumeId must not be undefined');\n            }\n            const cachedVolume = this._volumeCache.get(volumeId);\n            if (cachedVolume === undefined) {\n                throw new Error('removeVolumeLoadObject: volumeId was not present in volumeCache');\n            }\n            this.incrementVolumeCacheSize(-cachedVolume.sizeInBytes);\n            const eventDetails = {\n                volume: cachedVolume,\n                volumeId,\n            };\n            triggerEvent(eventTarget, Events.VOLUME_CACHE_VOLUME_REMOVED, eventDetails);\n            this._decacheVolume(volumeId);\n        };\n        this.putGeometryLoadObject = (geometryId, geometryLoadObject) => {\n            if (geometryId == undefined) {\n                throw new Error('putGeometryLoadObject: geometryId must not be undefined');\n            }\n            if (this._geometryCache.has(geometryId)) {\n                throw new Error('putGeometryLoadObject: geometryId already present in geometryCache');\n            }\n            const cachedGeometry = {\n                geometryId,\n                geometryLoadObject,\n                loaded: false,\n                timeStamp: Date.now(),\n                sizeInBytes: 0,\n            };\n            this._geometryCache.set(geometryId, cachedGeometry);\n            return geometryLoadObject.promise\n                .then((geometry) => {\n                if (!this._geometryCache.has(geometryId)) {\n                    console.warn('putGeometryLoadObject: geometryId was removed from geometryCache');\n                    return;\n                }\n                if (Number.isNaN(geometry.sizeInBytes)) {\n                    throw new Error('putGeometryLoadObject: geometry.sizeInBytes is not a number');\n                }\n                cachedGeometry.loaded = true;\n                cachedGeometry.geometry = geometry;\n                cachedGeometry.sizeInBytes = geometry.sizeInBytes;\n                const eventDetails = {\n                    geometry,\n                    geometryId,\n                };\n                triggerEvent(eventTarget, Events.GEOMETRY_CACHE_GEOMETRY_ADDED, eventDetails);\n                return;\n            })\n                .catch((error) => {\n                this._geometryCache.delete(geometryId);\n                throw error;\n            });\n        };\n        this.incrementImageCacheSize = (increment) => {\n            this._imageCacheSize += increment;\n        };\n        this.incrementVolumeCacheSize = (increment) => {\n            this._volumeCacheSize += increment;\n        };\n        this.decrementImageCacheSize = (decrement) => {\n            this._imageCacheSize -= decrement;\n        };\n        this.decrementVolumeCacheSize = (decrement) => {\n            this._volumeCacheSize -= decrement;\n        };\n        this._geometryCache = new Map();\n    }\n    getBytesAvailable() {\n        return this.getMaxCacheSize() - this.getCacheSize();\n    }\n    decacheIfNecessaryUntilBytesAvailable(numBytes, volumeImageIds) {\n        let bytesAvailable = this.getBytesAvailable();\n        if (bytesAvailable >= numBytes) {\n            return bytesAvailable;\n        }\n        let cachedImages = Array.from(this._imageCache.values());\n        function compare(a, b) {\n            if (a.timeStamp > b.timeStamp) {\n                return 1;\n            }\n            if (a.timeStamp < b.timeStamp) {\n                return -1;\n            }\n            return 0;\n        }\n        cachedImages.sort(compare);\n        let cachedImageIds = cachedImages.map((im) => im.imageId);\n        let imageIdsToPurge = cachedImageIds;\n        if (volumeImageIds) {\n            imageIdsToPurge = cachedImageIds.filter((id) => !volumeImageIds.includes(id));\n        }\n        for (const imageId of imageIdsToPurge) {\n            this.removeImageLoadObject(imageId);\n            triggerEvent(eventTarget, Events.IMAGE_CACHE_IMAGE_REMOVED, { imageId });\n            bytesAvailable = this.getBytesAvailable();\n            if (bytesAvailable >= numBytes) {\n                return bytesAvailable;\n            }\n        }\n        cachedImages = Array.from(this._imageCache.values());\n        cachedImageIds = cachedImages.map((im) => im.imageId);\n        for (const imageId of cachedImageIds) {\n            this.removeImageLoadObject(imageId);\n            triggerEvent(eventTarget, Events.IMAGE_CACHE_IMAGE_REMOVED, { imageId });\n            bytesAvailable = this.getBytesAvailable();\n            if (bytesAvailable >= numBytes) {\n                return bytesAvailable;\n            }\n        }\n    }\n    putImageLoadObject(imageId, imageLoadObject) {\n        if (imageId === undefined) {\n            throw new Error('putImageLoadObject: imageId must not be undefined');\n        }\n        if (imageLoadObject.promise === undefined) {\n            throw new Error('putImageLoadObject: imageLoadObject.promise must not be undefined');\n        }\n        if (this._imageCache.has(imageId)) {\n            throw new Error('putImageLoadObject: imageId already in cache');\n        }\n        if (imageLoadObject.cancelFn &&\n            typeof imageLoadObject.cancelFn !== 'function') {\n            throw new Error('putImageLoadObject: imageLoadObject.cancel must be a function');\n        }\n        const cachedImage = {\n            loaded: false,\n            imageId,\n            sharedCacheKey: undefined,\n            imageLoadObject,\n            timeStamp: Date.now(),\n            sizeInBytes: 0,\n        };\n        this._imageCache.set(imageId, cachedImage);\n        return imageLoadObject.promise\n            .then((image) => {\n            if (!this._imageCache.get(imageId)) {\n                console.warn('The image was purged from the cache before it completed loading.');\n                return;\n            }\n            if (image.sizeInBytes === undefined ||\n                Number.isNaN(image.sizeInBytes)) {\n                throw new Error('putImageLoadObject: image.sizeInBytes must not be undefined');\n            }\n            if (image.sizeInBytes.toFixed === undefined) {\n                throw new Error('putImageLoadObject: image.sizeInBytes is not a number');\n            }\n            if (!this.isCacheable(image.sizeInBytes)) {\n                throw new Error(Events.CACHE_SIZE_EXCEEDED);\n            }\n            this.decacheIfNecessaryUntilBytesAvailable(image.sizeInBytes);\n            cachedImage.loaded = true;\n            cachedImage.image = image;\n            cachedImage.sizeInBytes = image.sizeInBytes;\n            this.incrementImageCacheSize(cachedImage.sizeInBytes);\n            const eventDetails = {\n                image: cachedImage,\n            };\n            triggerEvent(eventTarget, Events.IMAGE_CACHE_IMAGE_ADDED, eventDetails);\n            cachedImage.sharedCacheKey = image.sharedCacheKey;\n        })\n            .catch((error) => {\n            this._imageCache.delete(imageId);\n            throw error;\n        });\n    }\n    getImageLoadObject(imageId) {\n        if (imageId === undefined) {\n            throw new Error('getImageLoadObject: imageId must not be undefined');\n        }\n        const cachedImage = this._imageCache.get(imageId);\n        if (cachedImage === undefined) {\n            return;\n        }\n        cachedImage.timeStamp = Date.now();\n        return cachedImage.imageLoadObject;\n    }\n    isLoaded(imageId) {\n        const cachedImage = this._imageCache.get(imageId);\n        if (!cachedImage) {\n            return false;\n        }\n        return cachedImage.loaded;\n    }\n    getVolumeContainingImageId(imageId) {\n        const volumeIds = Array.from(this._volumeCache.keys());\n        const imageIdToUse = imageIdToURI(imageId);\n        for (const volumeId of volumeIds) {\n            const cachedVolume = this._volumeCache.get(volumeId);\n            const { volume } = cachedVolume;\n            if (!volume?.imageIds?.length) {\n                return;\n            }\n            const imageIdIndex = volume.getImageURIIndex(imageIdToUse);\n            if (imageIdIndex > -1) {\n                return { volume, imageIdIndex };\n            }\n        }\n    }\n    getCachedImageBasedOnImageURI(imageId) {\n        const imageURIToUse = imageIdToURI(imageId);\n        const cachedImageIds = Array.from(this._imageCache.keys());\n        const foundImageId = cachedImageIds.find((imageId) => {\n            return imageIdToURI(imageId) === imageURIToUse;\n        });\n        if (!foundImageId) {\n            return;\n        }\n        return this._imageCache.get(foundImageId);\n    }\n    putVolumeLoadObject(volumeId, volumeLoadObject) {\n        if (volumeId === undefined) {\n            throw new Error('putVolumeLoadObject: volumeId must not be undefined');\n        }\n        if (volumeLoadObject.promise === undefined) {\n            throw new Error('putVolumeLoadObject: volumeLoadObject.promise must not be undefined');\n        }\n        if (this._volumeCache.has(volumeId)) {\n            throw new Error(`putVolumeLoadObject: volumeId:${volumeId} already in cache`);\n        }\n        if (volumeLoadObject.cancelFn &&\n            typeof volumeLoadObject.cancelFn !== 'function') {\n            throw new Error('putVolumeLoadObject: volumeLoadObject.cancel must be a function');\n        }\n        const cachedVolume = {\n            loaded: false,\n            volumeId,\n            volumeLoadObject,\n            timeStamp: Date.now(),\n            sizeInBytes: 0,\n        };\n        this._volumeCache.set(volumeId, cachedVolume);\n        return volumeLoadObject.promise\n            .then((volume) => {\n            if (!this._volumeCache.get(volumeId)) {\n                console.warn('The image was purged from the cache before it completed loading.');\n                return;\n            }\n            if (Number.isNaN(volume.sizeInBytes)) {\n                throw new Error('putVolumeLoadObject: volume.sizeInBytes must not be undefined');\n            }\n            if (volume.sizeInBytes.toFixed === undefined) {\n                throw new Error('putVolumeLoadObject: volume.sizeInBytes is not a number');\n            }\n            this.decacheIfNecessaryUntilBytesAvailable(volume.sizeInBytes, volume.imageIds);\n            cachedVolume.volume = volume;\n            cachedVolume.sizeInBytes = volume.sizeInBytes;\n            this.incrementVolumeCacheSize(cachedVolume.sizeInBytes);\n            const eventDetails = {\n                volume: cachedVolume,\n            };\n            triggerEvent(eventTarget, Events.VOLUME_CACHE_VOLUME_ADDED, eventDetails);\n        })\n            .catch((error) => {\n            this._volumeCache.delete(volumeId);\n            throw error;\n        });\n    }\n    _restoreImagesFromBuffer(volume) {\n        if (!(volume instanceof ImageVolume)) {\n            console.warn('Volume is not an ImageVolume. Cannot restore images from buffer.');\n            return;\n        }\n        const scalarData = volume.getScalarData();\n        const imageCacheOffsetMap = volume.imageCacheOffsetMap;\n        if (imageCacheOffsetMap.size === 0) {\n            console.warn('No cached images to restore for this volume.');\n            return;\n        }\n        for (const [imageId, { offset }] of imageCacheOffsetMap) {\n            const image = this.getImage(imageId);\n            if (!image) {\n                console.warn(`Image with id ${imageId} not found in cache.`);\n                continue;\n            }\n            const viewPixelData = image.getPixelData();\n            const length = viewPixelData.length;\n            const pixelData = new viewPixelData.constructor(scalarData.buffer, offset, length);\n            image.getPixelData = () => pixelData;\n            if (image.imageFrame) {\n                image.imageFrame.pixelData = pixelData;\n            }\n            delete image.bufferView;\n            this.incrementImageCacheSize(image.sizeInBytes);\n        }\n        console.log(`Images restored from buffer for volume ${volume.volumeId}.`);\n    }\n}\nconst cache = new Cache();\nexport default cache;\nexport { Cache };\n//# sourceMappingURL=cache.js.map","import { addProvider } from '../metaData';\nlet state = {};\nconst metadataProvider = {\n    add: (imageId, payload) => {\n        const type = payload.type;\n        if (!state[imageId]) {\n            state[imageId] = {};\n        }\n        state[imageId][type] = JSON.parse(JSON.stringify(payload.metadata));\n    },\n    get: (type, imageId) => {\n        return state[imageId]?.[type];\n    },\n    clear: () => {\n        state = {};\n    },\n};\naddProvider(metadataProvider.get);\nexport default metadataProvider;\n//# sourceMappingURL=genericMetadataProvider.js.map","var SegmentationRepresentations;\n(function (SegmentationRepresentations) {\n    SegmentationRepresentations[\"Labelmap\"] = \"LABELMAP\";\n    SegmentationRepresentations[\"Contour\"] = \"CONTOUR\";\n    SegmentationRepresentations[\"Surface\"] = \"SURFACE\";\n})(SegmentationRepresentations || (SegmentationRepresentations = {}));\nexport default SegmentationRepresentations;\n//# sourceMappingURL=SegmentationRepresentations.js.map","function findNextLink(line, lines, contourPoints) {\n    let index = -1;\n    lines.forEach((cell, i) => {\n        if (index >= 0) {\n            return;\n        }\n        if (cell.a == line.b) {\n            index = i;\n        }\n    });\n    if (index >= 0) {\n        const nextLine = lines[index];\n        lines.splice(index, 1);\n        contourPoints.push(nextLine.b);\n        if (contourPoints[0] == nextLine.b) {\n            return {\n                remainingLines: lines,\n                contourPoints,\n                type: 'CLOSED_PLANAR',\n            };\n        }\n        return findNextLink(nextLine, lines, contourPoints);\n    }\n    return {\n        remainingLines: lines,\n        contourPoints,\n        type: 'OPEN_PLANAR',\n    };\n}\nexport function findContours(lines) {\n    if (lines.length == 0) {\n        return [];\n    }\n    const contourPoints = [];\n    const firstCell = lines.shift();\n    contourPoints.push(firstCell.a);\n    contourPoints.push(firstCell.b);\n    const result = findNextLink(firstCell, lines, contourPoints);\n    if (result.remainingLines.length == 0) {\n        return [\n            {\n                type: result.type,\n                contourPoints: result.contourPoints,\n            },\n        ];\n    }\n    else {\n        const extraContours = findContours(result.remainingLines);\n        extraContours.push({\n            type: result.type,\n            contourPoints: result.contourPoints,\n        });\n        return extraContours;\n    }\n}\nexport function findContoursFromReducedSet(lines) {\n    return findContours(lines);\n}\nexport default {\n    findContours,\n    findContoursFromReducedSet,\n};\n//# sourceMappingURL=contourFinder.js.map","function ptInArray(array, pt) {\n    let index = -1;\n    for (let i = 0; i < array.length; i++) {\n        if (isSamePoint(pt, array[i])) {\n            index = i;\n        }\n    }\n    return index;\n}\nfunction isSamePoint(ptA, ptB) {\n    if (ptA[0] == ptB[0] && ptA[1] == ptB[1] && ptA[2] == ptB[2]) {\n        return true;\n    }\n    else {\n        return false;\n    }\n}\nfunction replacePointIndexReferences(linesArray, oldIndex, newIndex) {\n    for (let i = 0; i < linesArray.length; i++) {\n        const line = linesArray[i];\n        if (line.a == oldIndex) {\n            line.a = newIndex;\n        }\n        else if (line.b == oldIndex) {\n            line.b = newIndex;\n        }\n    }\n}\nexport function removeDuplicatePoints(polyData, bypass = false) {\n    const points = polyData.getPoints();\n    const lines = polyData.getLines();\n    const pointsArray = [];\n    for (let i = 0; i < points.getNumberOfPoints(); i++) {\n        const pt = points.getPoint(i).slice();\n        pointsArray.push(pt);\n    }\n    const linesArray = [];\n    for (let i = 0; i < lines.getNumberOfCells(); i++) {\n        const cell = lines.getCell(i * 3).slice();\n        const a = cell[0];\n        const b = cell[1];\n        const line = {\n            a,\n            b,\n        };\n        linesArray.push(line);\n    }\n    if (bypass) {\n        return { points: pointsArray, lines: linesArray };\n    }\n    const newPoints = [];\n    for (let i = 0; i < pointsArray.length; i++) {\n        const pt = pointsArray[i];\n        let index = ptInArray(newPoints, pt);\n        if (index >= 0) {\n            replacePointIndexReferences(linesArray, i, index);\n        }\n        else {\n            index = newPoints.length;\n            newPoints.push(pt);\n            replacePointIndexReferences(linesArray, i, index);\n        }\n    }\n    const newLines = [];\n    linesArray.forEach((line) => {\n        if (line.a != line.b) {\n            newLines.push(line);\n        }\n    });\n    return { points: newPoints, lines: newLines };\n}\nexport default { removeDuplicatePoints };\n//# sourceMappingURL=mergePoints.js.map","const getIsPointInsidePolygon = (point, vertices) => {\n    const x = point[0];\n    const y = point[1];\n    let inside = false;\n    for (let i = 0, j = vertices.length - 1; i < vertices.length; j = i++) {\n        const xi = vertices[i][0], yi = vertices[i][1];\n        const xj = vertices[j][0], yj = vertices[j][1];\n        const intersect = yi > y != yj > y && x < ((xj - xi) * (y - yi)) / (yj - yi) + xi;\n        if (intersect) {\n            inside = !inside;\n        }\n    }\n    return inside;\n};\nfunction checkEnclosed(outerContour, innerContour, points) {\n    const vertices = [];\n    outerContour.contourPoints.forEach((point) => {\n        vertices.push([points[point][0], points[point][1]]);\n    });\n    let pointsNotEnclosed = 0;\n    innerContour.contourPoints.forEach((point) => {\n        const result = getIsPointInsidePolygon([points[point][0], points[point][1]], vertices);\n        if (!result) {\n            pointsNotEnclosed++;\n        }\n    });\n    return pointsNotEnclosed === 0;\n}\nexport function processContourHoles(contours, points, useXOR = true) {\n    const retContours = contours.filter((contour) => contour.type !== 'CLOSED_PLANAR');\n    const closedContours = contours.filter((contour) => contour.type === 'CLOSED_PLANAR');\n    const contourWithHoles = [];\n    let contourWithoutHoles = [];\n    closedContours.forEach((contour, index) => {\n        const holes = [];\n        closedContours.forEach((hContour, hIndex) => {\n            if (index != hIndex) {\n                if (checkEnclosed(contour, hContour, points)) {\n                    holes.push(hIndex);\n                }\n            }\n        });\n        if (holes.length > 0) {\n            contourWithHoles.push({\n                contour,\n                holes,\n            });\n        }\n        else {\n            contourWithoutHoles.push(index);\n        }\n    });\n    if (useXOR) {\n        contourWithHoles.forEach((contourHoleSet) => {\n            contourHoleSet.contour.type = 'CLOSEDPLANAR_XOR';\n            retContours.push(contourHoleSet.contour);\n            contourHoleSet.holes.forEach((holeIndex) => {\n                closedContours[holeIndex].type = 'CLOSEDPLANAR_XOR';\n                retContours.push(closedContours[holeIndex]);\n                contourWithoutHoles = contourWithoutHoles.filter((contourIndex) => {\n                    return contourIndex !== holeIndex;\n                });\n            });\n        });\n        contourWithoutHoles.forEach((contourIndex) => {\n            retContours.push(closedContours[contourIndex]);\n        });\n    }\n    else {\n    }\n    return retContours;\n}\nexport default { processContourHoles };\n//# sourceMappingURL=detectContourHoles.js.map","class EdgeLocator {\n  constructor() {\n    let oriented = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    this.oriented = oriented;\n    this.edgeMap = new Map();\n  }\n  initialize() {\n    this.edgeMap.clear();\n  }\n  computeEdgeKey(pointId0, pointId1) {\n    return this.oriented || pointId0 < pointId1 ?\n    // Cantor pairing function:\n    0.5 * (pointId0 * pointId1) * (pointId0 * pointId1 + 1) + pointId1 : 0.5 * (pointId1 * pointId0) * (pointId1 * pointId0 + 1) + pointId0;\n  }\n  insertUniqueEdge(pointId0, pointId1, newEdgeValue) {\n    // Generate a unique key\n    const key = this.computeEdgeKey(pointId0, pointId1);\n    let node = this.edgeMap.get(key);\n    if (!node) {\n      // Didn't find key, so add a new edge entry\n      node = {\n        key,\n        edgeId: this.edgeMap.size,\n        value: newEdgeValue\n      };\n      this.edgeMap.set(key, node);\n    }\n    return node;\n  }\n  insertEdge(pointId0, pointId1, newEdgeValue) {\n    // Generate a unique key\n    const key = this.computeEdgeKey(pointId0, pointId1);\n    const node = {\n      key,\n      edgeId: this.edgeMap.size,\n      value: newEdgeValue\n    };\n    this.edgeMap.set(key, node);\n    return node;\n  }\n  isInsertedEdge(pointId0, pointId1) {\n    const key = this.computeEdgeKey(pointId0, pointId1);\n    return this.edgeMap.get(key);\n  }\n  static getEdgePointIds(node) {\n    const n = 0.5 * (-1 + Math.sqrt(8 * node.key + 1));\n    const pointId0 = node.key - 0.5 * (n + 1) * n;\n    const pointId1 = n - pointId0;\n    return [pointId0, pointId1];\n  }\n}\nfunction newInstance() {\n  let initialValues = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return new EdgeLocator(initialValues.oriented);\n}\nvar vtkEdgeLocator = {\n  newInstance\n};\n\nexport { vtkEdgeLocator as default };\n","// ----------------------------------------------------------------------------\n// Marching squares case functions (using lines to generate the 2D tessellation).\n// For each case, a list of edge ids that form the triangles. A -1 marks the\n// end of the list of edges. Edges are taken three at a time to generate\n// triangle points.\n// ----------------------------------------------------------------------------\nconst MARCHING_SQUARES_CASES = [[-1, -1, -1, -1, -1] /* 0 */, [0, 3, -1, -1, -1] /* 1 */, [1, 0, -1, -1, -1] /* 2 */, [1, 3, -1, -1, -1] /* 3 */, [2, 1, -1, -1, -1] /* 4 */, [0, 3, 2, 1, -1] /* 5 */, [2, 0, -1, -1, -1] /* 6 */, [2, 3, -1, -1, -1] /* 7 */, [3, 2, -1, -1, -1] /* 8 */, [0, 2, -1, -1, -1] /* 9 */, [1, 0, 3, 2, -1] /* 10 */, [1, 2, -1, -1, -1] /* 11 */, [3, 1, -1, -1, -1] /* 12 */, [0, 1, -1, -1, -1] /* 13 */, [3, 0, -1, -1, -1] /* 14 */, [-1, -1, -1, -1, -1] /* 15 */];\n\nconst EDGES = [[0, 1], [1, 3], [2, 3], [0, 2]];\nfunction getCase(index) {\n  return MARCHING_SQUARES_CASES[index];\n}\n\n// Define the four edges of the pixel by the following pairs of vertices\nfunction getEdge(eid) {\n  return EDGES[eid];\n}\n\n// ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\nvar vtkCaseTable = {\n  getCase,\n  getEdge\n};\n\nexport { vtkCaseTable as default };\n","import { m as macro } from '../../macros2.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\nimport vtkEdgeLocator from '../../Common/DataModel/EdgeLocator.js';\nimport vtkCaseTable from './ImageMarchingSquares/caseTable.js';\n\nconst {\n  vtkErrorMacro,\n  vtkDebugMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// vtkImageMarchingSquares methods\n// ----------------------------------------------------------------------------\n\nfunction vtkImageMarchingSquares(publicAPI, model) {\n  /**\n   * Get the X,Y kernels based on the set slicing mode.\n   * @returns {[number, number]}\n   */\n  function getKernels() {\n    let kernelX = 0; // default K slicing mode\n    let kernelY = 1;\n    if (model.slicingMode === 1) {\n      kernelX = 0;\n      kernelY = 2;\n    } else if (model.slicingMode === 0) {\n      kernelX = 1;\n      kernelY = 2;\n    }\n    return [kernelX, kernelY];\n  }\n\n  // Set our className\n  model.classHierarchy.push('vtkImageMarchingSquares');\n\n  /**\n   * Get the list of contour values.\n   * @returns {number[]}\n   */\n  publicAPI.getContourValues = () => model.contourValues;\n\n  /**\n   * Set the list contour values.\n   * @param {number[]} cValues\n   */\n  publicAPI.setContourValues = cValues => {\n    model.contourValues = cValues;\n    publicAPI.modified();\n  };\n  const ids = [];\n  const pixelScalars = [];\n  const pixelPts = [];\n  const edgeLocator = vtkEdgeLocator.newInstance();\n\n  /**\n   * Retrieve scalars and pixel coordinates.\n   * @param {Vector3} ijk origin of the pixel\n   * @param {Vector3} dims dimensions of the image\n   * @param {TypedArray} scalars list of scalar values\n   * @param {Vector3} increments IJK slice increments\n   * @param {number} kernelX index of the X element\n   * @param {number} kernelY index of the Y element\n   */\n  publicAPI.getPixelScalars = (ijk, dims, scalars, increments, kernelX, kernelY) => {\n    const [i, j, k] = ijk;\n\n    // First get the indices for the pixel\n    ids[0] = k * dims[1] * dims[0] + j * dims[0] + i; // i, j, k\n    ids[1] = ids[0] + increments[kernelX]; // i+1, j, k\n    ids[2] = ids[0] + increments[kernelY]; // i, j+1, k\n    ids[3] = ids[2] + increments[kernelX]; // i+1, j+1, k\n\n    // Now retrieve the scalars\n    for (let ii = 0; ii < 4; ++ii) {\n      pixelScalars[ii] = scalars[ids[ii]];\n    }\n  };\n\n  /**\n   * Retrieve pixel coordinates.\n   * @param {Vector3} ijk origin of the pixel\n   * @param {Vector3} origin origin of the image\n   * @param {Vector3} spacing spacing of the image\n   * @param {number} kernelX index of the X element\n   * @param {number} kernelY index of the Y element\n   */\n  publicAPI.getPixelPoints = (ijk, origin, spacing, kernelX, kernelY) => {\n    const i = ijk[kernelX];\n    const j = ijk[kernelY];\n\n    // (i,i+1),(j,j+1),(k,k+1) - i varies fastest; then j; then k\n    pixelPts[0] = origin[kernelX] + i * spacing[kernelX]; // 0\n    pixelPts[1] = origin[kernelY] + j * spacing[kernelY];\n    pixelPts[2] = pixelPts[0] + spacing[kernelX]; // 1\n    pixelPts[3] = pixelPts[1];\n    pixelPts[4] = pixelPts[0]; // 2\n    pixelPts[5] = pixelPts[1] + spacing[kernelY];\n    pixelPts[6] = pixelPts[2]; // 3\n    pixelPts[7] = pixelPts[5];\n  };\n\n  /**\n   * Produce points and lines for the polydata.\n   * @param {number[]} cVal list of contour values\n   * @param {Vector3} ijk origin of the pixel\n   * @param {Vector3} dims dimensions of the image\n   * @param {Vector3} origin origin of the image\n   * @param {Vector3} spacing sapcing of the image\n   * @param {TypedArray} scalars list of scalar values\n   * @param {number[]} points list of points\n   * @param {number[]} lines list of lines\n   * @param {Vector3} increments IJK slice increments\n   * @param {number} kernelX index of the X element\n   * @param {number} kernelY index of the Y element\n   */\n  publicAPI.produceLines = (cVal, ijk, dims, origin, spacing, scalars, points, lines, increments, kernelX, kernelY) => {\n    const k = ijk[model.slicingMode];\n    const CASE_MASK = [1, 2, 8, 4]; // case table is actually for quad\n    const xyz = [];\n    let pId;\n    publicAPI.getPixelScalars(ijk, dims, scalars, increments, kernelX, kernelY);\n    let index = 0;\n    for (let idx = 0; idx < 4; idx++) {\n      if (pixelScalars[idx] >= cVal) {\n        index |= CASE_MASK[idx]; // eslint-disable-line no-bitwise\n      }\n    }\n\n    const pixelLines = vtkCaseTable.getCase(index);\n    if (pixelLines[0] < 0) {\n      return; // don't get the pixel coordinates, nothing to do\n    }\n\n    publicAPI.getPixelPoints(ijk, origin, spacing, kernelX, kernelY);\n    const z = origin[model.slicingMode] + k * spacing[model.slicingMode];\n    for (let idx = 0; pixelLines[idx] >= 0; idx += 2) {\n      lines.push(2);\n      for (let eid = 0; eid < 2; eid++) {\n        const edgeVerts = vtkCaseTable.getEdge(pixelLines[idx + eid]);\n        pId = undefined;\n        if (model.mergePoints) {\n          pId = edgeLocator.isInsertedEdge(ids[edgeVerts[0]], ids[edgeVerts[1]])?.value;\n        }\n        if (pId === undefined) {\n          const t = (cVal - pixelScalars[edgeVerts[0]]) / (pixelScalars[edgeVerts[1]] - pixelScalars[edgeVerts[0]]);\n          const x0 = pixelPts.slice(edgeVerts[0] * 2, (edgeVerts[0] + 1) * 2);\n          const x1 = pixelPts.slice(edgeVerts[1] * 2, (edgeVerts[1] + 1) * 2);\n          xyz[kernelX] = x0[0] + t * (x1[0] - x0[0]);\n          xyz[kernelY] = x0[1] + t * (x1[1] - x0[1]);\n          xyz[model.slicingMode] = z;\n          pId = points.length / 3;\n          points.push(xyz[0], xyz[1], xyz[2]);\n          if (model.mergePoints) {\n            edgeLocator.insertEdge(ids[edgeVerts[0]], ids[edgeVerts[1]], pId);\n          }\n        }\n        lines.push(pId);\n      }\n    }\n  };\n  publicAPI.requestData = (inData, outData) => {\n    // implement requestData\n    const input = inData[0];\n    if (!input) {\n      vtkErrorMacro('Invalid or missing input');\n      return;\n    }\n    if (model.slicingMode == null || model.slicingMode < 0 || model.slicingMode > 2) {\n      vtkErrorMacro('Invalid or missing slicing mode');\n      return;\n    }\n    console.time('msquares');\n\n    // Retrieve output and volume data\n    const origin = input.getOrigin();\n    const spacing = input.getSpacing();\n    const dims = input.getDimensions();\n    const extent = input.getExtent();\n    const increments = input.computeIncrements(extent);\n    const scalars = input.getPointData().getScalars().getData();\n    const [kernelX, kernelY] = getKernels();\n\n    // Points - dynamic array\n    const points = [];\n\n    // Cells - dynamic array\n    const lines = [];\n\n    // Ensure slice is valid\n    let k = Math.round(model.slice);\n    if (k >= dims[model.slicingMode]) {\n      k = 0;\n    }\n\n    // Loop over all contour values, and then pixels, determine case and process\n    const ijk = [0, 0, 0];\n    ijk[model.slicingMode] = k;\n    for (let cv = 0; cv < model.contourValues.length; ++cv) {\n      for (let j = 0; j < dims[kernelY] - 1; ++j) {\n        ijk[kernelY] = j;\n        for (let i = 0; i < dims[kernelX] - 1; ++i) {\n          ijk[kernelX] = i;\n          publicAPI.produceLines(model.contourValues[cv], ijk, dims, origin, spacing, scalars, points, lines, increments, kernelX, kernelY);\n        }\n      }\n      edgeLocator.initialize();\n    }\n\n    // Update output\n    const polydata = vtkPolyData.newInstance();\n    polydata.getPoints().setData(new Float32Array(points), 3);\n    polydata.getLines().setData(new Uint32Array(lines));\n    outData[0] = polydata;\n    vtkDebugMacro('Produced output');\n    console.timeEnd('msquares');\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  contourValues: [],\n  slicingMode: 2,\n  slice: 0,\n  mergePoints: false\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Make this a VTK object\n  macro.obj(publicAPI, model);\n\n  // Also make it an algorithm with one input and one output\n  macro.algo(publicAPI, model, 1, 1);\n  macro.setGet(publicAPI, model, ['slicingMode', 'slice', 'mergePoints']);\n\n  // Object specific methods\n  macro.algo(publicAPI, model, 1, 1);\n  vtkImageMarchingSquares(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkImageMarchingSquares');\n\n// ----------------------------------------------------------------------------\n\nvar vtkImageMarchingSquares$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkImageMarchingSquares$1 as default, extend, newInstance };\n","import { cache as cornerstoneCache } from '@cornerstonejs/core';\nimport vtkImageMarchingSquares from '@kitware/vtk.js/Filters/General/ImageMarchingSquares';\nimport vtkDataArray from '@kitware/vtk.js/Common/Core/DataArray';\nimport vtkImageData from '@kitware/vtk.js/Common/DataModel/ImageData';\nimport { removeDuplicatePoints } from './mergePoints';\nimport { findContoursFromReducedSet } from './contourFinder';\nimport SegmentationRepresentations from '../../enums/SegmentationRepresentations';\nconst { Labelmap } = SegmentationRepresentations;\nfunction generateContourSetsFromLabelmap({ segmentations }) {\n    const { representationData, segments = [0, 1] } = segmentations;\n    const { volumeId: segVolumeId } = representationData[Labelmap];\n    const vol = cornerstoneCache.getVolume(segVolumeId);\n    if (!vol) {\n        console.warn(`No volume found for ${segVolumeId}`);\n        return;\n    }\n    const numSlices = vol.dimensions[2];\n    const imageVol = cornerstoneCache.getVolume(vol.referencedVolumeId);\n    if (!imageVol) {\n        console.warn(`No volume found for ${vol.referencedVolumeId}`);\n        return;\n    }\n    const segData = vol.imageData.getPointData().getScalars().getData();\n    const pixelsPerSlice = vol.dimensions[0] * vol.dimensions[1];\n    for (let z = 0; z < numSlices; z++) {\n        for (let y = 0; y < vol.dimensions[1]; y++) {\n            const index = y * vol.dimensions[0] + z * pixelsPerSlice;\n            segData[index] = 0;\n            segData[index + vol.dimensions[0] - 1] = 0;\n        }\n    }\n    const ContourSets = [];\n    const { FrameOfReferenceUID } = imageVol.metadata;\n    const numSegments = segments.length;\n    for (let segIndex = 0; segIndex < numSegments; segIndex++) {\n        const segment = segments[segIndex];\n        if (!segment) {\n            continue;\n        }\n        const sliceContours = [];\n        const scalars = vtkDataArray.newInstance({\n            name: 'Scalars',\n            numberOfComponents: 1,\n            size: pixelsPerSlice * numSlices,\n            dataType: 'Uint8Array',\n        });\n        const { containedSegmentIndices } = segment;\n        for (let sliceIndex = 0; sliceIndex < numSlices; sliceIndex++) {\n            if (isSliceEmptyForSegment(sliceIndex, segData, pixelsPerSlice, segIndex)) {\n                continue;\n            }\n            const frameStart = sliceIndex * pixelsPerSlice;\n            try {\n                for (let i = 0; i < pixelsPerSlice; i++) {\n                    const value = segData[i + frameStart];\n                    if (value === segIndex || containedSegmentIndices?.has(value)) {\n                        scalars.setValue(i + frameStart, 1);\n                    }\n                    else {\n                        scalars.setValue(i, 0);\n                    }\n                }\n                const mSquares = vtkImageMarchingSquares.newInstance({\n                    slice: sliceIndex,\n                });\n                const imageDataCopy = vtkImageData.newInstance();\n                imageDataCopy.shallowCopy(vol.imageData);\n                imageDataCopy.getPointData().setScalars(scalars);\n                mSquares.setInputData(imageDataCopy);\n                const cValues = [1];\n                mSquares.setContourValues(cValues);\n                mSquares.setMergePoints(false);\n                const msOutput = mSquares.getOutputData();\n                const reducedSet = removeDuplicatePoints(msOutput);\n                if (reducedSet.points?.length) {\n                    const contours = findContoursFromReducedSet(reducedSet.lines);\n                    sliceContours.push({\n                        referencedImageId: imageVol.imageIds[sliceIndex],\n                        contours,\n                        polyData: reducedSet,\n                        FrameNumber: sliceIndex + 1,\n                        sliceIndex,\n                        FrameOfReferenceUID,\n                    });\n                }\n            }\n            catch (e) {\n                console.warn(sliceIndex);\n                console.warn(e);\n            }\n        }\n        const metadata = {\n            referencedImageId: imageVol.imageIds[0],\n            FrameOfReferenceUID,\n        };\n        const ContourSet = {\n            label: segment.label,\n            color: segment.color,\n            metadata,\n            sliceContours,\n        };\n        ContourSets.push(ContourSet);\n    }\n    return ContourSets;\n}\nfunction isSliceEmptyForSegment(sliceIndex, segData, pixelsPerSlice, segIndex) {\n    const startIdx = sliceIndex * pixelsPerSlice;\n    const endIdx = startIdx + pixelsPerSlice;\n    for (let i = startIdx; i < endIdx; i++) {\n        if (segData[i] === segIndex) {\n            return false;\n        }\n    }\n    return true;\n}\nexport { generateContourSetsFromLabelmap };\n//# sourceMappingURL=generateContourSetsFromLabelmap.js.map","class RectangleROIStartEndThreshold {\n    constructor() {\n    }\n    static getContourSequence(toolData, metadataProvider) {\n        const { data } = toolData;\n        const { projectionPoints, projectionPointsImageIds } = data.cachedStats;\n        return projectionPoints.map((point, index) => {\n            const ContourData = getPointData(point);\n            const ContourImageSequence = getContourImageSequence(projectionPointsImageIds[index], metadataProvider);\n            return {\n                NumberOfContourPoints: ContourData.length / 3,\n                ContourImageSequence,\n                ContourGeometricType: 'CLOSED_PLANAR',\n                ContourData,\n            };\n        });\n    }\n}\nRectangleROIStartEndThreshold.toolName = 'RectangleROIStartEndThreshold';\nfunction getPointData(points) {\n    const orderedPoints = [\n        ...points[0],\n        ...points[1],\n        ...points[3],\n        ...points[2],\n    ];\n    const pointsArray = orderedPoints.flat();\n    const pointsArrayWithPrecision = pointsArray.map((point) => {\n        return point.toFixed(2);\n    });\n    return pointsArrayWithPrecision;\n}\nfunction getContourImageSequence(imageId, metadataProvider) {\n    const sopCommon = metadataProvider.get('sopCommonModule', imageId);\n    return {\n        ReferencedSOPClassUID: sopCommon.sopClassUID,\n        ReferencedSOPInstanceUID: sopCommon.sopInstanceUID,\n    };\n}\nexport default RectangleROIStartEndThreshold;\n//# sourceMappingURL=RectangleROIStartEndThreshold.js.map","import RectangleROIStartEndThreshold from './RectangleROIStartEndThreshold';\nfunction validateAnnotation(annotation) {\n    if (!annotation?.data) {\n        throw new Error('Tool data is empty');\n    }\n    if (!annotation.metadata || annotation.metadata.referenceImageId) {\n        throw new Error('Tool data is not associated with any imageId');\n    }\n}\nclass AnnotationToPointData {\n    constructor() {\n    }\n    static { this.TOOL_NAMES = {}; }\n    static convert(annotation, index, metadataProvider) {\n        validateAnnotation(annotation);\n        const { toolName } = annotation.metadata;\n        const toolClass = AnnotationToPointData.TOOL_NAMES[toolName];\n        if (!toolClass) {\n            throw new Error(`Unknown tool type: ${toolName}, cannot convert to RTSSReport`);\n        }\n        const ContourSequence = toolClass.getContourSequence(annotation, metadataProvider);\n        const color = [\n            Math.floor(Math.random() * 255),\n            Math.floor(Math.random() * 255),\n            Math.floor(Math.random() * 255),\n        ];\n        return {\n            ReferencedROINumber: index + 1,\n            ROIDisplayColor: color,\n            ContourSequence,\n        };\n    }\n    static register(toolClass) {\n        AnnotationToPointData.TOOL_NAMES[toolClass.toolName] = toolClass;\n    }\n}\nAnnotationToPointData.register(RectangleROIStartEndThreshold);\nexport default AnnotationToPointData;\n//# sourceMappingURL=AnnotationToPointData.js.map","export default function getReferencedFrameOfReferenceSequence(\n    metadata,\n    metadataProvider,\n    dataset\n) {\n    const { referencedImageId: imageId, FrameOfReferenceUID } = metadata;\n    const instance = metadataProvider.get(\"instance\", imageId);\n    const { SeriesInstanceUID } = instance;\n\n    const { ReferencedSeriesSequence } = dataset;\n\n    return [\n        {\n            FrameOfReferenceUID,\n            RTReferencedStudySequence: [\n                {\n                    ReferencedSOPClassUID: dataset.SOPClassUID,\n                    ReferencedSOPInstanceUID: dataset.SOPInstanceUID,\n                    RTReferencedSeriesSequence: [\n                        {\n                            SeriesInstanceUID,\n                            ContourImageSequence: [\n                                ...ReferencedSeriesSequence[0]\n                                    .ReferencedInstanceSequence\n                            ]\n                        }\n                    ]\n                }\n            ]\n        }\n    ];\n}\n","export default function getReferencedSeriesSequence(\n    metadata,\n    _index,\n    metadataProvider,\n    DicomMetadataStore\n) {\n    // grab imageId from toolData\n    const { referencedImageId: imageId } = metadata;\n    const instance = metadataProvider.get(\"instance\", imageId);\n    const { SeriesInstanceUID, StudyInstanceUID } = instance;\n\n    const ReferencedSeriesSequence = [];\n    if (SeriesInstanceUID) {\n        const series = DicomMetadataStore.getSeries(\n            StudyInstanceUID,\n            SeriesInstanceUID\n        );\n\n        const ReferencedSeries = {\n            SeriesInstanceUID,\n            ReferencedInstanceSequence: []\n        };\n\n        series.instances.forEach(instance => {\n            const { SOPInstanceUID, SOPClassUID } = instance;\n            ReferencedSeries.ReferencedInstanceSequence.push({\n                ReferencedSOPClassUID: SOPClassUID,\n                ReferencedSOPInstanceUID: SOPInstanceUID\n            });\n        });\n\n        ReferencedSeriesSequence.push(ReferencedSeries);\n    }\n\n    return ReferencedSeriesSequence;\n}\n","export default function getStructureSetModule(contour, index) {\n    const { FrameOfReferenceUID } = contour.metadata;\n\n    return {\n        ROINumber: index + 1,\n        ROIName: contour.name || `Todo: name ${index + 1}`,\n        ROIDescription: `Todo: description ${index + 1}`,\n        ROIGenerationAlgorithm: \"Todo: algorithm\",\n        ReferencedFrameOfReferenceUID: FrameOfReferenceUID\n    };\n}\n","import { utilities } from \"@cornerstonejs/tools\";\nimport dcmjs from \"dcmjs\";\nimport getPatientModule from \"./utilities/getPatientModule\";\nimport getReferencedFrameOfReferenceSequence from \"./utilities/getReferencedFrameOfReferenceSequence\";\nimport getReferencedSeriesSequence from \"./utilities/getReferencedSeriesSequence\";\nimport getRTROIObservationsSequence from \"./utilities/getRTROIObservationsSequence\";\nimport getRTSeriesModule from \"./utilities/getRTSeriesModule\";\nimport getStructureSetModule from \"./utilities/getStructureSetModule\";\n\nconst { generateContourSetsFromLabelmap, AnnotationToPointData } =\n    utilities.contours;\nconst { DicomMetaDictionary } = dcmjs.data;\n\n/**\n * Convert handles to RTSS report containing the dcmjs dicom dataset.\n *\n * Note: current WIP and using segmentation to contour conversion,\n * routine that is not fully tested\n *\n * @param segmentations - Cornerstone tool segmentations data\n * @param metadataProvider - Metadata provider\n * @param DicomMetadataStore - metadata store instance\n * @param cs - cornerstone instance\n * @param csTools - cornerstone tool instance\n * @returns Report object containing the dataset\n */\nfunction generateRTSSFromSegmentations(\n    segmentations,\n    metadataProvider,\n    DicomMetadataStore\n) {\n    // Convert segmentations to ROIContours\n    const roiContours = [];\n\n    const contourSets = generateContourSetsFromLabelmap({\n        segmentations\n    });\n\n    contourSets.forEach((contourSet, segIndex) => {\n        // Check contour set isn't undefined\n        if (contourSet) {\n            const contourSequence = [];\n            contourSet.sliceContours.forEach(sliceContour => {\n                /**\n                 * addContour - Adds a new ROI with related contours to ROIContourSequence\n                 *\n                 * @param newContour - cornerstoneTools `ROIContour` object\n                 *\n                 * newContour = {\n                 *   name: string,\n                 *   description: string,\n                 *   contourSequence: array[contour]\n                 *   color: array[number],\n                 *   metadata: {\n                 *       referencedImageId: string,\n                 *       FrameOfReferenceUID: string\n                 *     }\n                 * }\n                 *\n                 * contour = {\n                 *   ContourImageSequence: array[\n                 *       { ReferencedSOPClassUID: string, ReferencedSOPInstanceUID: string}\n                 *     ]\n                 *   ContourGeometricType: string,\n                 *   NumberOfContourPoints: number,\n                 *   ContourData: array[number]\n                 * }\n                 */\n                // Note: change needed if support non-planar contour representation is needed\n                const sopCommon = metadataProvider.get(\n                    \"sopCommonModule\",\n                    sliceContour.referencedImageId\n                );\n                const ReferencedSOPClassUID = sopCommon.sopClassUID;\n                const ReferencedSOPInstanceUID = sopCommon.sopInstanceUID;\n                const ContourImageSequence = [\n                    { ReferencedSOPClassUID, ReferencedSOPInstanceUID } // NOTE: replace in dcmjs?\n                ];\n\n                const sliceContourPolyData = sliceContour.polyData;\n\n                sliceContour.contours.forEach((contour, index) => {\n                    const ContourGeometricType = contour.type;\n                    const NumberOfContourPoints = contour.contourPoints.length;\n                    const ContourData = [];\n\n                    contour.contourPoints.forEach(point => {\n                        const pointData = sliceContourPolyData.points[point];\n                        pointData[0] = +pointData[0].toFixed(2);\n                        pointData[1] = +pointData[1].toFixed(2);\n                        pointData[2] = +pointData[2].toFixed(2);\n                        ContourData.push(pointData[0]);\n                        ContourData.push(pointData[1]);\n                        ContourData.push(pointData[2]);\n                    });\n\n                    contourSequence.push({\n                        ContourImageSequence,\n                        ContourGeometricType,\n                        NumberOfContourPoints,\n                        ContourNumber: index + 1,\n                        ContourData\n                    });\n                });\n            });\n\n            const segLabel = contourSet.label || `Segment ${segIndex + 1}`;\n\n            const ROIContour = {\n                name: segLabel,\n                description: segLabel,\n                contourSequence,\n                color: contourSet.color,\n                metadata: contourSet.metadata\n            };\n\n            roiContours.push(ROIContour);\n        }\n    });\n\n    const rtMetadata = {\n        name: segmentations.label,\n        label: segmentations.label\n    };\n\n    const dataset = _initializeDataset(\n        rtMetadata,\n        roiContours[0].metadata,\n        metadataProvider\n    );\n\n    roiContours.forEach((contour, index) => {\n        const roiContour = {\n            ROIDisplayColor: contour.color || [255, 0, 0],\n            ContourSequence: contour.contourSequence,\n            ReferencedROINumber: index + 1\n        };\n\n        dataset.StructureSetROISequence.push(\n            getStructureSetModule(contour, index)\n        );\n\n        dataset.ROIContourSequence.push(roiContour);\n\n        // ReferencedSeriesSequence\n        dataset.ReferencedSeriesSequence = getReferencedSeriesSequence(\n            contour.metadata,\n            index,\n            metadataProvider,\n            DicomMetadataStore\n        );\n\n        // ReferencedFrameOfReferenceSequence\n        dataset.ReferencedFrameOfReferenceSequence =\n            getReferencedFrameOfReferenceSequence(\n                contour.metadata,\n                metadataProvider,\n                dataset\n            );\n    });\n\n    const fileMetaInformationVersionArray = new Uint8Array(2);\n    fileMetaInformationVersionArray[1] = 1;\n\n    const _meta = {\n        FileMetaInformationVersion: {\n            Value: [fileMetaInformationVersionArray.buffer],\n            vr: \"OB\"\n        },\n        TransferSyntaxUID: {\n            Value: [\"1.2.840.10008.1.2.1\"],\n            vr: \"UI\"\n        },\n        ImplementationClassUID: {\n            Value: [DicomMetaDictionary.uid()], // TODO: could be git hash or other valid id\n            vr: \"UI\"\n        },\n        ImplementationVersionName: {\n            Value: [\"dcmjs\"],\n            vr: \"SH\"\n        }\n    };\n\n    dataset._meta = _meta;\n\n    return dataset;\n}\n\n/**\n * Convert handles to RTSSReport report object containing the dcmjs dicom dataset.\n *\n * Note: The tool data needs to be formatted in a specific way, and currently\n * it is limited to the RectangleROIStartEndTool in the Cornerstone.\n *\n * @param annotations - Array of Cornerstone tool annotation data\n * @param metadataProvider -  Metadata provider\n * @returns Report object containing the dataset\n */\nfunction generateRTSSFromAnnotations(\n    annotations,\n    metadataProvider,\n    DicomMetadataStore\n) {\n    const rtMetadata = {\n        name: \"RTSS from Annotations\",\n        label: \"RTSS from Annotations\"\n    };\n    const dataset = _initializeDataset(\n        rtMetadata,\n        annotations[0].metadata,\n        metadataProvider\n    );\n\n    annotations.forEach((annotation, index) => {\n        const ContourSequence = AnnotationToPointData.convert(\n            annotation,\n            index,\n            metadataProvider\n        );\n\n        dataset.StructureSetROISequence.push(\n            getStructureSetModule(annotation, index)\n        );\n\n        dataset.ROIContourSequence.push(ContourSequence);\n        dataset.RTROIObservationsSequence.push(\n            getRTROIObservationsSequence(annotation, index)\n        );\n\n        // ReferencedSeriesSequence\n        // Todo: handle more than one series\n        dataset.ReferencedSeriesSequence = getReferencedSeriesSequence(\n            annotation.metadata,\n            index,\n            metadataProvider,\n            DicomMetadataStore\n        );\n\n        // ReferencedFrameOfReferenceSequence\n        dataset.ReferencedFrameOfReferenceSequence =\n            getReferencedFrameOfReferenceSequence(\n                annotation.metadata,\n                metadataProvider,\n                dataset\n            );\n    });\n\n    const fileMetaInformationVersionArray = new Uint8Array(2);\n    fileMetaInformationVersionArray[1] = 1;\n\n    const _meta = {\n        FileMetaInformationVersion: {\n            Value: [fileMetaInformationVersionArray.buffer],\n            vr: \"OB\"\n        },\n        TransferSyntaxUID: {\n            Value: [\"1.2.840.10008.1.2.1\"],\n            vr: \"UI\"\n        },\n        ImplementationClassUID: {\n            Value: [DicomMetaDictionary.uid()], // TODO: could be git hash or other valid id\n            vr: \"UI\"\n        },\n        ImplementationVersionName: {\n            Value: [\"dcmjs\"],\n            vr: \"SH\"\n        }\n    };\n\n    dataset._meta = _meta;\n\n    return dataset;\n}\n\n// /**\n//  * Generate Cornerstone tool state from dataset\n//  * @param {object} dataset dataset\n//  * @param {object} hooks\n//  * @param {function} hooks.getToolClass Function to map dataset to a tool class\n//  * @returns\n//  */\n// //static generateToolState(_dataset, _hooks = {}) {\n// function generateToolState() {\n//     // Todo\n//     console.warn(\"RTSS.generateToolState not implemented\");\n// }\n\nfunction _initializeDataset(rtMetadata, imgMetadata, metadataProvider) {\n    const rtSOPInstanceUID = DicomMetaDictionary.uid();\n\n    // get the first annotation data\n    const { referencedImageId: imageId, FrameOfReferenceUID } = imgMetadata;\n\n    const { studyInstanceUID } = metadataProvider.get(\n        \"generalSeriesModule\",\n        imageId\n    );\n\n    const patientModule = getPatientModule(imageId, metadataProvider);\n    const rtSeriesModule = getRTSeriesModule(DicomMetaDictionary);\n\n    return {\n        StructureSetROISequence: [],\n        ROIContourSequence: [],\n        RTROIObservationsSequence: [],\n        ReferencedSeriesSequence: [],\n        ReferencedFrameOfReferenceSequence: [],\n        ...patientModule,\n        ...rtSeriesModule,\n        StudyInstanceUID: studyInstanceUID,\n        SOPClassUID: \"1.2.840.10008.5.1.4.1.1.481.3\", // RT Structure Set Storage\n        SOPInstanceUID: rtSOPInstanceUID,\n        Manufacturer: \"dcmjs\",\n        Modality: \"RTSTRUCT\",\n        FrameOfReferenceUID,\n        PositionReferenceIndicator: \"\",\n        StructureSetLabel: rtMetadata.label || \"\",\n        StructureSetName: rtMetadata.name || \"\",\n        ReferringPhysicianName: \"\",\n        OperatorsName: \"\",\n        StructureSetDate: DicomMetaDictionary.date(),\n        StructureSetTime: DicomMetaDictionary.time(),\n        _meta: null\n    };\n}\n\nexport { generateRTSSFromSegmentations, generateRTSSFromAnnotations };\n","export default function getPatientModule(imageId, metadataProvider) {\n    const generalSeriesModule = metadataProvider.get(\n        \"generalSeriesModule\",\n        imageId\n    );\n    const generalStudyModule = metadataProvider.get(\n        \"generalStudyModule\",\n        imageId\n    );\n    const patientStudyModule = metadataProvider.get(\n        \"patientStudyModule\",\n        imageId\n    );\n    const patientModule = metadataProvider.get(\"patientModule\", imageId);\n    const patientDemographicModule = metadataProvider.get(\n        \"patientDemographicModule\",\n        imageId\n    );\n\n    return {\n        Modality: generalSeriesModule.modality,\n        PatientID: patientModule.patientId,\n        PatientName: patientModule.patientName,\n        PatientBirthDate: \"\",\n        PatientAge: patientStudyModule.patientAge,\n        PatientSex: patientDemographicModule.patientSex,\n        PatientWeight: patientStudyModule.patientWeight,\n        StudyDate: generalStudyModule.studyDate,\n        StudyTime: generalStudyModule.studyTime,\n        StudyID: \"ToDo\",\n        AccessionNumber: generalStudyModule.accessionNumber\n    };\n}\n","export default function getRTSeriesModule(DicomMetaDictionary) {\n    return {\n        SeriesInstanceUID: DicomMetaDictionary.uid(), // generate a new series instance uid\n        SeriesNumber: \"99\" // Todo:: what should be the series number?\n    };\n}\n","import { utilities } from \"@cornerstonejs/tools\";\nimport {\n    generateRTSSFromAnnotations,\n    generateRTSSFromSegmentations\n} from \"./RTSS\";\n\nconst { generateContourSetsFromLabelmap } = utilities.contours;\n\nexport {\n    generateContourSetsFromLabelmap,\n    generateRTSSFromAnnotations,\n    generateRTSSFromSegmentations\n};\n","export default function getRTROIObservationsSequence(toolData, index) {\n    return {\n        ObservationNumber: index + 1,\n        ReferencedROINumber: index + 1,\n        RTROIInterpretedType: \"Todo: type\",\n        ROIInterpreter: \"Todo: interpreter\"\n    };\n}\n","import MeasurementReport from \"./MeasurementReport\";\nimport CodeScheme from \"./CodingScheme\";\nimport CORNERSTONE_3D_TAG from \"./cornerstone3DTag\";\n\nimport ArrowAnnotate from \"./ArrowAnnotate\";\nimport Bidirectional from \"./Bidirectional\";\nimport Angle from \"./Angle\";\nimport CobbAngle from \"./CobbAngle\";\nimport CircleROI from \"./CircleROI\";\nimport EllipticalROI from \"./EllipticalROI\";\nimport RectangleROI from \"./RectangleROI\";\nimport Length from \"./Length\";\nimport PlanarFreehandROI from \"./PlanarFreehandROI\";\nimport Probe from \"./Probe\";\n\nimport * as Segmentation from \"./Segmentation\";\nimport * as RTSS from \"./RTStruct\";\n\nconst Cornerstone3DSR = {\n    Bidirectional,\n    CobbAngle,\n    Angle,\n    Length,\n    CircleROI,\n    EllipticalROI,\n    RectangleROI,\n    ArrowAnnotate,\n    Probe,\n    PlanarFreehandROI,\n    MeasurementReport,\n    CodeScheme,\n    CORNERSTONE_3D_TAG\n};\n\nconst Cornerstone3DSEG = {\n    Segmentation\n};\n\nconst Cornerstone3DRT = {\n    RTSS\n};\n\nexport { Cornerstone3DSR, Cornerstone3DSEG, Cornerstone3DRT };\n","import { data } from \"dcmjs\";\n\nconst { Colors, BitArray } = data;\n\n// TODO: Is there a better name for this? RGBAInt?\n// Should we move it to Colors.js\nfunction dicomlab2RGBA(cielab) {\n    const rgba = Colors.dicomlab2RGB(cielab).map(x => Math.round(x * 255));\n    rgba.push(255);\n\n    return rgba;\n}\n\n// TODO: Copied these functions in from VTK Math so we don't need a dependency.\n// I guess we should put them somewhere\n// https://github.com/Kitware/vtk-js/blob/master/Sources/Common/Core/Math/index.js\nfunction cross(x, y, out) {\n    const Zx = x[1] * y[2] - x[2] * y[1];\n    const Zy = x[2] * y[0] - x[0] * y[2];\n    const Zz = x[0] * y[1] - x[1] * y[0];\n    out[0] = Zx;\n    out[1] = Zy;\n    out[2] = Zz;\n}\n\nfunction norm(x, n = 3) {\n    switch (n) {\n        case 1:\n            return Math.abs(x);\n        case 2:\n            return Math.sqrt(x[0] * x[0] + x[1] * x[1]);\n        case 3:\n            return Math.sqrt(x[0] * x[0] + x[1] * x[1] + x[2] * x[2]);\n        default: {\n            let sum = 0;\n            for (let i = 0; i < n; i++) {\n                sum += x[i] * x[i];\n            }\n            return Math.sqrt(sum);\n        }\n    }\n}\n\nfunction normalize(x) {\n    const den = norm(x);\n    if (den !== 0.0) {\n        x[0] /= den;\n        x[1] /= den;\n        x[2] /= den;\n    }\n    return den;\n}\n\nfunction subtract(a, b, out) {\n    out[0] = a[0] - b[0];\n    out[1] = a[1] - b[1];\n    out[2] = a[2] - b[2];\n}\n\n// TODO: This is a useful utility on its own. We should move it somewhere?\n// dcmjs.adapters.vtk.Multiframe? dcmjs.utils?\nfunction geometryFromFunctionalGroups(dataset, PerFrameFunctionalGroups) {\n    const geometry = {};\n    const pixelMeasures =\n        dataset.SharedFunctionalGroupsSequence.PixelMeasuresSequence;\n    const planeOrientation =\n        dataset.SharedFunctionalGroupsSequence.PlaneOrientationSequence;\n\n    // Find the origin of the volume from the PerFrameFunctionalGroups' ImagePositionPatient values\n    //\n    // TODO: assumes sorted frames. This should read the ImagePositionPatient from each frame and\n    // sort them to obtain the first and last position along the acquisition axis.\n    const firstFunctionalGroup = PerFrameFunctionalGroups[0];\n    const lastFunctionalGroup =\n        PerFrameFunctionalGroups[PerFrameFunctionalGroups.length - 1];\n    const firstPosition =\n        firstFunctionalGroup.PlanePositionSequence.ImagePositionPatient.map(\n            Number\n        );\n    const lastPosition =\n        lastFunctionalGroup.PlanePositionSequence.ImagePositionPatient.map(\n            Number\n        );\n\n    geometry.origin = firstPosition;\n\n    // NB: DICOM PixelSpacing is defined as Row then Column,\n    // unlike ImageOrientationPatient\n    geometry.spacing = [\n        pixelMeasures.PixelSpacing[1],\n        pixelMeasures.PixelSpacing[0],\n        pixelMeasures.SpacingBetweenSlices\n    ].map(Number);\n\n    geometry.dimensions = [\n        dataset.Columns,\n        dataset.Rows,\n        PerFrameFunctionalGroups.length\n    ].map(Number);\n\n    const orientation = planeOrientation.ImageOrientationPatient.map(Number);\n    const columnStepToPatient = orientation.slice(0, 3);\n    const rowStepToPatient = orientation.slice(3, 6);\n\n    geometry.planeNormal = [];\n\n    cross(columnStepToPatient, rowStepToPatient, geometry.planeNormal);\n\n    geometry.sliceStep = [];\n    subtract(lastPosition, firstPosition, geometry.sliceStep);\n    normalize(geometry.sliceStep);\n    geometry.direction = columnStepToPatient\n        .concat(rowStepToPatient)\n        .concat(geometry.sliceStep);\n\n    return geometry;\n}\n\nexport default class Segmentation {\n    constructor() {}\n\n    /**\n     * Produces an array of Segments from an input DICOM Segmentation dataset\n     *\n     * Segments are returned with Geometry values that can be used to create\n     * VTK Image Data objects.\n     *\n     * @example Example usage to create VTK Volume actors from each segment:\n     *\n     * const actors = [];\n     * const segments = generateToolState(dataset);\n     * segments.forEach(segment => {\n     *   // now make actors using the segment information\n     *   const scalarArray = vtk.Common.Core.vtkDataArray.newInstance({\n     *        name: \"Scalars\",\n     *        numberOfComponents: 1,\n     *        values: segment.pixelData,\n     *    });\n     *\n     *    const imageData = vtk.Common.DataModel.vtkImageData.newInstance();\n     *    imageData.getPointData().setScalars(scalarArray);\n     *    imageData.setDimensions(geometry.dimensions);\n     *    imageData.setSpacing(geometry.spacing);\n     *    imageData.setOrigin(geometry.origin);\n     *    imageData.setDirection(geometry.direction);\n     *\n     *    const mapper = vtk.Rendering.Core.vtkVolumeMapper.newInstance();\n     *    mapper.setInputData(imageData);\n     *    mapper.setSampleDistance(2.);\n     *\n     *    const actor = vtk.Rendering.Core.vtkVolume.newInstance();\n     *    actor.setMapper(mapper);\n     *\n     *    actors.push(actor);\n     * });\n     *\n     * @param dataset\n     * @return {{}}\n     */\n    static generateSegments(dataset) {\n        if (dataset.SegmentSequence.constructor.name !== \"Array\") {\n            dataset.SegmentSequence = [dataset.SegmentSequence];\n        }\n\n        dataset.SegmentSequence.forEach(segment => {\n            // TODO: other interesting fields could be extracted from the segment\n            // TODO: Read SegmentsOverlay field\n            // http://dicom.nema.org/medical/dicom/current/output/chtml/part03/sect_C.8.20.2.html\n\n            // TODO: Looks like vtkColor only wants RGB in 0-1 values.\n            // Why was this example converting to RGBA with 0-255 values?\n            const color = dicomlab2RGBA(segment.RecommendedDisplayCIELabValue);\n\n            segments[segment.SegmentNumber] = {\n                color,\n                functionalGroups: [],\n                offset: null,\n                size: null,\n                pixelData: null\n            };\n        });\n\n        // make a list of functional groups per segment\n        dataset.PerFrameFunctionalGroupsSequence.forEach(functionalGroup => {\n            const segmentNumber =\n                functionalGroup.SegmentIdentificationSequence\n                    .ReferencedSegmentNumber;\n\n            segments[segmentNumber].functionalGroups.push(functionalGroup);\n        });\n\n        // determine per-segment index into the pixel data\n        // TODO: only handles one-bit-per pixel\n        const frameSize = Math.ceil((dataset.Rows * dataset.Columns) / 8);\n        let nextOffset = 0;\n\n        Object.keys(segments).forEach(segmentNumber => {\n            const segment = segments[segmentNumber];\n\n            segment.numberOfFrames = segment.functionalGroups.length;\n            segment.size = segment.numberOfFrames * frameSize;\n            segment.offset = nextOffset;\n\n            nextOffset = segment.offset + segment.size;\n\n            const packedSegment = dataset.PixelData.slice(\n                segment.offset,\n                nextOffset\n            );\n\n            segment.pixelData = BitArray.unpack(packedSegment);\n\n            const geometry = geometryFromFunctionalGroups(\n                dataset,\n                segment.functionalGroups\n            );\n\n            segment.geometry = geometry;\n        });\n\n        return segments;\n    }\n}\n","import { CornerstoneSR, CornerstoneSEG } from \"./Cornerstone\";\nimport {\n    Cornerstone3DSR,\n    Cornerstone3DSEG,\n    Cornerstone3DRT\n} from \"./Cornerstone3D\";\nimport { VTKjsSEG } from \"./VTKjs\";\nimport * as Enums from \"./enums\";\nimport * as helpers from \"./helpers\";\n\nconst adaptersSR = {\n    Cornerstone: CornerstoneSR,\n    Cornerstone3D: Cornerstone3DSR\n};\n\nconst adaptersSEG = {\n    Cornerstone: CornerstoneSEG,\n    Cornerstone3D: Cornerstone3DSEG,\n    VTKjs: VTKjsSEG\n};\n\nconst adaptersRT = {\n    Cornerstone3D: Cornerstone3DRT\n};\n\nexport { adaptersSR, adaptersSEG, adaptersRT, Enums, helpers };\n","import Segmentation from \"./Segmentation\";\n\nconst VTKjsSEG = {\n    Segmentation\n};\n\nexport { VTKjsSEG };\n","\"use strict\"\n\nfunction iota(n) {\n  var result = new Array(n)\n  for(var i=0; i<n; ++i) {\n    result[i] = i\n  }\n  return result\n}\n\nmodule.exports = iota","/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n\nmodule.exports = function isBuffer (obj) {\n  return obj != null && obj.constructor != null &&\n    typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n","var iota = require(\"iota-array\")\nvar isBuffer = require(\"is-buffer\")\n\nvar hasTypedArrays  = ((typeof Float64Array) !== \"undefined\")\n\nfunction compare1st(a, b) {\n  return a[0] - b[0]\n}\n\nfunction order() {\n  var stride = this.stride\n  var terms = new Array(stride.length)\n  var i\n  for(i=0; i<terms.length; ++i) {\n    terms[i] = [Math.abs(stride[i]), i]\n  }\n  terms.sort(compare1st)\n  var result = new Array(terms.length)\n  for(i=0; i<result.length; ++i) {\n    result[i] = terms[i][1]\n  }\n  return result\n}\n\nfunction compileConstructor(dtype, dimension) {\n  var className = [\"View\", dimension, \"d\", dtype].join(\"\")\n  if(dimension < 0) {\n    className = \"View_Nil\" + dtype\n  }\n  var useGetters = (dtype === \"generic\")\n\n  if(dimension === -1) {\n    //Special case for trivial arrays\n    var code =\n      \"function \"+className+\"(a){this.data=a;};\\\nvar proto=\"+className+\".prototype;\\\nproto.dtype='\"+dtype+\"';\\\nproto.index=function(){return -1};\\\nproto.size=0;\\\nproto.dimension=-1;\\\nproto.shape=proto.stride=proto.order=[];\\\nproto.lo=proto.hi=proto.transpose=proto.step=\\\nfunction(){return new \"+className+\"(this.data);};\\\nproto.get=proto.set=function(){};\\\nproto.pick=function(){return null};\\\nreturn function construct_\"+className+\"(a){return new \"+className+\"(a);}\"\n    var procedure = new Function(code)\n    return procedure()\n  } else if(dimension === 0) {\n    //Special case for 0d arrays\n    var code =\n      \"function \"+className+\"(a,d) {\\\nthis.data = a;\\\nthis.offset = d\\\n};\\\nvar proto=\"+className+\".prototype;\\\nproto.dtype='\"+dtype+\"';\\\nproto.index=function(){return this.offset};\\\nproto.dimension=0;\\\nproto.size=1;\\\nproto.shape=\\\nproto.stride=\\\nproto.order=[];\\\nproto.lo=\\\nproto.hi=\\\nproto.transpose=\\\nproto.step=function \"+className+\"_copy() {\\\nreturn new \"+className+\"(this.data,this.offset)\\\n};\\\nproto.pick=function \"+className+\"_pick(){\\\nreturn TrivialArray(this.data);\\\n};\\\nproto.valueOf=proto.get=function \"+className+\"_get(){\\\nreturn \"+(useGetters ? \"this.data.get(this.offset)\" : \"this.data[this.offset]\")+\n\"};\\\nproto.set=function \"+className+\"_set(v){\\\nreturn \"+(useGetters ? \"this.data.set(this.offset,v)\" : \"this.data[this.offset]=v\")+\"\\\n};\\\nreturn function construct_\"+className+\"(a,b,c,d){return new \"+className+\"(a,d)}\"\n    var procedure = new Function(\"TrivialArray\", code)\n    return procedure(CACHED_CONSTRUCTORS[dtype][0])\n  }\n\n  var code = [\"'use strict'\"]\n\n  //Create constructor for view\n  var indices = iota(dimension)\n  var args = indices.map(function(i) { return \"i\"+i })\n  var index_str = \"this.offset+\" + indices.map(function(i) {\n        return \"this.stride[\" + i + \"]*i\" + i\n      }).join(\"+\")\n  var shapeArg = indices.map(function(i) {\n      return \"b\"+i\n    }).join(\",\")\n  var strideArg = indices.map(function(i) {\n      return \"c\"+i\n    }).join(\",\")\n  code.push(\n    \"function \"+className+\"(a,\" + shapeArg + \",\" + strideArg + \",d){this.data=a\",\n      \"this.shape=[\" + shapeArg + \"]\",\n      \"this.stride=[\" + strideArg + \"]\",\n      \"this.offset=d|0}\",\n    \"var proto=\"+className+\".prototype\",\n    \"proto.dtype='\"+dtype+\"'\",\n    \"proto.dimension=\"+dimension)\n\n  //view.size:\n  code.push(\"Object.defineProperty(proto,'size',{get:function \"+className+\"_size(){\\\nreturn \"+indices.map(function(i) { return \"this.shape[\"+i+\"]\" }).join(\"*\"),\n\"}})\")\n\n  //view.order:\n  if(dimension === 1) {\n    code.push(\"proto.order=[0]\")\n  } else {\n    code.push(\"Object.defineProperty(proto,'order',{get:\")\n    if(dimension < 4) {\n      code.push(\"function \"+className+\"_order(){\")\n      if(dimension === 2) {\n        code.push(\"return (Math.abs(this.stride[0])>Math.abs(this.stride[1]))?[1,0]:[0,1]}})\")\n      } else if(dimension === 3) {\n        code.push(\n\"var s0=Math.abs(this.stride[0]),s1=Math.abs(this.stride[1]),s2=Math.abs(this.stride[2]);\\\nif(s0>s1){\\\nif(s1>s2){\\\nreturn [2,1,0];\\\n}else if(s0>s2){\\\nreturn [1,2,0];\\\n}else{\\\nreturn [1,0,2];\\\n}\\\n}else if(s0>s2){\\\nreturn [2,0,1];\\\n}else if(s2>s1){\\\nreturn [0,1,2];\\\n}else{\\\nreturn [0,2,1];\\\n}}})\")\n      }\n    } else {\n      code.push(\"ORDER})\")\n    }\n  }\n\n  //view.set(i0, ..., v):\n  code.push(\n\"proto.set=function \"+className+\"_set(\"+args.join(\",\")+\",v){\")\n  if(useGetters) {\n    code.push(\"return this.data.set(\"+index_str+\",v)}\")\n  } else {\n    code.push(\"return this.data[\"+index_str+\"]=v}\")\n  }\n\n  //view.get(i0, ...):\n  code.push(\"proto.get=function \"+className+\"_get(\"+args.join(\",\")+\"){\")\n  if(useGetters) {\n    code.push(\"return this.data.get(\"+index_str+\")}\")\n  } else {\n    code.push(\"return this.data[\"+index_str+\"]}\")\n  }\n\n  //view.index:\n  code.push(\n    \"proto.index=function \"+className+\"_index(\", args.join(), \"){return \"+index_str+\"}\")\n\n  //view.hi():\n  code.push(\"proto.hi=function \"+className+\"_hi(\"+args.join(\",\")+\"){return new \"+className+\"(this.data,\"+\n    indices.map(function(i) {\n      return [\"(typeof i\",i,\"!=='number'||i\",i,\"<0)?this.shape[\", i, \"]:i\", i,\"|0\"].join(\"\")\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"this.stride[\"+i + \"]\"\n    }).join(\",\")+\",this.offset)}\")\n\n  //view.lo():\n  var a_vars = indices.map(function(i) { return \"a\"+i+\"=this.shape[\"+i+\"]\" })\n  var c_vars = indices.map(function(i) { return \"c\"+i+\"=this.stride[\"+i+\"]\" })\n  code.push(\"proto.lo=function \"+className+\"_lo(\"+args.join(\",\")+\"){var b=this.offset,d=0,\"+a_vars.join(\",\")+\",\"+c_vars.join(\",\"))\n  for(var i=0; i<dimension; ++i) {\n    code.push(\n\"if(typeof i\"+i+\"==='number'&&i\"+i+\">=0){\\\nd=i\"+i+\"|0;\\\nb+=c\"+i+\"*d;\\\na\"+i+\"-=d}\")\n  }\n  code.push(\"return new \"+className+\"(this.data,\"+\n    indices.map(function(i) {\n      return \"a\"+i\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"c\"+i\n    }).join(\",\")+\",b)}\")\n\n  //view.step():\n  code.push(\"proto.step=function \"+className+\"_step(\"+args.join(\",\")+\"){var \"+\n    indices.map(function(i) {\n      return \"a\"+i+\"=this.shape[\"+i+\"]\"\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"b\"+i+\"=this.stride[\"+i+\"]\"\n    }).join(\",\")+\",c=this.offset,d=0,ceil=Math.ceil\")\n  for(var i=0; i<dimension; ++i) {\n    code.push(\n\"if(typeof i\"+i+\"==='number'){\\\nd=i\"+i+\"|0;\\\nif(d<0){\\\nc+=b\"+i+\"*(a\"+i+\"-1);\\\na\"+i+\"=ceil(-a\"+i+\"/d)\\\n}else{\\\na\"+i+\"=ceil(a\"+i+\"/d)\\\n}\\\nb\"+i+\"*=d\\\n}\")\n  }\n  code.push(\"return new \"+className+\"(this.data,\"+\n    indices.map(function(i) {\n      return \"a\" + i\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"b\" + i\n    }).join(\",\")+\",c)}\")\n\n  //view.transpose():\n  var tShape = new Array(dimension)\n  var tStride = new Array(dimension)\n  for(var i=0; i<dimension; ++i) {\n    tShape[i] = \"a[i\"+i+\"]\"\n    tStride[i] = \"b[i\"+i+\"]\"\n  }\n  code.push(\"proto.transpose=function \"+className+\"_transpose(\"+args+\"){\"+\n    args.map(function(n,idx) { return n + \"=(\" + n + \"===undefined?\" + idx + \":\" + n + \"|0)\"}).join(\";\"),\n    \"var a=this.shape,b=this.stride;return new \"+className+\"(this.data,\"+tShape.join(\",\")+\",\"+tStride.join(\",\")+\",this.offset)}\")\n\n  //view.pick():\n  code.push(\"proto.pick=function \"+className+\"_pick(\"+args+\"){var a=[],b=[],c=this.offset\")\n  for(var i=0; i<dimension; ++i) {\n    code.push(\"if(typeof i\"+i+\"==='number'&&i\"+i+\">=0){c=(c+this.stride[\"+i+\"]*i\"+i+\")|0}else{a.push(this.shape[\"+i+\"]);b.push(this.stride[\"+i+\"])}\")\n  }\n  code.push(\"var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}\")\n\n  //Add return statement\n  code.push(\"return function construct_\"+className+\"(data,shape,stride,offset){return new \"+className+\"(data,\"+\n    indices.map(function(i) {\n      return \"shape[\"+i+\"]\"\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"stride[\"+i+\"]\"\n    }).join(\",\")+\",offset)}\")\n\n  //Compile procedure\n  var procedure = new Function(\"CTOR_LIST\", \"ORDER\", code.join(\"\\n\"))\n  return procedure(CACHED_CONSTRUCTORS[dtype], order)\n}\n\nfunction arrayDType(data) {\n  if(isBuffer(data)) {\n    return \"buffer\"\n  }\n  if(hasTypedArrays) {\n    switch(Object.prototype.toString.call(data)) {\n      case \"[object Float64Array]\":\n        return \"float64\"\n      case \"[object Float32Array]\":\n        return \"float32\"\n      case \"[object Int8Array]\":\n        return \"int8\"\n      case \"[object Int16Array]\":\n        return \"int16\"\n      case \"[object Int32Array]\":\n        return \"int32\"\n      case \"[object Uint8Array]\":\n        return \"uint8\"\n      case \"[object Uint16Array]\":\n        return \"uint16\"\n      case \"[object Uint32Array]\":\n        return \"uint32\"\n      case \"[object Uint8ClampedArray]\":\n        return \"uint8_clamped\"\n      case \"[object BigInt64Array]\":\n        return \"bigint64\"\n      case \"[object BigUint64Array]\":\n        return \"biguint64\"\n    }\n  }\n  if(Array.isArray(data)) {\n    return \"array\"\n  }\n  return \"generic\"\n}\n\nvar CACHED_CONSTRUCTORS = {\n  \"float32\":[],\n  \"float64\":[],\n  \"int8\":[],\n  \"int16\":[],\n  \"int32\":[],\n  \"uint8\":[],\n  \"uint16\":[],\n  \"uint32\":[],\n  \"array\":[],\n  \"uint8_clamped\":[],\n  \"bigint64\": [],\n  \"biguint64\": [],\n  \"buffer\":[],\n  \"generic\":[]\n}\n\n;(function() {\n  for(var id in CACHED_CONSTRUCTORS) {\n    CACHED_CONSTRUCTORS[id].push(compileConstructor(id, -1))\n  }\n});\n\nfunction wrappedNDArrayCtor(data, shape, stride, offset) {\n  if(data === undefined) {\n    var ctor = CACHED_CONSTRUCTORS.array[0]\n    return ctor([])\n  } else if(typeof data === \"number\") {\n    data = [data]\n  }\n  if(shape === undefined) {\n    shape = [ data.length ]\n  }\n  var d = shape.length\n  if(stride === undefined) {\n    stride = new Array(d)\n    for(var i=d-1, sz=1; i>=0; --i) {\n      stride[i] = sz\n      sz *= shape[i]\n    }\n  }\n  if(offset === undefined) {\n    offset = 0\n    for(var i=0; i<d; ++i) {\n      if(stride[i] < 0) {\n        offset -= (shape[i]-1)*stride[i]\n      }\n    }\n  }\n  var dtype = arrayDType(data)\n  var ctor_list = CACHED_CONSTRUCTORS[dtype]\n  while(ctor_list.length <= d+1) {\n    ctor_list.push(compileConstructor(dtype, ctor_list.length-1))\n  }\n  var ctor = ctor_list[d+1]\n  return ctor(data, shape, stride, offset)\n}\n\nmodule.exports = wrappedNDArrayCtor\n"],"names":["toArray","x","Array","isArray","codeMeaningEquals","codeMeaningName","contentItem","ConceptNameCodeSequence","CodeMeaning","datasetToDict","bufferOrDataset","filename","blob","ArrayBuffer","Blob","type","_meta","Error","buffer","from","write","link","document","createElement","href","window","URL","createObjectURL","download","click","graphicType","GraphicType","TID1500","utilities","addAccessors","StructuredReport","derivations","Normalizer","normalizers","TID1500MeasurementReport","TID1501MeasurementGroup","DicomMetaDictionary","data","FINDING","CodingSchemeDesignator","CodeValue","FINDING_SITE","FINDING_SITE_OLD","codeValueMatch","group","code","oldCode","MeasurementReport","_classCallCheck","_createClass","key","value","MeasurementGroup","ContentSequence","contentSequenceArr","findingGroup","find","findingSiteGroups","filter","NUMGroup","ValueType","SCOORDGroup","ReferencedSOPSequence","ReferencedSOPInstanceUID","ReferencedFrameNumber","defaultState","sopInstanceUid","frameIndex","complete","finding","ConceptCodeSequence","undefined","findingSites","map","fsg","description","findingSite","location","toolState","metadataProvider","options","allMeasurementGroups","firstImageId","Object","keys","generalSeriesModule","get","studyInstanceUID","seriesInstanceUID","forEach","imageId","sopCommonModule","frameNumber","toolData","toolTypes","ReferencedSOPClassUID","sopClassUID","sopInstanceUID","isMultiframeSOPClassUID","measurementGroups","toolType","toolTypeData","toolClass","CORNERSTONE_TOOL_CLASSES_BY_TOOL_TYPE","length","Measurements","tool","args","getTID300RepresentationArguments","TID300Representation","getTID300ContentItem","getMeasurementGroup","push","concat","TID1501MeasurementGroups","fileMetaInformationVersionArray","Uint8Array","derivationSourceDataset","StudyInstanceUID","SeriesInstanceUID","FileMetaInformationVersion","Value","vr","TransferSyntaxUID","ImplementationClassUID","uid","ImplementationVersionName","_vrMap","PixelData","report","dataset","assign","hooks","arguments","ContentTemplateSequence","TemplateIdentifier","imagingMeasurementContent","measurementData","cornerstoneToolClasses","CORNERSTONE_TOOL_CLASSES_BY_UTILITY_TYPE","registeredToolClasses","measurementGroup","TrackingIdentifierValue","TextValue","getToolClass","tc","isValidCornerstoneTrackingIdentifier","measurement","getMeasurementData","console","log","utilityToolType","MEASUREMENT_BY_TOOLTYPE","TID300Length","TID300","Length","LENGTH","_MeasurementReport$ge","getSetupMeasurementData","state","_objectSpread","MeasuredValueSequence","NumericValue","handles","start","end","textBox","hasMoved","movesIndependently","drawnIndependently","allowedOutsideImage","hasBoundingBox","_SCOORDGroup$GraphicD","_slicedToArray","GraphicData","y","point1","point2","distance","trackingIdentifierTextValue","TrackingIdentifier","includes","_TrackingIdentifier$s2","split","cornerstone4Tag","CORNERSTONE_4_TAG","registerTool","TID300Polyline","Polyline","FreehandRoi","points","active","cachedStats","area","color","invalidated","i","_tool$cachedStats","_cachedStats$area","_cachedStats$perimete","perimeter","TID300Bidirectional","Bidirectional","BIDIRECTIONAL","longAxisNUMGroup","longAxisSCOORDGroup","shortAxisNUMGroup","shortAxisSCOORDGroup","longestDiameter","String","shortestDiameter","bottomRight","Math","max","highlight","index","perpendicularStart","perpendicularEnd","isCreating","toolName","visible","_tool$handles","longAxis","shortAxis","longAxisLength","shortAxisLength","TID300Ellipse","Ellipse","ELLIPTICALROI","EllipticalRoi","majorAxis","minorAxis","minorAxisLength","sqrt","pow","minorAxisDirection","halfMinorAxisLength","corner1","corner2","initialRotation","halfXLength","abs","halfYLength","center","TID300Circle","Circle","CIRCLEROI","CircleRoi","radius","PI","TID300Point","Point","ARROW_ANNOTATE","CORNERSTONEFREETEXT","ArrowAnnotate","text","TID300RepresentationArguments","TID300CobbAngle","CobbAngle","COBB_ANGLE","rAngle","start2","end2","point3","point4","TID300Angle","Angle","ANGLE","middle","RectangleRoi","_utilities$orientatio","orientation","rotateDirectionCosinesInPlane","flipIOP","flipImageOrientationPatient","flipMatrix2D","rotateMatrix902D","datasetToBlob","BitArray","DicomMessage","SegmentationDerivation","Segmentation","generateSegmentation","images","brushData","includeSliceSpacing","segments","image0","dims","columns","rows","z","xy","_getSegCount","seg","isMultiframe","datasets","arrayBuffer","byteArray","dicomData","readFile","naturalizeDataset","dict","namifyDataset","meta","multiframe","normalizeToDataset","_createSegFromImages","_getNumberOfFramesPer","segmentIndicies","referencedFramesPerSegment","imageIdSpecificToolState","segIdx","brush","pixelData","_getNumberOfFramesPerSegment","NumberOfFrames","setNumberOfFrames","segmentIndex","referencedFrameIndicies","referencedFrameNumbers","element","segment","addSegment","_extractCornerstoneToolsPixelData","bitPackPixelData","generateToolState","imageIds","imagePlaneModule","warn","validOrientations","iop","orientations","h","v","iop90","getValidOrientations","rowCosines","_toConsumableArray","columnCosines","SharedFunctionalGroupsSequence","sharedImageOrientationPatient","PlaneOrientationSequence","ImageOrientationPatient","sliceLength","Columns","Rows","segMetadata","segmentSequence","SegmentSequence","seriesInstanceUid","ReferencedSeriesSequence","getSegmentMetadata","segType","SegmentationType","unpack","MaximumFractionalValue","onlyMaxAndZero","unpackPixelData","PerFrameFunctionalGroupsSequence","inPlane","PerFrameFunctionalGroups","ImageOrientationPatientI","alignedPixelDataI","alignPixelDataWithSourceData","ndarray","SegmentIdentificationSequence","ReferencedSegmentNumber","addImageIdSpecificBrushToolState","getImageIdOfSourceImage","DerivationImageSequence","SourceImageSequence","referencedFrames","pixelDataIndex","brushPixelData","p","numSegments","pixelData2D","brushDataI","cToolsPixelData","imageIdFrameNumber","Number","getImageIdOfReferencedFrame","getImageIdOfReferencedSingleFramedSOPInstance","compareIOP","Events","dx","iop1","iop2","nearlyEqual","dcmjsData","_utilities$compressio","compression","encode","decode","generateSegmentationDefaultOptions","rleEncode","fillSegmentation","segmentation","inputLabelmaps3D","userOptions","labelmaps3D","numberOfFrames","referencedFramesPerLabelmap","_loop","labelmap3D","labelmapIndex","labelmaps2D","metadata","_loop2","_i","labelmap2D","segmentsOnLabelmap","segmentMetadata","labelmaps","_getLabelmapsFromReferencedFrameIndicies","addSegmentFromLabelmap","rleEncodedFrames","assignToDataset","BitsAllocated","BitsStored","HighBit","SegmentationFractionalType","frame","_generateToolState","_regeneratorRuntime","mark","_callee","_options$skipOverlapp","skipOverlapping","_options$tolerance","tolerance","_options$TypedArrayCo","TypedArrayConstructor","_options$maxBytesPerC","maxBytesPerChunk","eventTarget","triggerEvent","pixelDataChunks","sopUIDImageIdIndexMap","overlapping","insertFunction","segmentsOnFrameArray","segmentsOnFrame","arrayBufferLength","labelmapBufferArray","imageIdMaps","segmentsPixelIndices","overlappingSegments","centroidXYZ","wrap","_context","prev","next","abrupt","checkOrientation","reduce","acc","checkSEGsOverlapping","t0","insertOverlappingPixelDataPlanar","insertPixelDataPlanar","BYTES_PER_ELEMENT","curr","indices","Map","sent","imageIdIndexBufferIndex","_calculateCentroid","calculateCentroid","xAcc","yAcc","zAcc","count","set","floor","centroids","stop","apply","findReferenceSourceImageId","frameSegment","FrameOfReferenceUID","PerFrameFunctionalGroup","frameSourceImageSequence","getImageIdOfSourceImageBySourceImageSequence","ReferencedSeriesInstanceUID","PlanePositionSequence","ImagePositionPatient","imageIdsIndexc","sourceImageMetadata","compareArrays","getImageIdOfSourceImagebyGeometry","groupsLen","frameSegmentsMapping","_loop3","getSegmentIndex","imageIdIndex","findIndex","has","segmentArray","_step","_iterator","_createForOfIteratorHelper","entries","s","n","done","role","temp2DArray","fill","view","readFromUnpackedChunks","j","len","err","e","f","M","m","tempBuffer","slice","tempSegmentsOnFrame","cloneDeep","numberOfSegs","segmentIndexToProcess","_loop4","_i2","byteOffset","labelmap2DView","segmentOnFrame","chunkSize","ceil","shouldTriggerEvent","Promise","resolve","processInChunks","min","indexCache","segmentIndexObject","percentComplete","round","SEGMENTATION_LOAD_PROGRESS","setTimeout","sourceDataDimensions","some","operation","absDotColumnCosines","absDotRowCosines","checkIfPerpendicular","error","bitArray","chunks","maxBitsPerChunk","numberOfChunks","startBit","endBit","startByte","endByte","chunk","unpackedChunk","getUnpackedChunks","array1","array2","offset","mapping","totalBytes","total","startChunkIndex","startOffsetInChunk","endChunkIndex","endOffsetInChunk","chunkIndex","getUnpackedOffsetAndLength","result","resultOffset","_i3","_Object$entries","_Object$entries$_i","bufferIndices","_step2","_iterator2","bufferIndex","_x","_x2","_x3","_x4","labelmaps3DorBrushData","cornerstoneToolsVersion","Segmentation_4X","Segmentation_3X","CornerstoneSR","CornerstoneSEG","__assign","t","prototype","hasOwnProperty","call","this","__spreadArray","to","pack","ar","l","SuppressedError","CodingScheme","codeValues","worldToImageCoords","cornersoneFreeTextCodingValue","Cornerstone3DCodingScheme","freeTextLabel","fs","generateDatasetMeta","sopInstanceUIDToImageIdMap","referencedImageId","annotation","annotationUID","frameOfReferenceUID","label","getCornerstoneLabelFromDefaultState","sopInstanceUIDsToSeriesInstanceUIDMap","derivationSourceDatasets","instance","dsd","generateDerivationSourceDataset","tid1500MeasurementReport","imageToWorldCoords","measurementGroupContentSequence","TrackingUniqueIdentifierGroup","TrackingUniqueIdentifierValue","UID","TrackingUniqueIdentifier","CORNERSTONE_3D_TAG","worldCoords","point","imagePixelModule","xOffset","yOffset","secondPoint","arrowFirst","activeHandleIndex","_data$handles","pointImage","cornerstone3DTag","width","shortAxisPoints","longAxisPoints","firstPointPairs","secondPointPairs","longAxisStartImage","longAxisEndImage","shortAxisStartImage","shortAxisEndImage","MEASUREMENT_TYPE","angle","start1","end1","trackingIdentifier","toLowerCase","CircleROI","pointsWorld","worldPos","EPSILON","EllipticalROI","majorAxisStart","majorAxisEnd","minorAxisStart","minorAxisEnd","majorAxisVec","minorAxisVec","columnCosinesVec","projectedMajorAxisOnColVec","projectedMinorAxisOnColVec","absoluteOfMajorDotProduct","absoluteOfMinorDotProduct","ellipsePoints","top","bottom","left","right","rotation","TOOLTYPE","RectangleROI","corners","_defineProperty","_data$cachedStats","PLANARFREEHANDROI","PlanarFreehandROI","isOpenContour","pop","polyline","firstPoint","PROBE","Probe","generateToolStateCornerstoneLegacy","scalarData","dimensions","segmentsOnLabelmap3D","Set","add","image","SOPClassUID","SopClassUID","SOPInstanceUID","SopInstanceUID","getPixelData","_createMultiframeSegmentationFromReferencedImages","SharedArrayBufferModes","constructor","listeners","reset","addEventListenerOnce","callback","onceWrapper","event","removeEventListener","addEventListener","indexOf","stack","stackLength","splice","dispatchEvent","defaultPrevented","fastDeepEqual","equal","a","b","RegExp","source","flags","valueOf","toString","toStr","isArguments","str","isArgs","callee","require$$0","origKeys","keysShim","o","isEnumerable","propertyIsEnumerable","hasDontEnumBug","hasProtoEnumBug","dontEnums","equalsConstructorPrototype","ctor","excludedKeys","$applicationCache","$console","$external","$frame","$frameElement","$frames","$innerHeight","$innerWidth","$onmozfullscreenchange","$onmozfullscreenerror","$outerHeight","$outerWidth","$pageXOffset","$pageYOffset","$parent","$scrollLeft","$scrollTop","$scrollX","$scrollY","$self","$webkitIndexedDB","$webkitStorageInfo","$window","hasAutomationEqualityBug","k","object","isObject","isFunction","isString","theKeys","TypeError","skipProto","name","skipConstructor","equalsConstructorPrototypeIfNotBuggy","implementation","require$$1","originalKeys","shim","keysWorksWithArguments","objectKeys","origSymbol","Symbol","hasSymbolSham","getOwnPropertySymbols","iterator","obj","sym","symObj","getOwnPropertyNames","syms","getOwnPropertyDescriptor","descriptor","enumerable","test","foo","$Object","concatty","arr","that","target","bound","arrLike","slicy","boundLength","boundArgs","Function","joiner","joiny","Empty","functionBind","bind","$hasOwn","hasown","$SyntaxError","SyntaxError","$Function","$TypeError","getEvalledConstructor","expressionSyntax","$gOPD","throwTypeError","ThrowTypeError","calleeThrows","gOPDthrows","hasSymbols","hasProto","__proto__","getProto","getPrototypeOf","needsEval","TypedArray","INTRINSICS","AggregateError","Atomics","BigInt","BigInt64Array","BigUint64Array","Boolean","DataView","Date","decodeURI","decodeURIComponent","encodeURI","encodeURIComponent","eval","EvalError","Float32Array","Float64Array","FinalizationRegistry","Int8Array","Int16Array","Int32Array","isFinite","isNaN","JSON","parseFloat","parseInt","Proxy","RangeError","ReferenceError","Reflect","SharedArrayBuffer","Uint8ClampedArray","Uint16Array","Uint32Array","URIError","WeakMap","WeakRef","WeakSet","errorProto","doEval","fn","gen","LEGACY_ALIASES","require$$2","hasOwn","require$$3","$concat","$spliceApply","$replace","replace","$strSlice","$exec","exec","rePropName","reEscapeChar","getBaseIntrinsic","allowMissing","alias","intrinsicName","getIntrinsic","parts","string","first","last","match","number","quote","subString","stringToPath","intrinsicBaseName","intrinsic","intrinsicRealName","skipFurtherCaching","isOwn","part","desc","$defineProperty","hasPropertyDescriptors","hasArrayLengthDefineBug","hasPropertyDescriptors_1","GetIntrinsic","gopd","defineDataProperty","property","nonEnumerable","nonWritable","nonConfigurable","loose","configurable","writable","supportsDescriptors","defineProperty","predicate","defineProperties","predicates","props","defineProperties_1","self","implementation_browserModule","exports","polyfill","global","define","getPolyfill","globalThis","getGlobal","vtkGlobal","globalThisShim","factoryMapping","vtkObject","vtk","isA","vtkClass","model","keyName","newInst","modified","register","vtkClassName","ClassHierarchy","super","globalMTime","VOID","fakeConsole","noOp","methodName","loggerFunctions","debug","info","setLoggerFunction","vtkLogMacro","vtkInfoMacro","vtkDebugMacro","vtkErrorMacro","vtkWarningMacro","ERROR_ONCE_MAP","vtkOnceErrorMacro","TYPED_ARRAYS","create","newTypedArray","_len","_key","newTypedArrayFrom","_len2","_key2","capitalize","charAt","toUpperCase","_capitalize","uncapitalize","formatBytesToProperUnit","size","precision","units","currentUnit","toFixed","formatNumbersWithThousandSeparator","separator","sections","reverse","join","safeArrays","getStateArrayMapFunc","item","getState","setImmediateVTK","measurePromiseExecution","promise","performance","now","finally","delta","publicAPI","callbacks","isInteger","mtime","classHierarchy","hierarchy","off","isDeleted","deleted","otherMTime","getMTime","onModified","freeze","unsubscribe","on","className","getClassName","depth","noWarning","noFunction","ret","_len3","list","_key3","subset","getReferenceByName","val","delete","field","el","jsonArchive","values","sortedObj","sort","shallowCopy","other","otherModel","keyList","keyIdx","toJSON","objectGetterMap","fieldNames","getter","objectSetterMap","enum","onChanged","previousValue","DeepEqual","findSetter","fields","setGet","getArray","setArray","defaultVal","_len4","_key4","changeDetected","array","needCopy","otherArray","setGetArray","moveToProtected","fieldName","algo","numberOfInputs","numberOfOutputs","setInputData","port","inputData","inputConnection","setInputConnection","outputPort","msg","getPortToFill","portToFill","getOutputData","shouldUpdate","update","output","inputArrayToProcess","localMTime","minOutputMTime","Infinity","mt","getInputData","addInputData","addInputConnection","getInputConnection","getOutputPort","outputPortAccess","ins","requestData","getNumberOfInputPorts","getNumberOfOutputPorts","getInputArrayToProcess","inputPort","arrayDesc","ds","fieldAssociation","arrayName","setInputArrayToProcess","attributeType","EVENT_ABORT","eventName","previousDelete","curCallbackID","callbackID","cbID","currentCallbacks","cb","priority","cb1","cb2","_ref","newInstance","extend","chain","_len5","_key5","_len6","_key6","isVtkObject","traverseInstanceTree","extractFunction","accumulator","visitedInstances","modelObj","subObj","debounce","func","wait","immediate","_this","timeout","debounced","_len7","_key7","context","callNow","clearTimeout","later","cancel","throttle","delay","isThrottled","argsToUse","wrapper","_len8","_key8","keystore","initialKeystore","setKey","getKey","getAllKeys","deleteKey","clearKeystore","nextProxyId","ROOT_GROUP_NAME","proxy","parentDelete","proxyId","ui","parse","stringify","propertyMap","groupChildrenNames","registerProperties","descriptionList","currentGroupName","childrenNames","children","getProperties","groupName","id","propertyNames","listProxyProperties","method","prop","updateUI","updateProxyProperty","propertyName","propUI","activate","proxyManager","setActiveMethod","getProxyGroup","propertyLinkSubscribers","registerPropertyLinkForGC","otherLink","gcPropertyLinks","subscribers","unbind","propertyLinkMap","getPropertyLink","persistent","links","updateInProgress","force","needUpdate","sourceLink","newValue","shallowEquals","linkToUpdate","indexToDelete","subscription","linkHandler","updateMe","listPropertyNames","getPropertyByName","getPropertyDomainByName","domain","getProxySection","proxyGroup","properties","updateOnBind","sLink","proxyPropertyMapping","subscriptions","modelKey","methodSrc","methodDst","proxyPropertyState","defaults","applyState","modelKeys","normalizeWheel","wheelEvent","sX","sY","pX","pY","detail","wheelDelta","wheelDeltaY","wheelDeltaX","axis","HORIZONTAL_AXIS","deltaY","deltaX","deltaMode","spinX","spinY","pixelX","pixelY","macro","enumToString","getCurrentGlobalMTime","setImmediate","macro$1","module","Alea","seed","me","mash","charCodeAt","Mash","s0","c","s1","s2","copy","impl","opts","xg","prng","int32","double","quick","amd","alea","XorGen","strseed","w","xor128","d","xorwow","X","init","xorshift7","limit","xor4096","tychei","pool","math","nodecrypto","rngname","startdenom","significance","overflow","mask","seedrandom","shortseed","mixkey","flatten","entropy","tostring","out","randomBytes","crypto","msCrypto","getRandomValues","browser","navigator","plugins","screen","autoseed","arc4","ARC4","g","S","pass","is_math_call","keylen","r","typ","smear","stringseed","fromCharCode","random","ex","require$$4","require$$5","sr","VTK_SMALL_NUMBER","createArray","res","nearestPowerOfTwo","xi","isPowerOfTwo","subtract","multiplyAccumulate","scalar","dot","cross","Zx","Zy","Zz","norm","sum","distance2BetweenPoints","determinant2x2","NaN","roundNumber","num","digits","sig","roundVector","vector","solveLinearSystem","A","det","largest","temp1","temp2","maxI","scale","luFactorLinearSystem","ii","idx","luSolveLinearSystem","clampValue","minValue","maxValue","clampVector","minVector","maxVector","VtkDataTypes","CHAR","SIGNED_CHAR","UNSIGNED_CHAR","SHORT","UNSIGNED_SHORT","INT","UNSIGNED_INT","FLOAT","DOUBLE","Constants","DataTypeByteSize","DefaultDataType","fastComputeRange","numberOfComponents","MAX_VALUE","computeRange","component","numberOfValues","nextJ","ensureRangeSize","rangeArray","ranges","getDataType","typedArray","STATIC","createRangeHelper","mean","getRange","getMaxNorm","normArray","numComps","getNumberOfComponents","maxNorm","tuple","getNumberOfTuples","getTuple","norm$1","DEFAULT_VALUES","dataType","rangeTuple","initialValues","empty","resize","requestedNumTuples","curNumTuples","oldValues","dataChange","newSize","initialize","getElementComponentSize","getComponent","tupleIdx","compIdx","setComponent","getValue","valueIdx","comp","setValue","getData","subarray","componentIndex","rangeIdx","range","setRange","rangeValue","setTuple","setTuples","tuples","insertTuple","insertTuples","insertNextTuple","insertNextTuples","findTuple","tupleToFill","getTuples","fromId","toId","getTupleLocation","getNumberOfValues","newClone","getName","setData","deepCopy","currentType","currentArray","interpolateTuple","source1","source1Idx","source2","source2Idx","tuple1","tuple2","vtkDataArray","newInstance$1","vtkDataArray$1","CustomEvent","cancelable","imageIdToURI","colonIndex","substring","TRUE","config","gpuTier","detectGPUConfig","rendering","useCPURendering","preferSizeOverAccuracy","useNorm16Texture","strictZSpacingForVolumeViewport","enableCacheOptimization","PLANE_TOLERANCE","COINCIDE","DISJOINT","distanceToPlane","origin","normal","projectPoint","xproj","xo","projectVector","vproj","n2","generalizedProjectPoint","intersectWithLine","p1","p2","outObj","intersection","betweenPoints","p21","p1Origin","den","fabsden","fabstolerance","intersectWithPlane","plane1Origin","plane1Normal","plane2Origin","plane2Normal","l0","l1","cross$1","absCross","maxc","iP","d1","d2","evaluate","evaluateFunction","evaluateGradient","xyz","planeOrigin","planeNormal","vtkPlane","vtkPlane$1","INIT_BOUNDS","equals","isValid","bounds","setBounds","otherBounds","addPoint","xMin","xMax","yMin","yMax","zMin","zMax","addPoints","addBounds","_xMin","_xMax","_yMin","_yMax","_zMin","_zMax","setMinPoint","setMaxPoint","inflate","sx","sy","sz","getCenter","getLength","getLengths","getXRange","getYRange","getZRange","getMaxLength","getDiagonalLength","getMinPoint","getMaxPoint","oppositeSign","getCorners","ix","iy","iz","computeCornerPoints","transformBounds","transform","vec3","computeScale3","scale3","computeLocalBounds","u","pointsData","du","dv","dw","intersectBox","dir","coord","inside","quadrant","whichPlane","maxT","candidatePlane","intersectPlane","sign","firstOne","intersect","bBounds","newBounds","intersects","containsPoint","cutWithPlane","ti","BoundingBox","refBounds","getBounds","contains","vtkBoundingBox","scaleAboutCenter","arrays","copyFieldFlags","doCopyAllOn","doCopyAllOff","superGetState","initializeFields","copyAllOn","clearFieldFlags","copyStructure","getCopyFieldFlags","getNumberOfArrays","getNumberOfActiveArrays","addArray","getArrayWithIndex","removeAllArrays","removeArray","removeArrayByIndex","arrayIdx","getArrays","entry","arraySpec","getArrayByIndex","getArrayByName","hasArray","getArrayName","getFlag","passData","copyFlag","destArr","tId","getAttributes","attrType","setAttribute","ncomps","interpolateData","fromId1","fromId2","copyFieldOn","copyFieldOff","copyAllOff","arrNew","copyFlags","vtkFieldData","vtkFieldData$1","COPYTUPLE","INTERPOLATE","PASSDATA","ALLCOPY","AttributeLimitTypes","MAX","EXACT","NOLIMIT","SCALARS","VECTORS","NORMALS","TCOORDS","TENSORS","GLOBALIDS","PEDIGREEIDS","EDGEFLAG","NUM_ATTRIBUTES","CellGhostTypes","DUPLICATECELL","HIGHCONNECTIVITYCELL","LOWCONNECTIVITYCELL","REFINEDCELL","EXTERIORCELL","HIDDENCELL","DesiredOutputPrecision","DEFAULT","SINGLE","PointGhostTypes","DUPLICATEPOINT","HIDDENPOINT","ghostArrayName","AttributeTypes","AttributeCopyOperations","activeScalars","activeVectors","activeTensors","activeNormals","activeTCoords","activeGlobalIds","activePedigreeIds","attrTypes","cleanAttributeType","attType","cleanAttType","ee","superClass","checkNumberOfComponents","uncleanAttType","currentAttribute","setActiveAttributeByName","setActiveAttributeByIndex","getActiveAttribute","activeVal","da","copyAttributeFlags","initializeAttributeCopyFlags","op","attCopyOp","ty","dataArrays","ref","superShallowCopy","vtkDataSetAttributes","vtkDataSetAttributes$1","FieldDataTypes","UNIFORM","DATA_OBJECT_FIELD","COORDINATE","POINT_DATA","POINT","POINT_FIELD_DATA","CELL","CELL_FIELD_DATA","VERTEX","VERTEX_FIELD_DATA","EDGE","EDGE_FIELD_DATA","ROW","ROW_DATA","FieldAssociations","FIELD_ASSOCIATION_POINTS","FIELD_ASSOCIATION_CELLS","FIELD_ASSOCIATION_NONE","FIELD_ASSOCIATION_POINTS_THEN_CELLS","FIELD_ASSOCIATION_VERTICES","FIELD_ASSOCIATION_EDGES","FIELD_ASSOCIATION_ROWS","NUMBER_OF_ASSOCIATIONS","DATASET_FIELDS","vtkDataSet","vtkDataSet$1","StructuredType","UNCHANGED","SINGLE_POINT","X_LINE","Y_LINE","Z_LINE","XY_PLANE","YZ_PLANE","XZ_PLANE","XYZ_GRID","EMPTY","vtkStructuredData","getDataDescriptionFromExtent","inExt","dataDim","direction","indexToWorld","worldToIndex","spacing","extent","dataDescription","mat3","setExtent","inExtent","extentArray","setDimensions","getDimensions","getNumberOfCells","nCells","getNumberOfPoints","getPoint","ijk","coords","extentToBounds","getSpatialExtent","computeTransforms","mat4","ain","aout","indexToWorldVec3","worldToIndexVec3","indexToWorldBounds","bin","bout","worldToIndexBounds","computeHistogram","worldBounds","voxelFunc","yStride","zStride","pixels","getPointData","getScalars","maximum","minimum","sumOfSquares","isum","inum","pixel","average","variance","sigma","computeIncrements","increments","incr","computeOffsetIndex","getExtent","getOffsetIndexFromWorld","getScalarValueFromWorld","offsetIndex","vtkImageData","vtkImageData$1","CLAMP_TO_EDGE","REPEAT","MIRRORED_REPEAT","Filter","NEAREST","LINEAR","NEAREST_MIPMAP_NEAREST","NEAREST_MIPMAP_LINEAR","LINEAR_MIPMAP_NEAREST","LINEAR_MIPMAP_LINEAR","floatView","int32View","HalfFloat","fromHalf","toHalf","bits","renderable","myFactory","visited","_renderableChildMap","build","prepass","render","traverse","renderPass","passTraversal","getTraverseOperation","customRenderPass","getOperation","getViewNodeFor","dataObject","vn","getFirstAncestorOfType","_parent","addMissingNode","dobj","setVisited","newNode","createViewNode","setParent","addMissingNodes","dataObjs","addMissingChildren","child","prepareNodes","removeUnusedNodes","visitedCount","getVisited","getRenderable","dataObj","createNode","setRenderable","vtkViewNode","vtkViewNode$1","PASS_TYPES","overrides","cpt","setMyFactory","registerOverride","vtkViewNodeFactory","vtkViewNodeFactory$1","CLASS_MAPPING","vtkOpenGLViewNodeFactory","Wrap","vtkOpenGLTexture","updateArrayDataType","pixData","pixCount","height","components","openGLDataType","dataArrayToCopy","UNSIGNED_BYTE","halfFloat","_openGLRenderWindow","getWebgl2","HALF_FLOAT","halfFloatExt","getExtension","HALF_FLOAT_OES","newArray","src","scaleTextureToHighestPowerOfTwo","newWidth","newHeight","jFactor","iFactor","usingHalf","joff","jidx","jlow","jhi","jmix","jmix1","ioff","iidx","ilow","ihi","imix","useTexStorage","resizable","getResizable","getGLInformations","RENDERER","platform","oglNorm16Ext","processDataArray","dataArray","minArray","maxArray","scaleOffsets","computeScaleOffsets","getOpenGLDataType","useHalfFloat","isHalfFloat","hasExactHalfFloat","setUseHalfFloat","renWin","_openGLRenderer","getParent","getContext","getInterpolate","generateMipmap","setMinificationFilter","setMagnificationFilter","getRepeat","setWrapR","setWrapS","setWrapT","setImage","handle","textureBuildTime","getImage","getImageLoaded","create2DFromImage","sendParameters","getCanvas","canvas","create2DFromRaw","getJsImageData","jsid","input","ext","inScalars","indata","scalars","createCubeFromRaw","destroyTexture","deactivate","deleteTexture","numberOfDimensions","resetFormatAndType","createTexture","bindTexture","texParameteri","TEXTURE_MIN_FILTER","getOpenGLFilterMode","minificationFilter","TEXTURE_MAG_FILTER","magnificationFilter","TEXTURE_WRAP_S","getOpenGLWrapMode","wrapS","TEXTURE_WRAP_T","wrapT","TEXTURE_WRAP_R","wrapR","getTextureUnit","getTextureUnitForTexture","activateTexture","deactivateTexture","releaseGraphicsResources","rwin","internalFormat","format","allocatedGPUMemoryInBytes","shaderProgram","autoParameters","sendParametersTime","isBound","TEXTURE_2D","TEXTURE_BINDING_2D","getIntegerv","TEXTURE_BASE_LEVEL","baseLevel","TEXTURE_MAX_LEVEL","maxLevel","getInternalFormat","vtktype","_forceInternalFormat","getDefaultInternalFormat","getDefaultTextureInternalFormat","setInternalFormat","iFormat","getFormat","getDefaultFormat","RED","RG","RGB","RGBA","LUMINANCE","LUMINANCE_ALPHA","getDefaultDataType","vtkScalarType","forceUpdate","getShiftAndScale","shift","BYTE","emode","flip","scaledData","pixelStorei","UNPACK_FLIP_Y_WEBGL","UNPACK_ALIGNMENT","texStorage2D","texSubImage2D","texImage2D","getDefaultTextureByteSize","TEXTURE_CUBE_MAP","invertedData","widthLevel","heightLevel","row1","row2","tempData","TEXTURE_CUBE_MAP_POSITIVE_X","createDepthFromRaw","DEPTH_COMPONENT","DEPTH_COMPONENT32F","DEPTH_COMPONENT16","needNearestPowerOfTwo","ctx","translate","drawImage","safeImage","create2DFilterableFromRaw","create2DFilterableFromDataArray","create3DFromRaw","TEXTURE_3D","texStorage3D","texSubImage3D","texImage3D","create3DFilterableFromRaw","create3DFilterableFromDataArray","numPixelsIn","volumeInfo","dataComputedScale","dataComputedOffset","scaleOffsetsCopy","structuredClone","scaleInverse","nc","volCopyData","outArray","outIdx","inValue","smin","smax","dataTypeToUse","soffset","sscale","maxTexDim","getParameter","MAX_TEXTURE_SIZE","xstride","ystride","targetWidth","xreps","yreps","targetHeight","tileWidth","tileHeight","yRep","xrepsThisRow","outXContIncr","tileY","xRep","inOffset","tileX","setOpenGLRenderWindow","rw","getMaximumTextureSize","isCurrent","minLOD","maxLOD","vtkOpenGLTexture$1","INVALID_BOUNDS","setNumberOfPoints","nbPoints","dimension","setNumberOfComponents","setPoint","findPoint","insertNextPoint","xRange","yRange","zRange","computeBounds","vtkPoints","vtkPoints$1","extractCellSizes","cellArray","currentIdx","cellId","cellArrayIndex","defaultValues","recompute","numberOfCells","cellSizes","getCellSizes","oldNumTuples","newNumTuples","getCell","loc","cellLoc","numberOfPoints","insertNextCell","cellPointIds","vtkCellArray","vtkCellArray$1","pointsIds","pointIdsList","triangleData","pointId","pointOffset","trianglePointOffset","getLength2","diff","getParametricDistance","pcoords","pDist","pDistMax","cell","getCellDimension","tol","subId","evaluatePosition","closestPoint","dist2","weights","vtkCell","vtkCell$1","maxId","buildLinks","numPts","getPoints","numCells","linkLoc","getCellPoints","cellPointId","incrementLinkCount","allocateLinks","insertCellReference","getPointsIds","allocate","numLinks","ncells","cells","getLink","ptId","getNcells","getCells","insertNextCellReference","deletePoint","removeCellReference","addCellReference","resizeCellList","squeeze","pos","vtkCellLinks","vtkCellLinks$1","CellType","VTK_EMPTY_CELL","VTK_VERTEX","VTK_POLY_VERTEX","VTK_LINE","VTK_POLY_LINE","VTK_TRIANGLE","VTK_TRIANGLE_STRIP","VTK_POLYGON","VTK_PIXEL","VTK_QUAD","VTK_TETRA","VTK_VOXEL","VTK_HEXAHEDRON","VTK_WEDGE","VTK_PYRAMID","VTK_PENTAGONAL_PRISM","VTK_HEXAGONAL_PRISM","VTK_QUADRATIC_EDGE","VTK_QUADRATIC_TRIANGLE","VTK_QUADRATIC_QUAD","VTK_QUADRATIC_POLYGON","VTK_QUADRATIC_TETRA","VTK_QUADRATIC_HEXAHEDRON","VTK_QUADRATIC_WEDGE","VTK_QUADRATIC_PYRAMID","VTK_BIQUADRATIC_QUAD","VTK_TRIQUADRATIC_HEXAHEDRON","VTK_QUADRATIC_LINEAR_QUAD","VTK_QUADRATIC_LINEAR_WEDGE","VTK_BIQUADRATIC_QUADRATIC_WEDGE","VTK_BIQUADRATIC_QUADRATIC_HEXAHEDRON","VTK_BIQUADRATIC_TRIANGLE","VTK_CUBIC_LINE","VTK_CONVEX_POINT_SET","VTK_POLYHEDRON","VTK_PARAMETRIC_CURVE","VTK_PARAMETRIC_SURFACE","VTK_PARAMETRIC_TRI_SURFACE","VTK_PARAMETRIC_QUAD_SURFACE","VTK_PARAMETRIC_TETRA_REGION","VTK_PARAMETRIC_HEX_REGION","VTK_HIGHER_ORDER_EDGE","VTK_HIGHER_ORDER_TRIANGLE","VTK_HIGHER_ORDER_QUAD","VTK_HIGHER_ORDER_POLYGON","VTK_HIGHER_ORDER_TETRAHEDRON","VTK_HIGHER_ORDER_WEDGE","VTK_HIGHER_ORDER_PYRAMID","VTK_HIGHER_ORDER_HEXAHEDRON","VTK_LAGRANGE_CURVE","VTK_LAGRANGE_TRIANGLE","VTK_LAGRANGE_QUADRILATERAL","VTK_LAGRANGE_TETRAHEDRON","VTK_LAGRANGE_HEXAHEDRON","VTK_LAGRANGE_WEDGE","VTK_LAGRANGE_PYRAMID","VTK_NUMBER_OF_CELL_TYPES","CellTypesStrings","getClassNameFromTypeId","typeId","getTypeIdFromClassName","cellTypeString","isLinear","hasSubCells","cellType","typeArray","locationArray","insertCell","setCellTypes","cellTypes","cellLocations","getCellLocation","deleteCell","getNumberOfTypes","isType","numTypes","getCellType","insertNextType","getSize","getExtend","getTypeArray","getLocationArray","getMaxId","vtkCellTypes","vtkCellTypes$1","IntersectionState","NO_INTERSECTION","YES_INTERSECTION","ON_LINE","distanceToLine","MIN_VALUE","closest","denom","a1","a2","b1","b2","a21","b21","b1a1","minDist","l2","projXYZ","outDistance","evaluateLocation","evaluateOrientation","q","quat","vtkLine","vtkLine$1","vtkPointSet","vtkPointSet$1","computeNormalDirection","v1","v2","v3","ax","ay","az","bx","by","bz","computeNormal","intersectWithTriangle","q1","r1","q2","r2","coplanar","pt1","pt2","surfaceId","n1","dist1","pts1","pts2","n1n2","normalize","index1","index2","t1","t2","tt1","tt2","ts1","ts2","id1","id2","val1","val2","t12","t22","t11","t21","tol2","pt3","plane","evaluation","dist2Pt1Pt2","dist2Pt2Pt3","dist2Pt3Pt1","line","intersectLine","pt3Pt1","pt3Pt2","pt3X","fabsn","rhs","c1","c2","dist2Point","dist2Line1","dist2Line2","closestPoint1","closestPoint2","cp","maxComponent","lineDistance","p0","u3","pc","vtkTriangle","vtkTriangle$1","POLYDATA_FIELDS","CELL_FACTORY","letter","buildCells","nVerts","getNumberOfVerts","nLines","getNumberOfLines","nPolys","getNumberOfPolys","nStrips","getNumberOfStrips","types","pTypes","locs","pLocs","nextCellPts","verts","numCellPts","lines","polys","strips","initialSize","getPointCells","getCellEdgeNeighbors","link1","link2","cellHint","cellInfo","vtkPolyData","vtkPolyData$1","vtkStreamingOpenGLTexture","superCreate3DFilterableFromRaw","inputDataType","inputNumComps","update3DFromRaw","updatedFrames","bytesPerVoxel","fillSubImage3D","zOffset","rowLength","gl","blockHeight","multiRowBlockLength","multiRowBlockLengthInBytes","normalBlocks","lastBlockHeight","multiRowLastBlockLength","block","dataView","getTextureParameters","setUpdatedFrame","providers","ImageVolume","_imageIdsIndexMap","_imageURIsIndexMap","cornerstoneImageMetaData","imageCacheOffsetMap","isPreScaled","scaling","volumeId","referencedVolumeId","sizeInBytes","imageData","referencedImageIds","additionalDetails","numVoxels","scalarArray","setSpacing","setDirection","setOrigin","setScalars","numFrames","_getNumFrames","_reprocessImageIds","_createCornerstoneImageMetaData","_imageIds","newImageIds","clear","imageURI","isDynamicVolume","getScalarData","isTypedArray","getImageIdIndex","getImageURIIndex","destroy","getScalarDataArrays","decache","completelyRemove","removeFromCache","convertToImageSlicesAndCache","cache","removeVolumeLoadObject","getScalarDataLength","scalarDataCount","_getScalarDataLength","bytesPerImage","numComponents","pixelsPerImage","PhotometricInterpretation","voiLut","VOILUTFunction","windowCenter","windowWidth","voi","rgba","photometricInterpretation","voiLUTFunction","invert","getScalarDataByImageIdIndex","getCornerstoneImage","imageIdIndexToFrameIndex","volumeBuffer","bytePerPixel","imageScalarData","volumeBufferView","modalityLutModule","queries","provider","metaData","minMax","storedPixelData","storedPixel","numPixels","getMinMax","intercept","rescaleIntercept","byteLength","minPixelValue","maxPixelValue","slope","rescaleSlope","columnPixelSpacing","rowPixelSpacing","convertToCornerstoneImage","getCornerstoneImageLoadObject","getCornerstoneImages","referencedVolume","getVolume","numSlices","_","numImages","bytesRemaining","decacheIfNecessaryUntilBytesAvailable","imageLoadObject","getImageLoadObject","putImageLoadObject","catch","imageOrientationPatient","imagePositionPatient","bitsAllocated","pixelSpacing","genericMetadataProvider","ONE_GB","_imageCache","_volumeCache","_imageCacheSize","_volumeCacheSize","_maxCacheSize","_maxInstanceSize","setMaxCacheSize","newMaxCacheSize","errorMessage","isCacheable","getBytesAvailable","getMaxCacheSize","getMaxInstanceSize","getCacheSize","_decacheImage","cancelFn","_decacheVolume","cachedVolume","volumeLoadObject","volume","cancelLoading","_restoreImagesFromBuffer","purgeCache","imageIterator","removeImageLoadObject","IMAGE_CACHE_IMAGE_REMOVED","purgeVolumeCache","volumeIterator","VOLUME_CACHE_VOLUME_REMOVED","getVolumeLoadObject","timeStamp","getGeometry","geometryId","cachedGeometry","_geometryCache","geometry","cachedImage","incrementImageCacheSize","eventDetails","incrementVolumeCacheSize","putGeometryLoadObject","geometryLoadObject","loaded","then","GEOMETRY_CACHE_GEOMETRY_ADDED","increment","decrementImageCacheSize","decrement","decrementVolumeCacheSize","numBytes","volumeImageIds","bytesAvailable","cachedImages","cachedImageIds","im","imageIdsToPurge","sharedCacheKey","CACHE_SIZE_EXCEEDED","IMAGE_CACHE_IMAGE_ADDED","isLoaded","getVolumeContainingImageId","volumeIds","imageIdToUse","getCachedImageBasedOnImageURI","imageURIToUse","foundImageId","putVolumeLoadObject","VOLUME_CACHE_VOLUME_ADDED","viewPixelData","imageFrame","bufferView","payload","addProvider","SegmentationRepresentations","findNextLink","contourPoints","nextLine","remainingLines","findContours","firstCell","extraContours","findContoursFromReducedSet","ptInArray","pt","isSamePoint","ptA","ptB","replacePointIndexReferences","linesArray","oldIndex","newIndex","removeDuplicatePoints","polyData","bypass","getLines","pointsArray","newPoints","newLines","getIsPointInsidePolygon","vertices","yi","xj","yj","processContourHoles","contours","useXOR","retContours","contour","closedContours","contourWithHoles","contourWithoutHoles","holes","hContour","hIndex","outerContour","innerContour","pointsNotEnclosed","checkEnclosed","contourHoleSet","holeIndex","contourIndex","EdgeLocator","oriented","edgeMap","computeEdgeKey","pointId0","pointId1","insertUniqueEdge","newEdgeValue","node","edgeId","insertEdge","isInsertedEdge","getEdgePointIds","vtkEdgeLocator","MARCHING_SQUARES_CASES","EDGES","vtkCaseTable","getCase","getEdge","eid","vtkImageMarchingSquares","getContourValues","contourValues","setContourValues","cValues","ids","pixelScalars","pixelPts","edgeLocator","getPixelScalars","kernelX","kernelY","getPixelPoints","produceLines","cVal","slicingMode","CASE_MASK","pId","pixelLines","edgeVerts","mergePoints","x0","x1","inData","outData","time","getOrigin","getSpacing","getKernels","cv","polydata","timeEnd","vtkImageMarchingSquares$1","Labelmap","generateContourSetsFromLabelmap","segmentations","representationData","segVolumeId","vol","cornerstoneCache","imageVol","segData","pixelsPerSlice","ContourSets","segIndex","sliceContours","containedSegmentIndices","sliceIndex","isSliceEmptyForSegment","frameStart","mSquares","imageDataCopy","setMergePoints","reducedSet","FrameNumber","ContourSet","startIdx","endIdx","RectangleROIStartEndThreshold","getContourSequence","projectionPoints","projectionPointsImageIds","ContourData","orderedPoints","pointsArrayWithPrecision","flat","ContourImageSequence","sopCommon","getContourImageSequence","NumberOfContourPoints","ContourGeometricType","AnnotationToPointData","TOOL_NAMES","convert","referenceImageId","validateAnnotation","ContourSequence","ReferencedROINumber","ROIDisplayColor","getReferencedFrameOfReferenceSequence","RTReferencedStudySequence","RTReferencedSeriesSequence","ReferencedInstanceSequence","getReferencedSeriesSequence","_index","DicomMetadataStore","series","getSeries","ReferencedSeries","instances","getStructureSetModule","ROINumber","ROIName","ROIDescription","ROIGenerationAlgorithm","ReferencedFrameOfReferenceUID","_initializeDataset","rtMetadata","imgMetadata","rtSOPInstanceUID","patientModule","generalStudyModule","patientStudyModule","patientDemographicModule","Modality","modality","PatientID","patientId","PatientName","patientName","PatientBirthDate","PatientAge","patientAge","PatientSex","patientSex","PatientWeight","patientWeight","StudyDate","studyDate","StudyTime","studyTime","StudyID","AccessionNumber","accessionNumber","getPatientModule","rtSeriesModule","SeriesNumber","getRTSeriesModule","StructureSetROISequence","ROIContourSequence","RTROIObservationsSequence","ReferencedFrameOfReferenceSequence","Manufacturer","PositionReferenceIndicator","StructureSetLabel","StructureSetName","ReferringPhysicianName","OperatorsName","StructureSetDate","date","StructureSetTime","utilities.contours.generateContourSetsFromLabelmap","annotations","ObservationNumber","RTROIInterpretedType","ROIInterpreter","getRTROIObservationsSequence","roiContours","contourSet","sliceContour","sliceContourPolyData","pointData","ContourNumber","segLabel","ROIContour","contourSequence","roiContour","Cornerstone3DSR","CodeScheme","Cornerstone3DSEG","Cornerstone3DRT","RTSS","Colors","adaptersSR","Cornerstone","Cornerstone3D","adaptersSEG","VTKjs","cielab","RecommendedDisplayCIELabValue","dicomlab2RGB","SegmentNumber","functionalGroups","functionalGroup","segmentNumber","frameSize","nextOffset","packedSegment","pixelMeasures","PixelMeasuresSequence","planeOrientation","firstFunctionalGroup","lastFunctionalGroup","firstPosition","lastPosition","PixelSpacing","SpacingBetweenSlices","columnStepToPatient","rowStepToPatient","sliceStep","geometryFromFunctionalGroups","adaptersRT","isBuffer","iota","hasTypedArrays","compare1st","order","stride","terms","compileConstructor","dtype","useGetters","procedure","CACHED_CONSTRUCTORS","index_str","shapeArg","strideArg","a_vars","c_vars","tShape","tStride","shape","arrayDType","ctor_list"],"sourceRoot":""}